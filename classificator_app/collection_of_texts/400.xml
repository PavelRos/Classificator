<?xml version="1.0" ?>
<doc>
	<label auto="true" type="str" verify="true"><![CDATA[Develop]]></label>
	<author auto="true" type="list" verify="true">
		<item type="str"><![CDATA[blognetology]]></item>
	</author>
	<date auto="true" type="str" verify="true"><![CDATA[2022-12-05, 18:26]]></date>
	<link auto="true" type="str" verify="true"><![CDATA[https://habr.com/ru/company/netologyru/blog/703654/]]></link>
	<title auto="true" type="str" verify="true"><![CDATA[Личный опыт: управление роботом с помощью Steam Deck]]></title>
	<categories auto="true" type="list" verify="true">
		<item type="str"><![CDATA[Блог компании Нетология]]></item>
		<item type="str"><![CDATA[Разработка робототехники]]></item>
		<item type="str"><![CDATA[Робототехника]]></item>
		<item type="str"><![CDATA[DIY или Сделай сам]]></item>
	</categories>
	<key_words auto="true" type="list" verify="true">
		<item type="str"><![CDATA[Steamdeck]]></item>
		<item type="str"><![CDATA[steam deck]]></item>
		<item type="str"><![CDATA[роботы]]></item>
		<item type="str"><![CDATA[робототехника]]></item>
		<item type="str"><![CDATA[роботехника]]></item>
		<item type="str"><![CDATA[робот-игрушка]]></item>
		<item type="str"><![CDATA[гексапод]]></item>
		<item type="str"><![CDATA[diy]]></item>
	</key_words>
	<text auto="true" type="str" verify="true"><![CDATA[Привет, меня зовут Станислав Архипенко. Сейчас я работаю в IT, но с раннего детства я был увлечён техникой. Ещё совсем маленьким я подключал батарейки к моторчикам и мечтал о том, что когда-нибудь смогу создавать настоящих роботов. Моя мечта осуществилась. Я не работаю сборщиком роботов, но новенький 3D-принтер позволил мне окунуться в разработку и строительство робот с голов от дизайна и печати 3д деталей, до сборки и пайки, программирования и отладки. В этой статье покажу своего гексапода и расскажу об управлении с помощью игровой консоли Steam Deck. 
Какого робота я собрал и как
На сайте thingiverse.com — огромной коллекции 3д проектов — я случайно обнаружил замечательный проект авторства AlexKorvin. Сочетание интересного внешнего дизайна и  хорошей спецификации со списком деталей и ссылками на магазины, а также открытое программное обеспечение не оставили мне выбора — я решил реализовать проект. Однако при детальном изучении материалов я обнаружил, что Алексей принял несколько конструктивных решений, с которыми я не согласен:
Повышающие преобразователи и однобаночные аккумуляторы в системе питания.
Arduino для управления servo-приводами.
В качестве контроллера — джойстики от playstation 2 и дополнительный китайский модуль для получения сигнала.
Аналоговые приёмник и передатчик для видео.
Мне показалось, что электронику можно сделать проще, поэтому я внёс изменения:
Использовать классический подход для питания в таких случаях: 4-баночный аккумулятор и понижающий преобразователь.
Основной модуль управления — Raspberry Pi Zero W.
Для управления servo использовать две классические платы управления на основе PCA9685. 
Контроллер управления от Xbox One через bluetooth.
С аппаратной частью всё понятно, но вот с программной есть небольшая проблема: программа, которую использует Alex (от совершенно другого проекта) написана под Arduino и не подходит для Raspberry Pi. Самое сложное в этой программе — расчёты положения ног. Мне не хотелось разрабатывать программу с нуля. Во-первых, расчёты положения ног — кропотливая работа, а во-вторых, Alex реализовал ряд классных функций, которые я не хотел терять.
Я не стал переписывать программу с нуля, а вместо этого перевёл код из C в Python3. Во время перевода я не использовал автоматические утилиты-переводчики и ограничился поиском и заменой по тексту. Так я смог привести C-синтаксис в состояние, понятное Python-интерпретатору.
Затем я удалил всё, что связано с аппаратной частью: управления серво, связь с джойстиком — а оставшийся код трансформировал в родительский класс hexapod, который реализовывал вычисления положения ног и логику управления.
Следующим шагом я разработал дочерний класс AcpRobot, в который и включил всё, что связано с аппаратурой. Мне такой подход показался удачным: благодаря разделению на родительский и дочерний классы теперь можно использовать логику управления с разными аппаратными реализациями.
В вопросе операционный системы я пошёл по пути наименьшего сопротивления и применил Raspbian. 
Для Xbox-контроллера я использовал драйвер xpadneo и следующую конфигурацию bluetooth в /etc/bluetooth/main.conf:
[General] 
ControllerMode = dual 
Privacy = device
Чтобы программа управления роботом запускалась автоматически, я написал небольшой сервис для systemd, а позже скрипт, который устанавливает весь Python-код и генерирует systemd-сервис по шаблону. Передачу видео на телефон я решил оставить на потом, мне совсем не хотелось разбираться с мобильной разработкой. Получилось так:
Как я связал робота и Steam Deck
Согласно Википедии, Steam Deck — это портативный игровой компьютер, разработанный Valve Corporation. Мне кажется, что ключевое слово здесь «компьютер», так как эта консоль действительно полноценный, настоящий x86-64 комп с Linux (SteamOS) на борту. На нём даже по умолчанию Python предустановлен! С учётом того, что я так и не решил проблему передачи видео, Steam Deck — идеальный кандидат в качестве нового джойстика управления. Так как мой робот — полноценный компьютер, и Steam Deck — тоже полноценный компьютер, я решил использовать Wi-fi для дистанционного управления. 
Сетевой обмен данными
Для получения сетевого стека я использовал Apache Thrift. Это фреймворк для разработки межъязыковых сервисов, он позволяет генерировать сетевой RPC-код по заданной схеме для десятка разных языков. Моя схема содержала пару структур данных и пять запросов: 
Ping — просто пинг, чтобы проверить, работает ли связь.
Axis — информация о стиках.
Button — информация о нажатых кнопка.
Get_status — статус робота, включает: текущий режим, под режим, статус огней и батареи
Get_logs — передача логов из робота.
Используя схему, я сгенерировал RCP код для сервера — робота и клиента — Steam Deck. Далее использовал его для обмена данными.
Пользовательский интерфейс
Для меня пользовательский интерфейс — случай, когда задача казалась очень сложной, а вышла очень простой. Я использовал PySimpleGUI, с помощью которого элементарно строить пользовательский интерфейс. Немного магии, 200 строк кода, и UI модуль готов!
RC — адрес сервера удалённого управления (RC — remote control).
VD — адрес видео стрима (VD — video).
M: CALI — означает текущий режим (mode) — калибровка (calibration).
SM: NA — текущий под-режим (sub-mode) отсутствует (NA означает Not Available).
Speed: FAST — текущий скоростной режим переключён в положение «быстро».
L1 и L2 — свет (Light) 1 и 2 активированы.
View: LOGS — переключение между режимом отображения журнала (Log) или видео.
Видеострим
Со стороны робота я использовал камеру raspberry pi camera v2. Для захвата изображения я использовал ustreamer — лёгкий и быстрый сервер для потоковой передачи видео MJPEG с устройств V4L2 в сеть. К сожалению, в репозиториях rasbian нет пакета с ustreamer, однако сборка из исходных кодов оказалось элементарной:
export WITH_SYSTEMD=1

sudo apt install libevent-dev libjpeg9-dev libbsd-dev libsystemd-dev

git clone https://github.com/pikvm/ustreamer.git

cd ustreamer

make
Для запуска сервера я использую следующие флаги:
--host $(hostname) \

--port  9999 \

--format=uyvy \

--encoder=m2m-image \

--workers=3 \

--persistent \

--dv-timings \

--drop-same-frames 30 \

--desired-fps 24
Со стороны Steam Deck я использовал urllib для чтения потока данных и opencv-python для конвертации изображения в подходящий формат.
Что есть сейчас и что ещё нужно сделать
Проект ещё не доведён до конца: надо избавиться от багов, завернуть Python-код в пакеты, оптимизировать видеострим. Но ключевые функции уже работают и радуют. 
Если вы решите повторить мой путь, эти ссылки вам помогут:
Моя инструкция по сборке робота.
Проект на github.
Дополнительные STL — файлы для установки raspberry pi и pwm модулей.
Видео по сборке похожего робота от AlexKorvin — изначального автора проекта. Привет, меня зовут Станислав Архипенко. Сейчас я работаю в IT, но с раннего детства я был увлечён техникой. Ещё совсем маленьким я подключал батарейки к моторчикам и мечтал о том, что когда-нибудь смогу создавать настоящих роботов. Моя мечта осуществилась. Я не работаю сборщиком роботов, но новенький 3D-принтер позволил мне окунуться в разработку и строительство робот с голов от дизайна и печати 3д деталей, до сборки и пайки, программирования и отладки. В этой статье покажу своего гексапода и расскажу об управлении с помощью игровой консоли Steam Deck.  Какого робота я собрал и как На сайте thingiverse.com — огромной коллекции 3д проектов — я случайно обнаружил замечательный проект авторства AlexKorvin. Сочетание интересного внешнего дизайна и  хорошей спецификации со списком деталей и ссылками на магазины, а также открытое программное обеспечение не оставили мне выбора — я решил реализовать проект. Однако при детальном изучении материалов я обнаружил, что Алексей принял несколько конструктивных решений, с которыми я не согласен: thingiverse.com проект Повышающие преобразователи и однобаночные аккумуляторы в системе питания.
Arduino для управления servo-приводами.
В качестве контроллера — джойстики от playstation 2 и дополнительный китайский модуль для получения сигнала.
Аналоговые приёмник и передатчик для видео. Повышающие преобразователи и однобаночные аккумуляторы в системе питания. Повышающие преобразователи и однобаночные аккумуляторы в системе питания. Arduino для управления servo-приводами. Arduino для управления servo-приводами. В качестве контроллера — джойстики от playstation 2 и дополнительный китайский модуль для получения сигнала. В качестве контроллера — джойстики от playstation 2 и дополнительный китайский модуль для получения сигнала. Аналоговые приёмник и передатчик для видео. Аналоговые приёмник и передатчик для видео. Мне показалось, что электронику можно сделать проще, поэтому я внёс изменения: Использовать классический подход для питания в таких случаях: 4-баночный аккумулятор и понижающий преобразователь.
Основной модуль управления — Raspberry Pi Zero W.
Для управления servo использовать две классические платы управления на основе PCA9685. 
Контроллер управления от Xbox One через bluetooth. Использовать классический подход для питания в таких случаях: 4-баночный аккумулятор и понижающий преобразователь. Использовать классический подход для питания в таких случаях: 4-баночный аккумулятор и понижающий преобразователь. Основной модуль управления — Raspberry Pi Zero W. Основной модуль управления — Raspberry Pi Zero W. Для управления servo использовать две классические платы управления на основе PCA9685.  Для управления servo использовать две классические платы управления на основе PCA9685.  классические платы управления на основе PCA9685 Контроллер управления от Xbox One через bluetooth. Контроллер управления от Xbox One через bluetooth. С аппаратной частью всё понятно, но вот с программной есть небольшая проблема: программа, которую использует Alex (от совершенно другого проекта) написана под Arduino и не подходит для Raspberry Pi. Самое сложное в этой программе — расчёты положения ног. Мне не хотелось разрабатывать программу с нуля. Во-первых, расчёты положения ног — кропотливая работа, а во-вторых, Alex реализовал ряд классных функций, которые я не хотел терять. программа использует проекта Я не стал переписывать программу с нуля, а вместо этого перевёл код из C в Python3. Во время перевода я не использовал автоматические утилиты-переводчики и ограничился поиском и заменой по тексту. Так я смог привести C-синтаксис в состояние, понятное Python-интерпретатору. Затем я удалил всё, что связано с аппаратной частью: управления серво, связь с джойстиком — а оставшийся код трансформировал в родительский класс hexapod, который реализовывал вычисления положения ног и логику управления. родительский класс hexapod Следующим шагом я разработал дочерний класс AcpRobot, в который и включил всё, что связано с аппаратурой. Мне такой подход показался удачным: благодаря разделению на родительский и дочерний классы теперь можно использовать логику управления с разными аппаратными реализациями. дочерний класс AcpRobot В вопросе операционный системы я пошёл по пути наименьшего сопротивления и применил Raspbian.  Raspbian Для Xbox-контроллера я использовал драйвер xpadneo и следующую конфигурацию bluetooth в /etc/bluetooth/main.conf: xpadneo [General] 
ControllerMode = dual 
Privacy = device [General]  ControllerMode = dual  Privacy = device Чтобы программа управления роботом запускалась автоматически, я написал небольшой сервис для systemd, а позже скрипт, который устанавливает весь Python-код и генерирует systemd-сервис по шаблону. Передачу видео на телефон я решил оставить на потом, мне совсем не хотелось разбираться с мобильной разработкой. Получилось так: скрипт шаблону  Как я связал робота и Steam Deck Согласно Википедии, Steam Deck — это портативный игровой компьютер, разработанный Valve Corporation. Мне кажется, что ключевое слово здесь «компьютер», так как эта консоль действительно полноценный, настоящий x86-64 комп с Linux (SteamOS) на борту. На нём даже по умолчанию Python предустановлен! С учётом того, что я так и не решил проблему передачи видео, Steam Deck — идеальный кандидат в качестве нового джойстика управления. Так как мой робот — полноценный компьютер, и Steam Deck — тоже полноценный компьютер, я решил использовать Wi-fi для дистанционного управления.  Сетевой обмен данными Для получения сетевого стека я использовал Apache Thrift. Это фреймворк для разработки межъязыковых сервисов, он позволяет генерировать сетевой RPC-код по заданной схеме для десятка разных языков. Моя схема содержала пару структур данных и пять запросов:  Apache Thrift Моя схема Ping — просто пинг, чтобы проверить, работает ли связь.
Axis — информация о стиках.
Button — информация о нажатых кнопка.
Get_status — статус робота, включает: текущий режим, под режим, статус огней и батареи
Get_logs — передача логов из робота. Ping — просто пинг, чтобы проверить, работает ли связь. Ping — просто пинг, чтобы проверить, работает ли связь. Axis — информация о стиках. Axis — информация о стиках. Button — информация о нажатых кнопка. Button — информация о нажатых кнопка. Get_status — статус робота, включает: текущий режим, под режим, статус огней и батареи Get_status — статус робота, включает: текущий режим, под режим, статус огней и батареи Get_logs — передача логов из робота. Get_logs — передача логов из робота. Используя схему, я сгенерировал RCP код для сервера — робота и клиента — Steam Deck. Далее использовал его для обмена данными. Пользовательский интерфейс Для меня пользовательский интерфейс — случай, когда задача казалась очень сложной, а вышла очень простой. Я использовал PySimpleGUI, с помощью которого элементарно строить пользовательский интерфейс. Немного магии, 200 строк кода, и UI модуль готов! PySimpleGUI UI модуль RC — адрес сервера удалённого управления (RC — remote control).
VD — адрес видео стрима (VD — video).
M: CALI — означает текущий режим (mode) — калибровка (calibration).
SM: NA — текущий под-режим (sub-mode) отсутствует (NA означает Not Available).
Speed: FAST — текущий скоростной режим переключён в положение «быстро».
L1 и L2 — свет (Light) 1 и 2 активированы.
View: LOGS — переключение между режимом отображения журнала (Log) или видео. RC — адрес сервера удалённого управления (RC — remote control). RC — адрес сервера удалённого управления (RC — remote control). VD — адрес видео стрима (VD — video). VD — адрес видео стрима (VD — video). M: CALI — означает текущий режим (mode) — калибровка (calibration). M: CALI — означает текущий режим (mode) — калибровка (calibration). SM: NA — текущий под-режим (sub-mode) отсутствует (NA означает Not Available). SM: NA — текущий под-режим (sub-mode) отсутствует (NA означает Not Available). Speed: FAST — текущий скоростной режим переключён в положение «быстро». Speed: FAST — текущий скоростной режим переключён в положение «быстро». L1 и L2 — свет (Light) 1 и 2 активированы. L1 и L2 — свет (Light) 1 и 2 активированы. View: LOGS — переключение между режимом отображения журнала (Log) или видео. View: LOGS — переключение между режимом отображения журнала (Log) или видео. Видеострим Со стороны робота я использовал камеру raspberry pi camera v2. Для захвата изображения я использовал ustreamer — лёгкий и быстрый сервер для потоковой передачи видео MJPEG с устройств V4L2 в сеть. К сожалению, в репозиториях rasbian нет пакета с ustreamer, однако сборка из исходных кодов оказалось элементарной: raspberry pi camera v2 ustreamer export WITH_SYSTEMD=1

sudo apt install libevent-dev libjpeg9-dev libbsd-dev libsystemd-dev

git clone https://github.com/pikvm/ustreamer.git

cd ustreamer

make export WITH_SYSTEMD=1

sudo apt install libevent-dev libjpeg9-dev libbsd-dev libsystemd-dev

git clone https://github.com/pikvm/ustreamer.git

cd ustreamer

make Для запуска сервера я использую следующие флаги: --host $(hostname) \

--port  9999 \

--format=uyvy \

--encoder=m2m-image \

--workers=3 \

--persistent \

--dv-timings \

--drop-same-frames 30 \

--desired-fps 24 --host $(hostname) \

--port  9999 \

--format=uyvy \

--encoder=m2m-image \

--workers=3 \

--persistent \

--dv-timings \

--drop-same-frames 30 \

--desired-fps 24 Со стороны Steam Deck я использовал urllib для чтения потока данных и opencv-python для конвертации изображения в подходящий формат. использовал Что есть сейчас и что ещё нужно сделать Проект ещё не доведён до конца: надо избавиться от багов, завернуть Python-код в пакеты, оптимизировать видеострим. Но ключевые функции уже работают и радуют.   Если вы решите повторить мой путь, эти ссылки вам помогут: Моя инструкция по сборке робота.
Проект на github.
Дополнительные STL — файлы для установки raspberry pi и pwm модулей.
Видео по сборке похожего робота от AlexKorvin — изначального автора проекта. Моя инструкция по сборке робота. Моя инструкция по сборке робота. Моя инструкция по сборке робота Проект на github. Проект на github. Проект на github Дополнительные STL — файлы для установки raspberry pi и pwm модулей. Дополнительные STL — файлы для установки raspberry pi и pwm модулей. Дополнительные STL Видео по сборке похожего робота от AlexKorvin — изначального автора проекта. Видео по сборке похожего робота от AlexKorvin — изначального автора проекта. Видео по сборке похожего робота от AlexKorvin]]></text>
</doc>
