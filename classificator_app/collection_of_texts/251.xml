<?xml version="1.0" ?>
<doc>
	<label auto="true" type="str" verify="true"><![CDATA[Develop]]></label>
	<author auto="true" type="list" verify="true">
		<item type="str"><![CDATA[MaFrance351]]></item>
	</author>
	<date auto="true" type="str" verify="true"><![CDATA[2022-12-10, 11:01]]></date>
	<link auto="true" type="str" verify="true"><![CDATA[https://habr.com/ru/company/timeweb/blog/703328/]]></link>
	<title auto="true" type="str" verify="true"><![CDATA[Как устроен и как работает пин-пад]]></title>
	<categories auto="true" type="list" verify="true">
		<item type="str"><![CDATA[Блог компании Timeweb Cloud]]></item>
		<item type="str"><![CDATA[Платежные системы]]></item>
		<item type="str"><![CDATA[Старое железо]]></item>
	</categories>
	<key_words auto="true" type="list" verify="true">
		<item type="str"><![CDATA[timeweb_статьи_выходного_дня]]></item>
		<item type="str"><![CDATA[пин-пад]]></item>
		<item type="str"><![CDATA[pos-терминал]]></item>
		<item type="str"><![CDATA[verifone]]></item>
		<item type="str"><![CDATA[des]]></item>
		<item type="str"><![CDATA[PIN]]></item>
		<item type="str"><![CDATA[PCI]]></item>
		<item type="str"><![CDATA[PED]]></item>
		<item type="str"><![CDATA[4P4C]]></item>
		<item type="str"><![CDATA[Cypress]]></item>
		<item type="str"><![CDATA[SRAM]]></item>
		<item type="str"><![CDATA[ЖКИ]]></item>
		<item type="str"><![CDATA[банкоматы]]></item>
		<item type="str"><![CDATA[чипы]]></item>
		<item type="str"><![CDATA[контроллеры]]></item>
		<item type="str"><![CDATA[платы]]></item>
		<item type="str"><![CDATA[ПО]]></item>
	</key_words>
	<text auto="true" type="str" verify="true"><![CDATA[Приветствую всех!

Многие из нас хоть раз читали, как происходит обработка банковских операций. И все мы знаем, что незашифрованный PIN не уходит никуда дальше пин-пада. А вот о том, как именно это реализовано, информации традиционно маловато.



Итак, в ходе данной статьи поговорим о пин-падах. Узнаем, как они устроены, какой защитой обладают. На примере реального девайса рассмотрим управление им. Как обычно, будет много интересного.

❯ Суть такова

В комментариях к моему посту про магнитные карты многие заинтересовались именно процессом обработки транзакций. Так что решил написать и про это, тем более, что тема работы подобных устройств меня интересовала давно.
POS-terminal'ы наподобие VeriFone Tranz или VeriFone OMNI давным-давно ушли в историю. Абсолютное большинство платёжных терминалов ныне оснащается устройством для ввода и шифрования ПИН (в большинстве случаев он вообще встроенный).



Итак, пин-пад (PIN Entry Device) представляет собой устройство, имеющее защищённое хранилище ключей (как это реализовано, поговорим чуть позже), позволяющее пользователю ввести ПИН и вернуть его зашифрованное значение. Для использования в банковской сфере они проходят сертификацию PCI PED (Payment Card Industry PIN Entry Device). Пин-пад может быть как внешним, выполненным в виде отдельного устройства, так и встроенным, реализованным схемотехникой терминала.
Отдельно идут так называемые интеллектуальные пин-пады, представляющие собой практически полноценные POS-terminal'ы, адаптированные для управления с кассового компьютера.

❯ Обзор оборудования

В качестве основной железки, что будет фигурировать в этой статье, был взят VeriFone PINpad 1000SE (он же просто PP1000SE). Модель достаточно старая, после вывода из эксплуатации терминалов без поддержки бесконтактной оплаты (CTLS) встречается чуть реже, чем нигде, хотя в лучшие времена стояли практически повсеместно. Почему именно он? Всё дело в том, что платёжные терминалы и банковская сфера в принципе — весьма закрытая область. И найти какой-либо софт, документацию, а уж тем более средства разработки крайне проблематично. Чего не скажешь о нашем девайсе, нужная информация для которого отыскалась без каких-либо проблем.



Собственно, вот так он выглядит. Думаю, многие из вас его даже вспомнят. На передней панели у него дисплей (графический, но используется только в текстовом режиме, причём вмещается на дисплей всего восемь символов), кнопки для ввода ПИН, отмены, корректировки и подтверждения, а также ненужные кнопки программируемые функциональные клавиши (о которых, к слову, в единственном общественно доступном мануале сказано нечто вроде «This feature is not implemented in this version of firmware).



С обратной стороны наклейка с названием модели, резиновые ножки, отверстие пищалки, а также закладная для крепления на стойку. Ну и разъём типа 4P4C для подключения кабеля.



Распиновка этого разъёма приведена в документации. Она здесь вот такая.



Разбираем. Электроника закрыта защитной пластиной. Также видна давно сдохшая батарейка типа CR2450. Её надо заменить на новую, иначе при подаче питания пин-пад не будет подавать никаких признаков жизни.



Снимем защитную пластину. Отчётливо видны некий проприетарный чип, парочка микросхем от ST и Cypress, немножко дискретной логики. Этим самым проприетарным чипом выступает либо что-то заказное, либо микросхемы общего назначения, на которые вместо обычной ещё на заводе нанесена маркировка компании. В старых экземплярах таких компонентов не было, чаще всего использовались Z80/MC68000 с соответствующей обвязкой.

Сами ключи обычно хранятся в SRAM, так что при разряде батарейки они тоже исчезнут вместе со всеми параметрами.



Открутим плату. Дисплей графический, без маркировки. Отодрать его от пластмассового крепления у меня не вышло, побоялся его сломать.

❯ Методы защиты

Итак, как мы помним, пин-пад должен обладать защищённым хранилищем ключей. В частности, это значит, что при попытке получения доступа ключи будут необратимо стёрты. Для этого используются специальные механизмы защиты от вскрытия (anti-tampering systems). Помимо систем контроля используются и различные конструктивные решения, усложняющие неразрушающую разборку устройства или вообще делающие её невозможной. Продемонстрируем, как они выглядят.



Рассмотрим ту самую пластину, закрывающую электронику. Это не просто кусок текстолита. Внутри него по всей его площади проходит тоненькая дорожка-змейка. При попытке просверлить или проковырять в ней отверстие цепь разомкнётся, и контур безопасности окажется разорван. Пластина соединена с платой при помощи кусочков анизотропной резины, аналогичной той, что используется для подключения к контактам на плате сегментных ЖКИ.



Помимо пластин существуют и рамки. обеспечивающие контроль связанности между собой двух плат. Вот для примера такая рамка в пин-паде VeriFone SC5000. По её периметру наклеен шлейфик, подключённый к плате при помощи всё той же резинки. Также контролируется и плотность прижатия плат — для этого стоит ещё один кусочек контактной резины, соединяющий непосредственно платы.



А вот ещё один пин-пад, Ingenico 3050. Отчётливо виден приклеенный на обратной стороне крышки шлейф с той самой дорожкой-змейкой.



Ну и не стоит забывать про банальные концевики. Здесь они представлены в виде резиновых кнопок, прижимаемых частями корпуса. Одна из них находится прямо среди защитной пластины, ещё четыре — со стороны клавиатуры. Тут тоже всё не так просто: вокруг каждой площадки есть ещё и кольцевой контакт, соединённый с землёй (обратите внимание, что обычные кнопки таким не оснащены). Если злоумышленник попытается подсунуть фольгу или впрыснуть токопроводящую жидкость, контур безопасности окажется закорочен на землю, что, разумеется, будет немедленно воспринято как взлом.

В старых пин-падах для этих целей использовались тактовые кнопки и микропереключатели.





К методам защиты также относится и заливка смолой. Ныне в POS-terminal'ах такое встречается редко, а вот клавиатуры банкоматов всё также частенько заливают. Иногда вместо полной упаковки устройства в единый монолит из эпоксидки её просто наливают сверху на плату (по форме или просто каплей), защищая отдельные её участки.



Вернёмся к нашему Ingenico 3050. Поверх материнской платы припаяна ещё одна вверх ногами, на которой и находятся управляющие чипы. Из-за такой конструкции демонтировать этот узел без отрыва дорожек или перегрева микросхем не так-то просто, особенно с учётом того, что помимо пайки он ещё и приклеен.



А вот POS-terminal Ingenico 5100. У него процессор и его обвязка находятся внутри единого монолита из смолы. Наружу торчат только контакты для подключения.


Пин-пад от банкомата. Тут используется комбинированная защита — плата, помещённая в контур безопасности, залитая поверх смолой.





Более новый пин-пад, EPPV6. Отчётливо видны отсеки в корпусе, залитые смолой, а заодно и отверстие, куда она заливалась. Заклеенное наклейкой „Kill EPP“ отверстие — кнопка самоуничтожения (при нажатии ключи стираются, а устройство блокируется), нажимаемая при выводе экземпляра из эксплуатации.

Помимо аппаратных существуют и программные методы защиты: защищённые загрузчики, шифрованные прошивки, подписывание ПО.

❯ Первое включение



Итак, батарейку припаяли, можно пробовать подключать. Для удобства я спаял переходник, к которому пин-пад подключается при помощи обычного витого кабеля с разъёмами 4P4C на концах от трубки стационарного телефона.

Подаём питание. Пин-пад должен будет пискнуть и написать нечто вроде „Tampered device“ (ну, или не написать, если батарейка дожила до наших дней и вам не пришлось её менять). Жмём несколько раз „Cancel“ и попадаем в рабочий режим. Если туда загружена какая-нибудь строка, он выведет её, если же нет, то на экране появится бегущая стрелка.

Нажмём комбинацию клавиш „Cancel“+»2", наберём пароль 844747746 и попадём в сервисное меню. Список пунктов там такой:

P.C MEM TST — тест NVRAM (с её полным стиранием)
INIT MKEY RAM — удаление ключей
LANGUAGES — ну, это ясно, что такое
DSP ALL MSG — режим отображения сообщений
SET BAUD RATE — скорость порта
SET KEY MGT — режим организации ключей
SET PP MODE — режим работы пин-пада (Nurit/VeriFone)
OS ACCESS — выход в Nurit OS (NOS)

Выбирать нужно нажатием цифровой клавиши с соответствующим номером.

Также есть комбинация «Cancel»+«3» с паролем 83746, но ничего интересного для нас там нет.

❯ Что с экраном?

Вы спросите: а почему же графический экран используется столь нерационально? Не лучше ли было разработчикам поставить сегментный дисплей?



Всё очень просто. Существовала ещё и «узкая» версия PP1000SE, более старая. Там стоит сегментный экран, а также отсутствуют два последних пунктам меню. В лучшие времена VeriFone приобрела израильскую компанию Lipman Electronics Engineering, выпускавшую терминалы Nurit. Соответственно, часть её наработок и была использована в PP1000SE второй версии. А ради совместимости с первой и были введены подобные меры.

«Широкий» PP1000SE можно переключить в режим Nurit (если что, для выхода оттуда надо нажать сначала на среднюю фиолетовую кнопку, а затем на «2», пароль тот же самый), на нём же можно выйти в Nurit OS, выбрав последний пункт меню, после чего зажав клавиши «3»+«5»+«7».







А вот антикварный пин-пад PP1000+. По системе команд он аналогичен PP1000SE. Внутри, кстати, как раз видна смола.

❯ Управляющие пакеты

PP1000SE управляется пакетами данных. Началом служит символ «SI» или «STX», концом — «SO» или «ETX». Какой из двух выбрать, указано в таблице формата каждого пакета в мануале.
После пакета данных идёт контрольное значение — последовательный XOR всех байт пакета, за исключением начального.

Функция для расчёта этого значения


Если контрольная сумма соответствует, пин-пад присылает в ответ байт «ACK», если нет — «NAK». После трёх несоответствий подряд отправляется «EOT».

Также стоит отметить параметры порта — 7 data bits, even parity. Скорость задаётся в том самом меню.

❯ Выводим текст на экран

На примере вывода текста рассмотрим отправку пакета.

void showString(string s) {
   uint8_t data = 0;
   string input = "";
   input += STX;
   input += "Z2";
   input += 0x1A;
   input += s;
   input += ETX;
   input += BCC(input);
   WriteStringCOM(input);
   while(!ReadCOM(data));;
   if(data != 0x06) cout << "error" << endl;
   else cout << "success";
}

Итак, для вывода текста служит пакет типа Z2. Вначале к строке добавляется символ «STX» (для удобства коды всех этих символов я указал в начале программы через define), потом, код пакета «Z2», далее символ «SUB», служащий для очистки экрана, сама строка для вывода, символ «ETX». Рассчитывается и также добавляется контрольное число.
Итак, пробуем:

Программа для вывода строки


Запускаем, и, если всё было подключено правильно, на дисплее должно будет появиться примерно следующее:



Разумеется, на «узком» пин-паде это тоже работает:



❯ Ключи



Ну что же, время перейти к самому главному — к тому, как именно производится шифрование. В большинстве пин-падов используется алгоритм 3DES. Ранее использовался простой DES, но ныне его почти нигде не встретишь.

Итак, в терминальном ПО можно встретить в основном три вида ключей: PIN, MAC и KLK. Первый из этого списка — ключ непосредственно для шифрования PIN. Второй — ключ Message Authentication Code, позволяющий отслеживать подлинность отправляемых пакетов данных. Третий — Key Loading Key, ключ для загрузки ключей, позволяющий для большей безопасности загружать уже зашифрованные ключи. Из всех трёх нам больше всего интересен ключ PIN.

❯ Организация ключей

Существует два метода работы с ключами — Master/Session и DUKPT. В настоящее время используется преимущественно второй вариант.

Master/Session — уже достаточно старый метод. Принцип его работы такой: внутри пин-пада в защищённом хранилище находится мастер-ключ. Терминал содержит в своей памяти рабочий (сессионный) ключ, зашифрованный мастер-ключом. При необходимости что-либо зашифровать, терминал отправляет пин-паду этот рабочий ключ, где он расшифровывается мастер-ключом. Назад возвращается зашифрованный блок данных. При этом ни мастер-ключ, ни расшифрованный рабочий не покидают пределов пин-пада.

DUKPT — более совершенный вариант. Суть его в том, что, при помощи BDK (Base Derivation Key) генерируются IPEK (Initial PIN Encryption Key) и KSN (Key Serial Number), которые и загружаются в пин-пад. На базе IPEK выпускаются ключи, уже используемые в процессе шифрования.

При каждой операции шифрования KSN увеличивается на единицу, а пин-пад возвращает зашифрованный блок данных и новое значение KSN.

В данном примере рассмотрим метод Master/Session как наиболее простой в реализации.

❯ Загружаем ключ

Итак, для загрузки ключей в пин-пад существует пакет «02». Далее требуется указать номер ячейки, куда будет загружен ключ, и, собственно, сам ключ.

Вот как-то так


Для примера я загружу туда ключ 0123456789ABCDEF. Этот пакет несколько отличается по формату: после ответа пин-пада надо отправить «ACK», иначе ключ забит не будет.
После загрузки ключа также пропадёт сообщение «Tampered device».

❯ PIN-block



Разумеется, пин-пад шифрует не просто PIN, а PIN-block — специальный пакет данных. Чаще всего используют ISO 9564 Format 0, являющийся результатом операции XOR данных PAN и PIN.

❯ Запрашиваем PIN

Ну что, время попробовать прочитать PIN.

Для начала подготовим входные данные. PAN возьмём всё тот же, что был в посте про магнитные карты — 4034351574462072. Рабочим ключом пусть будет 0123456789012345. Зашифруем его с помощью ранее заданного мастер-ключа, получив при этом значение 59216EC9E36F8EF8.

ПИНом будет банальный 1234. На основе PAN и PIN рассчитаем PIN-block: 041277AEA8BB9DF8.

Пишем очередную прогу. Вначале необходимо выбрать мастер-ключ, для чего отправляем пакет с кодом 08. После отправки запроса на ввод пин-пад запрашивает PIN, после чего отправляет зашифрованный PIN-block. В это время на дисплее крутятся надписи «PROCESSING» и «PIN PAD», которые будут оставаться там до нажатия кнопки «Cancel» или прихода нового пакета. После получения PIN-block отправим пакет «Indicate host done» (с кодом Q2), который выведет на экран пин-пада сообщение «Thank you».

Функции в итоге получились вот такие:

void selectMKEY() {
   string input = "";
   input += SI;
   input += "08";
   input += "0"; //номер ячейки ключа
   input += SO;
   input += BCC(input);
   WriteStringCOM(input);
}

void requestPINEntry() {
   uint8_t data = 0;
   string input = "";
   input += STX;
   input += "70";
   input += 0x2E;
   input += "4034351574462072"; //PAN
   input += 0x1C;
   input += "59216EC9E36F8EF8"; //рабочий ключ
   input += "9.99"; //сумма к оплате для отображения на дисплее
   input += ETX;
   input += BCC(input);
   WriteStringCOM(input);
   for(int i = 0; i < 11; i++) {
     while(!ReadCOM(data));;
     printf("%02X ",data);
    }
   for(int i = 0; i < 16; i++) {
     while(!ReadCOM(data));;
     cout << data; //вывод самого PIN-block
    }
    cout << ' ';
   for(int i = 0; i < 2; i++) {
     while(!ReadCOM(data));;
     printf("%02X ",data);
  }
  WriteCOM(0x06);
  Sleep(1000);
  indicateHostDone();
}

void indicateHostDone() {
  string input = "";
  input += STX;
  input += "Q2";
  input += ETX;
  input += BCC(input);
  WriteStringCOM(input);
}

Запускаем. Вводим наш ПИН — 1234. Пин-пад в ответ присылает нам PIN-block 5DCB16E4555C6B1A. Расшифровываем его с помощью нашего незашифрованного рабочего ключа и получаем наше расчётное значение 041277AEA8BB9DF8.
Оно живое, оно работает!

❯ Немного о Contactless

Также мне довелось раздобыть PP1000SE CTLS. От обычного он отличается слотом для SAM-модуля и наличием бесконтактного считывателя. Увы, никаких команд касательно считывания карты найти мне так и не удалось…











А вот и такой экземпляр в работе, фото сделано в Греции летом две тысячи двадцать первого года:



❯ Так что в итоге?

Вот мы и рассмотрели ещё одну составляющую обработки пластиковых карт. Попутно продемонстрировали, как запустить такие устройства в «лабораторных» условиях.

Определённо уверен, что все эти материалы кому-нибудь понравятся, тем более, что такого описания подобного оборудования почти никто не делал.

Ссылки

Payment Card Tools
PP1000SE Reference and Programmers Guide
Как расшифровать данные магнитной дорожки с использованием DUKPT           ❯ Суть такова ❯ Суть такова  посту  VeriFone Tranz VeriFone OMNI         ❯ Обзор оборудования ❯ Обзор оборудования       ненужные кнопки                              ❯ Методы защиты ❯ Методы защиты                                                           ❯ Первое включение ❯ Первое включение           P.C MEM TST — тест NVRAM (с её полным стиранием)
INIT MKEY RAM — удаление ключей
LANGUAGES — ну, это ясно, что такое
DSP ALL MSG — режим отображения сообщений
SET BAUD RATE — скорость порта
SET KEY MGT — режим организации ключей
SET PP MODE — режим работы пин-пада (Nurit/VeriFone)
OS ACCESS — выход в Nurit OS (NOS) P.C MEM TST — тест NVRAM (с её полным стиранием) P.C MEM TST INIT MKEY RAM — удаление ключей INIT MKEY RAM LANGUAGES — ну, это ясно, что такое LANGUAGES DSP ALL MSG — режим отображения сообщений DSP ALL MSG SET BAUD RATE — скорость порта SET BAUD RATE SET KEY MGT — режим организации ключей SET KEY MGT SET PP MODE — режим работы пин-пада (Nurit/VeriFone) SET PP MODE OS ACCESS — выход в Nurit OS (NOS) OS ACCESS      ❯ Что с экраном? ❯ Что с экраном?                      ❯ Управляющие пакеты ❯ Управляющие пакеты     Функция для расчёта этого значения Функция для расчёта этого значения          ❯ Выводим текст на экран ❯ Выводим текст на экран    void showString(string s) {
   uint8_t data = 0;
   string input = "";
   input += STX;
   input += "Z2";
   input += 0x1A;
   input += s;
   input += ETX;
   input += BCC(input);
   WriteStringCOM(input);
   while(!ReadCOM(data));;
   if(data != 0x06) cout << "error" << endl;
   else cout << "success";
} void showString(string s) {
   uint8_t data = 0;
   string input = "";
   input += STX;
   input += "Z2";
   input += 0x1A;
   input += s;
   input += ETX;
   input += BCC(input);
   WriteStringCOM(input);
   while(!ReadCOM(data));;
   if(data != 0x06) cout << "error" << endl;
   else cout << "success";
}  define    Программа для вывода строки Программа для вывода строки                ❯ Ключи ❯ Ключи         ❯ Организация ключей ❯ Организация ключей            ❯ Загружаем ключ ❯ Загружаем ключ    Вот как-то так Вот как-то так      0123456789ABCDEF    ❯ PIN-block ❯ PIN-block       ❯ Запрашиваем PIN ❯ Запрашиваем PIN    4034351574462072 0123456789012345 59216EC9E36F8EF8   1234 041277AEA8BB9DF8       void selectMKEY() {
   string input = "";
   input += SI;
   input += "08";
   input += "0"; //номер ячейки ключа
   input += SO;
   input += BCC(input);
   WriteStringCOM(input);
}

void requestPINEntry() {
   uint8_t data = 0;
   string input = "";
   input += STX;
   input += "70";
   input += 0x2E;
   input += "4034351574462072"; //PAN
   input += 0x1C;
   input += "59216EC9E36F8EF8"; //рабочий ключ
   input += "9.99"; //сумма к оплате для отображения на дисплее
   input += ETX;
   input += BCC(input);
   WriteStringCOM(input);
   for(int i = 0; i < 11; i++) {
     while(!ReadCOM(data));;
     printf("%02X ",data);
    }
   for(int i = 0; i < 16; i++) {
     while(!ReadCOM(data));;
     cout << data; //вывод самого PIN-block
    }
    cout << ' ';
   for(int i = 0; i < 2; i++) {
     while(!ReadCOM(data));;
     printf("%02X ",data);
  }
  WriteCOM(0x06);
  Sleep(1000);
  indicateHostDone();
}

void indicateHostDone() {
  string input = "";
  input += STX;
  input += "Q2";
  input += ETX;
  input += BCC(input);
  WriteStringCOM(input);
} void selectMKEY() {
   string input = "";
   input += SI;
   input += "08";
   input += "0"; //номер ячейки ключа
   input += SO;
   input += BCC(input);
   WriteStringCOM(input);
}

void requestPINEntry() {
   uint8_t data = 0;
   string input = "";
   input += STX;
   input += "70";
   input += 0x2E;
   input += "4034351574462072"; //PAN
   input += 0x1C;
   input += "59216EC9E36F8EF8"; //рабочий ключ
   input += "9.99"; //сумма к оплате для отображения на дисплее
   input += ETX;
   input += BCC(input);
   WriteStringCOM(input);
   for(int i = 0; i < 11; i++) {
     while(!ReadCOM(data));;
     printf("%02X ",data);
    }
   for(int i = 0; i < 16; i++) {
     while(!ReadCOM(data));;
     cout << data; //вывод самого PIN-block
    }
    cout << ' ';
   for(int i = 0; i < 2; i++) {
     while(!ReadCOM(data));;
     printf("%02X ",data);
  }
  WriteCOM(0x06);
  Sleep(1000);
  indicateHostDone();
}

void indicateHostDone() {
  string input = "";
  input += STX;
  input += "Q2";
  input += ETX;
  input += BCC(input);
  WriteStringCOM(input);
}  5DCB16E4555C6B1A 041277AEA8BB9DF8    ❯ Немного о Contactless ❯ Немного о Contactless                        ❯ Так что в итоге? ❯ Так что в итоге?      Ссылки Ссылки  Payment Card Tools
PP1000SE Reference and Programmers Guide
Как расшифровать данные магнитной дорожки с использованием DUKPT Payment Card Tools Payment Card Tools PP1000SE Reference and Programmers Guide PP1000SE Reference and Programmers Guide Как расшифровать данные магнитной дорожки с использованием DUKPT Как расшифровать данные магнитной дорожки с использованием DUKPT   ]]></text>
</doc>
