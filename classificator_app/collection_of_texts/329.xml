<?xml version="1.0" ?>
<doc>
	<label auto="true" type="str" verify="true"><![CDATA[Develop]]></label>
	<author auto="true" type="list" verify="true">
		<item type="str"><![CDATA[root85]]></item>
	</author>
	<date auto="true" type="str" verify="true"><![CDATA[2022-12-07, 21:14]]></date>
	<link auto="true" type="str" verify="true"><![CDATA[https://habr.com/ru/post/704158/]]></link>
	<title auto="true" type="str" verify="true"><![CDATA[ChatGPT – хайп или реальная помощь разработчику?]]></title>
	<categories auto="true" type="list" verify="true">
		<item type="str"><![CDATA[Машинное обучение]]></item>
		<item type="str"><![CDATA[Облачные сервисы]]></item>
		<item type="str"><![CDATA[Искусственный интеллект]]></item>
	</categories>
	<key_words auto="true" type="list" verify="true">
		<item type="str"><![CDATA[ChatGPT]]></item>
		<item type="str"><![CDATA[Go]]></item>
		<item type="str"><![CDATA[ai]]></item>
		<item type="str"><![CDATA[кодогенерация]]></item>
	</key_words>
	<text auto="true" type="str" verify="true"><![CDATA[Одна из хайповых тем последней недели в англоязычном Твиттере – релиз ChatGPT от OpenAI. Чат-бот который, по задумке авторов, может писать код, фиксить баги, и отвечать на сложные вопросы.
Я решил проверить, действительно ли ChatGPT может помочь разработчику. Имею опыт программирования на разных языках, совсем недавно перешел на Go (пишу блокчейн-проект). Решил сузить задачу до такой: мог бы мне, разработчику с опытом, новичку в Go, хоть немного помочь ChatGPT.
Пример 1
Давайте начнем с простого. Хочу найти элемент в срезе (slice) – расширенном аналоге массива. Давайте зададим вопрос боту. MA в этом чате и далее – это я.
Что хорошо:
Код компилируется, есть пример применения бинарного поиска;
Есть выводы сообщений "найден/не найден";
Есть базовые объяснения алгоритма, хотя упоминается функция Index, подразумевается Search.
Что плохо:
Код, конечно, не работает как надо, т.е. срез не отсортирован, а это основное требование к бинарному поиску. Но говорится, что массив д.б. отсортирован.
Выглядит сложно для новичка. Я бы предпочел цикл или пакет slices и IndexFunc, если не было явного требования о "быстром" поиске.
Пример 2
Но давайте явно укажем, что массив не сортированный.
Что хорошо:
В принципе, хорошо почти все :) и код рабочий, и совет дан хороший.
Что плохо:
Название функции перепутано, нужно Search, а не Index.
Пример 3
Давайте перейдем к более специфичному примеру. Попробуем напечатать значение, заданное в Wei, в ETH (1 ETH = 10^18 Wei):
Что круто:
Почти все! Ну действительно, приятно удивил результат. Он действительно переведет в ETH значение wei (да, конечно, Int может не хватить, но можно инициализировать wei через wei.SetString).
Правильная единица конверсии (10^18).
Откомментированный код.
Бот, похоже, обучается на основе фидбэка от пользователей. Предыдущий результат, который я получил несколько часов назад, включал очевидно неверный код с делением big.Int на big.Int.
Пример 4
Давайте попробуем получить баланс в USDT заданного кошелька в сети Ethereum:
Что хорошо:
Шаблон программы действительно сгенерирован и в целом имеет правильную структуру (подключение к API, получение баланса, печать).
Подключены правильные библиотеки (go-ethereum).
Подставлены осмысленные имена переменных.
В одном из запросов (не в этом) был правильно определен адрес USDT в нужной сети (Ethereum Mainnet).
Бот правильно понял, что число символов после запятой равно шести и правильно написал код печати.
Что плохо:
Правильный баланс этот код не напечатает. Не вдаваясь в подробности, но он напечатает (после правок) баланс в ETH (не в USDT).
Чтобы сделать пример рабочим, нужно добавить довольно много инфраструктурного кода, который я не буду здесь приводить для экономии места.
(Добавлено) Пример 5
Проверим, как бот справится с задачей чтения из таблицы Postgres, содержащей данные о людях.
Как будто, все правильно (комментарии бота опустил). Но давайте теперь создадим саму таблицу с тестовыми данными:
Я попробовал это запустить и... все заработало, таблица с данными создалась, код выполняется и выводит данные в консоль!
(!) Единственное изменение, которое пришлось сделать – это установить правильную строку подключения к БД.
Что хорошо:
В этом примере все получилось как нужно. Однозначно буду использовать ChatGPT для простого прототипирования. Сильно быстрее было сделать два запроса к боту, чем набирать код вручную.
Итак, субъективные выводы:
ChatGPT – впечатляющая разработка. Код из всех примеров может работать с изменениями различной степени, либо вообще без изменений.
ChatGPT уже можно использовать для вдохновения (например, понять, какие библиотеки можно взять для решения задачи, пример 4), для быстрого прототипирования (пример 5), или чтобы не тратить время на реализацию тривиальных операций (результат примера 3 я бы взял в продакшен).
Возможно, не совсем для пользования новичками в программировании, которые сходу не смогут понять, в чем в коде проблема.
Вижу классное нишевое использование подобных ботов, например, в плане поиска нужных библиотек и примеров из них, что потенциально может быть встроено сразу в IDE (вот тут кто-то уже запилил плагин для VSCode), или для сдачи лабораторных преподавателю, не особо разбирающемуся в теме :) (надеюсь, такие уже не встречаются). Одна из хайповых тем последней недели в англоязычном Твиттере – релиз ChatGPT от OpenAI. Чат-бот который, по задумке авторов, может писать код, фиксить баги, и отвечать на сложные вопросы. ChatGPT Я решил проверить, действительно ли ChatGPT может помочь разработчику. Имею опыт программирования на разных языках, совсем недавно перешел на Go (пишу блокчейн-проект). Решил сузить задачу до такой: мог бы мне, разработчику с опытом, новичку в Go, хоть немного помочь ChatGPT. Пример 1 Давайте начнем с простого. Хочу найти элемент в срезе (slice) – расширенном аналоге массива. Давайте зададим вопрос боту. MA в этом чате и далее – это я.   Что хорошо: Код компилируется, есть пример применения бинарного поиска;
Есть выводы сообщений "найден/не найден";
Есть базовые объяснения алгоритма, хотя упоминается функция Index, подразумевается Search. Код компилируется, есть пример применения бинарного поиска; Код компилируется, есть пример применения бинарного поиска; Есть выводы сообщений "найден/не найден"; Есть выводы сообщений "найден/не найден"; Есть базовые объяснения алгоритма, хотя упоминается функция Index, подразумевается Search. Есть базовые объяснения алгоритма, хотя упоминается функция Index, подразумевается Search. Что плохо: Код, конечно, не работает как надо, т.е. срез не отсортирован, а это основное требование к бинарному поиску. Но говорится, что массив д.б. отсортирован.
Выглядит сложно для новичка. Я бы предпочел цикл или пакет slices и IndexFunc, если не было явного требования о "быстром" поиске. Код, конечно, не работает как надо, т.е. срез не отсортирован, а это основное требование к бинарному поиску. Но говорится, что массив д.б. отсортирован. Код, конечно, не работает как надо, т.е. срез не отсортирован, а это основное требование к бинарному поиску. Но говорится, что массив д.б. отсортирован. Выглядит сложно для новичка. Я бы предпочел цикл или пакет slices и IndexFunc, если не было явного требования о "быстром" поиске. Выглядит сложно для новичка. Я бы предпочел цикл или пакет slices и IndexFunc, если не было явного требования о "быстром" поиске. Пример 2 Но давайте явно укажем, что массив не сортированный.   Что хорошо: В принципе, хорошо почти все :) и код рабочий, и совет дан хороший. В принципе, хорошо почти все :) и код рабочий, и совет дан хороший. В принципе, хорошо почти все :) и код рабочий, и совет дан хороший. Что плохо: Название функции перепутано, нужно Search, а не Index. Название функции перепутано, нужно Search, а не Index. Название функции перепутано, нужно Search, а не Index. Пример 3 Давайте перейдем к более специфичному примеру. Попробуем напечатать значение, заданное в Wei, в ETH (1 ETH = 10^18 Wei):   Что круто: Почти все! Ну действительно, приятно удивил результат. Он действительно переведет в ETH значение wei (да, конечно, Int может не хватить, но можно инициализировать wei через wei.SetString).
Правильная единица конверсии (10^18).
Откомментированный код.
Бот, похоже, обучается на основе фидбэка от пользователей. Предыдущий результат, который я получил несколько часов назад, включал очевидно неверный код с делением big.Int на big.Int. Почти все! Ну действительно, приятно удивил результат. Он действительно переведет в ETH значение wei (да, конечно, Int может не хватить, но можно инициализировать wei через wei.SetString). Почти все! Ну действительно, приятно удивил результат. Он действительно переведет в ETH значение wei (да, конечно, Int может не хватить, но можно инициализировать wei через wei.SetString). Правильная единица конверсии (10^18). Правильная единица конверсии (10^18). Откомментированный код. Откомментированный код. Бот, похоже, обучается на основе фидбэка от пользователей. Предыдущий результат, который я получил несколько часов назад, включал очевидно неверный код с делением big.Int на big.Int. Бот, похоже, обучается на основе фидбэка от пользователей. Предыдущий результат, который я получил несколько часов назад, включал очевидно неверный код с делением big.Int на big.Int. Пример 4 Давайте попробуем получить баланс в USDT заданного кошелька в сети Ethereum:     Что хорошо: Шаблон программы действительно сгенерирован и в целом имеет правильную структуру (подключение к API, получение баланса, печать).
Подключены правильные библиотеки (go-ethereum).
Подставлены осмысленные имена переменных.
В одном из запросов (не в этом) был правильно определен адрес USDT в нужной сети (Ethereum Mainnet).
Бот правильно понял, что число символов после запятой равно шести и правильно написал код печати. Шаблон программы действительно сгенерирован и в целом имеет правильную структуру (подключение к API, получение баланса, печать). Шаблон программы действительно сгенерирован и в целом имеет правильную структуру (подключение к API, получение баланса, печать). Подключены правильные библиотеки (go-ethereum). Подключены правильные библиотеки (go-ethereum). Подставлены осмысленные имена переменных. Подставлены осмысленные имена переменных. В одном из запросов (не в этом) был правильно определен адрес USDT в нужной сети (Ethereum Mainnet). В одном из запросов (не в этом) был правильно определен адрес USDT в нужной сети (Ethereum Mainnet). Бот правильно понял, что число символов после запятой равно шести и правильно написал код печати. Бот правильно понял, что число символов после запятой равно шести и правильно написал код печати. Что плохо: Правильный баланс этот код не напечатает. Не вдаваясь в подробности, но он напечатает (после правок) баланс в ETH (не в USDT).
Чтобы сделать пример рабочим, нужно добавить довольно много инфраструктурного кода, который я не буду здесь приводить для экономии места. Правильный баланс этот код не напечатает. Не вдаваясь в подробности, но он напечатает (после правок) баланс в ETH (не в USDT). Правильный баланс этот код не напечатает. Не вдаваясь в подробности, но он напечатает (после правок) баланс в ETH (не в USDT). Чтобы сделать пример рабочим, нужно добавить довольно много инфраструктурного кода, который я не буду здесь приводить для экономии места. Чтобы сделать пример рабочим, нужно добавить довольно много инфраструктурного кода, который я не буду здесь приводить для экономии места. (Добавлено) Пример 5 Проверим, как бот справится с задачей чтения из таблицы Postgres, содержащей данные о людях.     Как будто, все правильно (комментарии бота опустил). Но давайте теперь создадим саму таблицу с тестовыми данными:   Я попробовал это запустить и... все заработало, таблица с данными создалась, код выполняется и выводит данные в консоль!   (!) Единственное изменение, которое пришлось сделать – это установить правильную строку подключения к БД. Что хорошо: В этом примере все получилось как нужно. Однозначно буду использовать ChatGPT для простого прототипирования. Сильно быстрее было сделать два запроса к боту, чем набирать код вручную. В этом примере все получилось как нужно. Однозначно буду использовать ChatGPT для простого прототипирования. Сильно быстрее было сделать два запроса к боту, чем набирать код вручную. В этом примере все получилось как нужно. Однозначно буду использовать ChatGPT для простого прототипирования. Сильно быстрее было сделать два запроса к боту, чем набирать код вручную. Итак, субъективные выводы: Итак, субъективные выводы ChatGPT – впечатляющая разработка. Код из всех примеров может работать с изменениями различной степени, либо вообще без изменений.
ChatGPT уже можно использовать для вдохновения (например, понять, какие библиотеки можно взять для решения задачи, пример 4), для быстрого прототипирования (пример 5), или чтобы не тратить время на реализацию тривиальных операций (результат примера 3 я бы взял в продакшен).
Возможно, не совсем для пользования новичками в программировании, которые сходу не смогут понять, в чем в коде проблема.
Вижу классное нишевое использование подобных ботов, например, в плане поиска нужных библиотек и примеров из них, что потенциально может быть встроено сразу в IDE (вот тут кто-то уже запилил плагин для VSCode), или для сдачи лабораторных преподавателю, не особо разбирающемуся в теме :) (надеюсь, такие уже не встречаются). ChatGPT – впечатляющая разработка. Код из всех примеров может работать с изменениями различной степени, либо вообще без изменений. ChatGPT – впечатляющая разработка. Код из всех примеров может работать с изменениями различной степени, либо вообще без изменений. ChatGPT уже можно использовать для вдохновения (например, понять, какие библиотеки можно взять для решения задачи, пример 4), для быстрого прототипирования (пример 5), или чтобы не тратить время на реализацию тривиальных операций (результат примера 3 я бы взял в продакшен). ChatGPT уже можно использовать для вдохновения (например, понять, какие библиотеки можно взять для решения задачи, пример 4), для быстрого прототипирования (пример 5), или чтобы не тратить время на реализацию тривиальных операций (результат примера 3 я бы взял в продакшен). Возможно, не совсем для пользования новичками в программировании, которые сходу не смогут понять, в чем в коде проблема. Возможно, не совсем для пользования новичками в программировании, которые сходу не смогут понять, в чем в коде проблема. Вижу классное нишевое использование подобных ботов, например, в плане поиска нужных библиотек и примеров из них, что потенциально может быть встроено сразу в IDE (вот тут кто-то уже запилил плагин для VSCode), или для сдачи лабораторных преподавателю, не особо разбирающемуся в теме :) (надеюсь, такие уже не встречаются). Вижу классное нишевое использование подобных ботов, например, в плане поиска нужных библиотек и примеров из них, что потенциально может быть встроено сразу в IDE (вот тут кто-то уже запилил плагин для VSCode), или для сдачи лабораторных преподавателю, не особо разбирающемуся в теме :) (надеюсь, такие уже не встречаются). запилил плагин ]]></text>
</doc>
