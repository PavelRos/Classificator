<?xml version="1.0" ?>
<doc>
	<label auto="true" type="str" verify="true"><![CDATA[Other]]></label>
	<author auto="true" type="list" verify="true">
		<item type="str"><![CDATA[SkU4]]></item>
	</author>
	<date auto="true" type="str" verify="true"><![CDATA[2022-05-25, 14:23]]></date>
	<link auto="true" type="str" verify="true"><![CDATA[https://habr.com/ru/post/667750/]]></link>
	<title auto="true" type="str" verify="true"><![CDATA[Разработка навыка для «Алисы» на основе Google Keep заметок]]></title>
	<categories auto="true" type="list" verify="true">
		<item type="str"><![CDATA[Open source]]></item>
		<item type="str"><![CDATA[Google API]]></item>
		<item type="str"><![CDATA[Go]]></item>
		<item type="str"><![CDATA[Голосовые интерфейсы]]></item>
	</categories>
	<key_words auto="true" type="list" verify="true">
		<item type="str"><![CDATA[golang]]></item>
		<item type="str"><![CDATA[swagger]]></item>
		<item type="str"><![CDATA[boltdb]]></item>
		<item type="str"><![CDATA[cicd]]></item>
		<item type="str"><![CDATA[go]]></item>
		<item type="str"><![CDATA[keep]]></item>
		<item type="str"><![CDATA[mock]]></item>
		<item type="str"><![CDATA[gin]]></item>
		<item type="str"><![CDATA[localize]]></item>
		<item type="str"><![CDATA[pprof]]></item>
	</key_words>
	<text auto="true" type="str" verify="true"><![CDATA[На данный момент я активно пользуюсь приложением Google Keep для управления заметками на смартфоне. В частности, в дополнение к приложению есть виджет для рабочего стола, который отображает активные заметки. Для покупок в магазине достаточно удобно пользоваться заметками вида "чеклист", о которых и пойдет речь ниже.
Как правило для покупок в магазине используется один и тот же набор наименований. Если заполнить такой список пунктами, которые будут помечаться галочкой (т.е. дропаться вниз), а не удаляться, то в последующем при добавлении новых пунктов будут отображаться подсказки по уже добавленным пунктам, что достаточно удобно.
Подсказки при добавлении в список уже существующих
Казалось бы причем тут Алиса... так вот удобно было бы добавлять такие пункты покупок в список, используя голосовой помощник от Яндекса.
Стоит упомянуть, что продукт Google Keep неплохо синхронизирует данные между устройствами, поэтому при манипуляции с заметками изменения достаточно быстро отображаются в виджете.
Итак, задача:
Добавлять/удалять пункты в чеклист через Алису
Удалять пункты путём пометки их галочкой, а не через удаление
Не дублировать пункты с одинаковым наименованием
На этом вроде бы и всё, поехали…
Используемый стек технологий:
Язык: Go (gin, swagger, mock tests, clean architecture) + Bolt DB
CI/CD: Github + Docker + DigitalOcean
Код приложения доступен на GitHub.
Управление списком Google Keep
В процессе реализации пришлось отказаться от официального api, поскольку оно доступно только для корпоративных аккаунтов:
The Google Keep API is used in an enterprise environment to manage Google Keep content and resolve issues identified by cloud security software.
В качестве альтернативного решения был рассмотрен вариант получения доступа к api через отправку запроса с необходимым набором headers и cookie (своеобразная комбинация параметров отправки jwt токена). Помимо приложения есть web версия сервиса, для редактирования заметок через браузер. Здесь и было подсмотрено итоговое решение для управления персональными заметкам.
Если проанализировать запросы через панель разработчика Chrome, можно заметить, что для получения и обновления заметок используется запрос /notes/v1/changes:
Необходимо только воспроизвести запрос с правильными заголовками и cookies, чтобы пройти корректно авторизацию. Для этого сохраняем har-лог из панели разработчика в файл и импортируем его в Postman. Далее поочередно отключаем заголовки пока запрос не пройдет авторизацию. В результате в качестве обязательных параметров имеем:
Headers: x-origin и authorization
Все cookie с префиксом SID
Отлично, теперь к реализации
В качестве рабочего решения используем har файл с запросами к Google Keep, из которого будем извлекать url, headers и cookie. Вариант продления token ключа в текущей реализации не предусматривается. Подразумевается, когда закончится срок действия ключа, мы откроем браузер, заберем из него свежий har и подменим его в приложении в качестве файла конфигурации.
Реализацию метода отправки запроса можно посмотреть на GitHub. Алгоритм реализуем на любом языке: проходим по всем запросам из har-файла, находим запрос/notes/v1/changes, извлекаем из него заголовки и cookie и отправляем уже новый запрос с успешной авторизацией.
Реализация механизма навыка для Яндекс.Диалогов на Go
Одним из требований разработки для Яндекс.Диалогов является ограничение по времени ожидания ответа от навыка 3-мя секундами. Если запрос не успевает отработать за 3 секунды, то Алиса возвращает довольно неприятный для пользователя ответ "Диалог не отвечает". Чтобы этого избежать, реализуем данное ограничение по времени выполнения запроса на встроенных goroutines языка Go. Таким образом рассмотрим схему работы горутин:
Схема работы горутин в приложении навыка
Расшифровка схемы:
При запросе от пользователя запускаем метод в горутине, который распознает команду от Алисы и запускает в зависимости от команды нужное действие.
Если действие не успело уложиться в таймаут 3-х секунд, то возвращаем Hot answer, что означает некий ответ-заглушку для конкретной команды. Например, ответ "Ваш запрос обрабатывается" вместо "Список успешно обновлен".

Сам метод продолжает выполняться в горутине (Drop answer), и если он был завершен с ошибкой, то ошибка будет записана в BoltDB.
Если действие успело уложиться в таймаут 3-х секунд, то возвращаем Cold answer, что является реальным ответом на действие. Например, список чеклиста от Google Keep.

При этом асинхронно запускается отдельная горутина, которая подчищает дубликаты списка независимо от запроса пользователя.
Для обмена ответами между горутинами используются каналы.

Реализацию механизма hot + cold + drop можно посмотреть в репозитории на GitHub.
Эта общая схема работы горутин подойдет для реализации любых навыков для Яндекс.Диалогов на Go.
Настройки Яндекс.Диалогов
В настройках навыка стоит упомянуть интенты для распознавания структур текста. На данный момент используется два интента: add_delete_products и list, что распознает соответственно фразы добавления и удаления пунктов в чеклист, а также получение активных пунктов списка.
Код интентов можно найти в описании к репозиторию: add_delete_products и list.
Для интента добавления/удаления не нашел какого-то изящного решения, как то которое сейчас есть. Если кто-то знает более красивую реализацию, буду рад рассмотреть варианты.
Фразы активации
запусти навык чек лист
добавь овощи и фрукты
удали макароны
какой получился список?

попроси чек лист добавить печенье
попроси чек лист огласить список
Заключение
Навык разрабатывался преимущественно для себя, с целью легкого управления чеклистом при помощи голосового помощника «Алиса». Дополнительно удалось разобраться с работой API сервиса в обход рекомендуемой документации от Google Keep. Такой подход можно пробовать практиковать на других сервисах, если нет вариантов реализации, понимая минусы, когда приложение будет работать только для пользователя, который сможет предоставить свой har-лог запросов.
Также разработан механизм hot + cold + drop ограничения ответа по времени, когда для каждого действия предусмотрен свой немедленный ответ на случай таймаута. Что позволяет независимо от скорости работы сторонних сервисов вернуть корректный ответ и поддерживать диалог с пользователем.   На данный момент я активно пользуюсь приложением Google Keep для управления заметками на смартфоне. В частности, в дополнение к приложению есть виджет для рабочего стола, который отображает активные заметки. Для покупок в магазине достаточно удобно пользоваться заметками вида "чеклист", о которых и пойдет речь ниже. Как правило для покупок в магазине используется один и тот же набор наименований. Если заполнить такой список пунктами, которые будут помечаться галочкой (т.е. дропаться вниз), а не удаляться, то в последующем при добавлении новых пунктов будут отображаться подсказки по уже добавленным пунктам, что достаточно удобно. Подсказки при добавлении в список уже существующих  Подсказки при добавлении в список уже существующих Казалось бы причем тут Алиса... так вот удобно было бы добавлять такие пункты покупок в список, используя голосовой помощник от Яндекса. Стоит упомянуть, что продукт Google Keep неплохо синхронизирует данные между устройствами, поэтому при манипуляции с заметками изменения достаточно быстро отображаются в виджете. Итак, задача: Итак, задача: Добавлять/удалять пункты в чеклист через Алису
Удалять пункты путём пометки их галочкой, а не через удаление
Не дублировать пункты с одинаковым наименованием Добавлять/удалять пункты в чеклист через Алису Добавлять/удалять пункты в чеклист через Алису Удалять пункты путём пометки их галочкой, а не через удаление Удалять пункты путём пометки их галочкой, а не через удаление Не дублировать пункты с одинаковым наименованием Не дублировать пункты с одинаковым наименованием На этом вроде бы и всё, поехали… Используемый стек технологий: Язык: Go (gin, swagger, mock tests, clean architecture) + Bolt DB
CI/CD: Github + Docker + DigitalOcean Язык: Bolt DB  CI/CD: Код приложения доступен на GitHub. GitHub Управление списком Google Keep В процессе реализации пришлось отказаться от официального api, поскольку оно доступно только для корпоративных аккаунтов: официального api The Google Keep API is used in an enterprise environment to manage Google Keep content and resolve issues identified by cloud security software. The Google Keep API is used in an enterprise environment to manage Google Keep content and resolve issues identified by cloud security software. В качестве альтернативного решения был рассмотрен вариант получения доступа к api через отправку запроса с необходимым набором headers и cookie (своеобразная комбинация параметров отправки jwt токена). Помимо приложения есть web версия сервиса, для редактирования заметок через браузер. Здесь и было подсмотрено итоговое решение для управления персональными заметкам. web версия]]></text>
</doc>
