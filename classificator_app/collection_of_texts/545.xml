<?xml version="1.0" ?>
<doc>
	<label auto="true" type="str" verify="true"><![CDATA[Develop]]></label>
	<author auto="true" type="list" verify="true">
		<item type="str"><![CDATA[tmteam]]></item>
	</author>
	<date auto="true" type="str" verify="true"><![CDATA[2022-12-01, 04:48]]></date>
	<link auto="true" type="str" verify="true"><![CDATA[https://habr.com/ru/post/698190/]]></link>
	<title auto="true" type="str" verify="true"><![CDATA[NFun — expression evaluator для .Net]]></title>
	<categories auto="true" type="list" verify="true">
		<item type="str"><![CDATA[Open source]]></item>
		<item type="str"><![CDATA[Программирование]]></item>
		<item type="str"><![CDATA[.NET]]></item>
		<item type="str"><![CDATA[Компиляторы]]></item>
		<item type="str"><![CDATA[C#]]></item>
	</categories>
	<key_words auto="true" type="list" verify="true">
		<item type="str"><![CDATA[.net]]></item>
		<item type="str"><![CDATA[open-source]]></item>
		<item type="str"><![CDATA[compiler]]></item>
		<item type="str"><![CDATA[nuget]]></item>
		<item type="str"><![CDATA[language design]]></item>
		<item type="str"><![CDATA[c#]]></item>
		<item type="str"><![CDATA[github]]></item>
	</key_words>
	<text auto="true" type="str" verify="true"><![CDATA[Репозиторий.
Примеры и спецификация.
Что есть "Expression evaluator" ?
Expression evaluator позволяет вычислять указанные выражения, например:
12*3 это 36
[1,2,3].reverse() это массив [3,2,1]
'Kate'.reverse() это "etaK"
Выражения могут зависеть от входных переменных:
10*x + 4 зависит от значения x.
'My name is {userName}. Age is {2022-birthYear}' зависит от значений userName и birthYear.
Nfun скрипты в обработке сигналов scada - системы Sonica
Скрипт может содержать несколько таких выражений:
x = Vx*t
y = Vy*t

distance = sqrt(x**2 + y**2)
average = (x+y)/2
В общем случае, вы можете использовать Nfun везде, где раньше вы хранили, передавали или настраивали константы. В примере ниже, мы формульно задаем правила начисления бонусов
// ...`settings.json`...
{
    "offset": "25",
    "timeOffset": "3* 60 * 60 * 24 #sec",
    "condition": "if (age>18) isEmpty(orders) else isEmpty(parent.orders)",
    "bonus": "(min(max(order.price, 20.0), 100) + prevBonus)/ordersCount"
}
Вот несколько примеров использования:
Backend: фильтры входящих запросов;
Embeded: настройка обработки сигналов;
Система лояльности: настройки бонусной программы;
Робототехника: кинематическая модель. Описания траекторий;
Low-code решения.
Что умеет NFun
Nfun продолжает идею библиотеки Ncalc, но для богатой системы типов
Примитивные типы - byte, u16, u32, u64, i16, i32, i64, real, bool, ip, char, text, any
Массивы, структуры, лямбда выражения и Linq.
Арифметические, бинарные, дискретные операторы, операторы по работе с массивами
Условный оператор if.
Интерполяция строк.
Именованные выражения и пользовательские функции.
Строгая типизация с выведением типов.
Встроенные функции.
Кастомизация семантики.
Playground
Установите nuget пакет NFun
PM> Install-Package NFun
Начнем с классики!
var a = Funny.Calc("'Hello world'");
Console.WriteLine(a);
Посчитаем константы
bool   b = Funny.Calc<bool>("false and (2 > 1)"); // false of bool  
double d = Funny.Calc<double>(" 2 * 10 + 1 "); // 21  of double  
int    i = Funny.Calc<int>(" 2 * 10 + 1 "); // 21 of int
Посчитаем выходные данные
class User { public string Age {get;set;} public string Name {get;set;} }

var inputUser = new User{ Age = 42; Name = "Ivan"; }

string userAlias = 
    Funny.Calc<User,string> ( 
        "if(age < 18) name else 'Mr. {name}' ", 
        inputUser);
  
А теперь перейдем в режим хардкора. Этот режим предоставляет доступ ко всем переменным, и к контролю исполнения на низком уровне
var runtime = Funny.Hardcore.Build(
    "y = a-b; " +
    "out = 2*y/(a+b)"
);
// Set inputs
runtime["a"].Value = 30;
runtime["b"].Value = 20;
// Run script
runtime.Run();
// Get outputs
Assert.AreEqual(0.4, runtime["out"].Value);
Мы можем продолжить ...





Синтаксис
Nfun поддерживает однострочные выражения:
12 * x**3 - 3
Многострочные именованные выражения:
nameStr = 'My name is: "{name}"'
ageStr = 'My age is {age}'
result = '{nameStr}. {ageStr}'
И пользовательские функции:
maxOf3(a,b,c) = max(max(a,b),c)

y = maxOf3(1,2,3) # 3
В зависимости от задачи, вы можете включать и отключать эти возможности.
Подробнее про синтаксис
Семантика
Nfun строго типизирован - это было основным вызовом, и ключевой особенность для гармоничной интеграции в C#, а так же защиты от ошибок. Однако, синтаксис языков со строгой типизацией всегда сложнее.
Что бы решить эту проблему я опирался на постулат:
Все, что выглядит как правильный скрипт (в рамках синтаксиса/семантики) - должно запуститься
Или, более формализовано:
Если код выглядит как слабо-типизированный скрипт, но при этом запускается без ошибок, значит для него можно однозначно вывести типы.
Либо показать, что такой код не может быть выполнен без ошибок.
Это потребовало разработки сложной системы выведения типов, от которой и отталкивается вся семантика языка. Результатом этого является повсеместное использование Generic-ов.
В примере ниже - функции, вычисления, и даже константы - являются обобщенными типами (из списка int32, uint32, int64, uint64, real). Однако, пользователь не должен задумываться об этом:
var expr = @"
  # generic function
  inc(a) = a + 1  

  # generic calculation
  out = 42.inc().inc()
";
double d = Funny.Calc<double>(expr); // 44  of double  
int    i = Funny.Calc<int>(expr); // 44 of int
Таким образом, удалось собрать все преимущества строгой типизации:
Если типы выражения не сходятся - вы получаете ошибку на этапе интерпретации.
Если типы не сходятся с ожидаемыми C# типами - вы получаете ошибку на этапе интерпретации.
Производительность.
При этом, синтаксис остался максимально простым для неподготовленного пользователя!
Технические детали
Так как Nfun под капотом это - "почти язык программирования", то его архитектура достаточно стандартна. Не буду описывать ее здесь подробно, об этом уже есть много классных статей.
Интерпритацию кода можно разделить на несколько этапов:
1. Токенизация (лексер).
Самописный лексер разбирает входную строку на токены, учитывается возможность интерполяции строк.
2. Парсинг.
Разбор токенов в дерево AST. Используется самописный парсер. Спецификация синтаксиса опирается на спецификацию языка (и очень много тестов). Формальная грамматика не описана.
3. Выведение типов.
Кастомный, графовый алгоритм выведения типов, с поддержкой неявных преобразований между типами.
Нюансы:
Целочисленные константы являются "обобщенными константами"
one() = 1 # returns T, where byte -> T -> real 

y:int  = one() # 1 of int
z:real = one() # 1.0 of real
Тип узла может зависеть, как от предыдущего, так и от последующего кода
y = 1 # y:real, так как используется в знаменателе на следующей строчке
x:real = 1/y
Ограничения на дженерик-переменные могут быть заданы, как сверху (наследование, тип к которому можно привести данный), так и снизу ( потомок, тип, которой может быть приведен к данному)
sum(a,b) = a+b

x:int  = 1 + 2  # x = 3 of int
y:real = 1 + 2 # y = 3.0 of real
z:byte = 1 + 2 # error! operator '+' is defined for (uint16|int16)-> T -> real
               # so it cannot return 'byte'
4. Сборка выражений (построение рантайма)
Из результатов решения типов и Ast-дерева собирается самописное дерево вычисляемых выражений.
Конвертация CLR-значений в Nfun.
Исполнение выражений.
Конвертация результатов в CLR значения.
Я сознательно не использовал Csharp-expression-tree, так как, одним из важнейших критериев была скорость "one-time-shot". То есть запуска, от момента получения строки со скриптом и до момента получения результатов выполнения.
Состояние проекта
Проект готов к использованию в продакшене.
Используется в течении года в составе scada-системы, покрыт 6000+ тестами, к нему написана спецификация, и.. даже есть несколько звездочек на гитхабе (да-да, это call to action!). Почти успех!
Заключение
Когда я начинал Nfun, я мечтал создать простой, надежный и интуитивный опенсорс-инструмент. Я хотел реализовать синтаксические идеи и поэкспериментировать с системами выведения типов, попробовать для себя что-то новое...
По итогу, Nfun стоил огромного количества сил, времени и инвестигаций. Я впервые столкнулся с подобной задачей. Теперь мне хочется, чтобы люди пользовались этим инструментом! И писали тикеты, да реквесты на гитхаб. Ну, или комментарии под этот пост ;) Репозиторий. Репозиторий Репозиторий Примеры и спецификация. Примеры и спецификация Примеры и спецификация Что есть "Expression evaluator" ? Expression evaluator позволяет вычислять указанные выражения, например: 12*3 это 36
[1,2,3].reverse() это массив [3,2,1]
'Kate'.reverse() это "etaK" 12*3 это 36 12*3 это 36 12*3 [1,2,3].reverse() это массив [3,2,1] [1,2,3].reverse() это массив [3,2,1] [1,2,3].reverse() 'Kate'.reverse() это "etaK" 'Kate'.reverse() это "etaK" 'Kate'.reverse() Выражения могут зависеть от входных переменных: 10*x + 4 зависит от значения x.
'My name is {userName}. Age is {2022-birthYear}' зависит от значений userName и birthYear. 10*x + 4 зависит от значения x. 10*x + 4 зависит от значения x. 10*x + 4 x 'My name is {userName}. Age is {2022-birthYear}' зависит от значений userName и birthYear. 'My name is {userName}. Age is {2022-birthYear}' зависит от значений userName и birthYear. 'My name is {userName}. Age is {2022-birthYear}' userName birthYear  Nfun скрипты в обработке сигналов scada - системы Sonica Скрипт может содержать несколько таких выражений: x = Vx*t
y = Vy*t

distance = sqrt(x**2 + y**2)
average = (x+y)/2 x = Vx*t
y = Vy*t

distance = sqrt(x**2 + y**2)
average = (x+y)/2 В общем случае, вы можете использовать Nfun везде, где раньше вы хранили, передавали или настраивали константы. В примере ниже, мы формульно задаем правила начисления бонусов // ...`settings.json`...
{
    "offset": "25",
    "timeOffset": "3* 60 * 60 * 24 #sec",
    "condition": "if (age>18) isEmpty(orders) else isEmpty(parent.orders)",
    "bonus": "(min(max(order.price, 20.0), 100) + prevBonus)/ordersCount"
} // ...`settings.json`...
{
    "offset": "25",
    "timeOffset": "3* 60 * 60 * 24 #sec",
    "condition": "if (age>18) isEmpty(orders) else isEmpty(parent.orders)",
    "bonus": "(min(max(order.price, 20.0), 100) + prevBonus)/ordersCount"
} Вот несколько примеров использования: Backend: фильтры входящих запросов;
Embeded: настройка обработки сигналов;
Система лояльности: настройки бонусной программы;
Робототехника: кинематическая модель. Описания траекторий;
Low-code решения. Backend: фильтры входящих запросов; Backend: фильтры входящих запросов; Embeded: настройка обработки сигналов; Embeded: настройка обработки сигналов; Система лояльности: настройки бонусной программы; Система лояльности: настройки бонусной программы; Робототехника: кинематическая модель. Описания траекторий; Робототехника: кинематическая модель. Описания траекторий; Low-code решения. Low-code решения. Что умеет NFun Nfun продолжает идею библиотеки Ncalc, но для богатой системы типов Ncalc Примитивные типы - byte, u16, u32, u64, i16, i32, i64, real, bool, ip, char, text, any
Массивы, структуры, лямбда выражения и Linq.
Арифметические, бинарные, дискретные операторы, операторы по работе с массивами
Условный оператор if.
Интерполяция строк.
Именованные выражения и пользовательские функции.
Строгая типизация с выведением типов.
Встроенные функции.
Кастомизация семантики. Примитивные типы - byte, u16, u32, u64, i16, i32, i64, real, bool, ip, char, text, any Примитивные типы - byte, u16, u32, u64, i16, i32, i64, real, bool, ip, char, text, any byte u16 u32 u64 i16 i32 i64 real bool ip char text any Массивы, структуры, лямбда выражения и Linq. Массивы, структуры, лямбда выражения и Linq. Арифметические, бинарные, дискретные операторы, операторы по работе с массивами Арифметические, бинарные, дискретные операторы, операторы по работе с массивами Условный оператор if. Условный оператор if. if Интерполяция строк. Интерполяция строк. Именованные выражения и пользовательские функции. Именованные выражения и пользовательские функции. Строгая типизация с выведением типов. Строгая типизация с выведением типов. Встроенные функции. Встроенные функции. Кастомизация семантики. Кастомизация семантики. Playground Установите nuget пакет NFun NFun PM> Install-Package NFun PM> Install-Package NFun Начнем с классики! var a = Funny.Calc("'Hello world'");
Console.WriteLine(a); var a = Funny.Calc("'Hello world'");
Console.WriteLine(a); Посчитаем константы bool   b = Funny.Calc<bool>("false and (2 > 1)"); // false of bool  
double d = Funny.Calc<double>(" 2 * 10 + 1 "); // 21  of double  
int    i = Funny.Calc<int>(" 2 * 10 + 1 "); // 21 of int bool   b = Funny.Calc<bool>("false and (2 > 1)"); // false of bool  
double d = Funny.Calc<double>(" 2 * 10 + 1 "); // 21  of double  
int    i = Funny.Calc<int>(" 2 * 10 + 1 "); // 21 of int Посчитаем выходные данные class User { public string Age {get;set;} public string Name {get;set;} }

var inputUser = new User{ Age = 42; Name = "Ivan"; }

string userAlias = 
    Funny.Calc<User,string> ( 
        "if(age < 18) name else 'Mr. {name}' ", 
        inputUser);
   class User { public string Age {get;set;} public string Name {get;set;} }

var inputUser = new User{ Age = 42; Name = "Ivan"; }

string userAlias = 
    Funny.Calc<User,string> ( 
        "if(age < 18) name else 'Mr. {name}' ", 
        inputUser);
   А теперь перейдем в режим хардкора. Этот режим предоставляет доступ ко всем переменным, и к контролю исполнения на низком уровне var runtime = Funny.Hardcore.Build(
    "y = a-b; " +
    "out = 2*y/(a+b)"
);
// Set inputs
runtime["a"].Value = 30;
runtime["b"].Value = 20;
// Run script
runtime.Run();
// Get outputs
Assert.AreEqual(0.4, runtime["out"].Value); var runtime = Funny.Hardcore.Build(
    "y = a-b; " +
    "out = 2*y/(a+b)"
);
// Set inputs
runtime["a"].Value = 30;
runtime["b"].Value = 20;
// Run script
runtime.Run();
// Get outputs
Assert.AreEqual(0.4, runtime["out"].Value); Мы можем продолжить ... Мы можем продолжить ...                  Синтаксис Nfun поддерживает однострочные выражения: 12 * x**3 - 3 12 * x**3 - 3 Многострочные именованные выражения: nameStr = 'My name is: "{name}"'
ageStr = 'My age is {age}'
result = '{nameStr}. {ageStr}' nameStr = 'My name is: "{name}"'
ageStr = 'My age is {age}'
result = '{nameStr}. {ageStr}' И пользовательские функции: maxOf3(a,b,c) = max(max(a,b),c)

y = maxOf3(1,2,3) # 3 maxOf3(a,b,c) = max(max(a,b),c)

y = maxOf3(1,2,3) # 3 В зависимости от задачи, вы можете включать и отключать эти возможности. Подробнее про синтаксис Подробнее про синтаксис                        Семантика Nfun строго типизирован - это было основным вызовом, и ключевой особенность для гармоничной интеграции в C#, а так же защиты от ошибок. Однако, синтаксис языков со строгой типизацией всегда сложнее. Что бы решить эту проблему я опирался на постулат: Все, что выглядит как правильный скрипт (в рамках синтаксиса/семантики) - должно запуститься Все, что выглядит как правильный скрипт (в рамках синтаксиса/семантики) - должно запуститься Или, более формализовано: Если код выглядит как слабо-типизированный скрипт, но при этом запускается без ошибок, значит для него можно однозначно вывести типы.
Либо показать, что такой код не может быть выполнен без ошибок. Если код выглядит как слабо-типизированный скрипт, но при этом запускается без ошибок, значит для него можно однозначно вывести типы. Либо показать, что такой код не может быть выполнен без ошибок. Это потребовало разработки сложной системы выведения типов, от которой и отталкивается вся семантика языка. Результатом этого является повсеместное использование Generic-ов. В примере ниже - функции, вычисления, и даже константы - являются обобщенными типами (из списка int32, uint32, int64, uint64, real). Однако, пользователь не должен задумываться об этом: int32 uint32 int64 uint64 real var expr = @"
  # generic function
  inc(a) = a + 1  

  # generic calculation
  out = 42.inc().inc()
";
double d = Funny.Calc<double>(expr); // 44  of double  
int    i = Funny.Calc<int>(expr); // 44 of int var expr = @"
  # generic function
  inc(a) = a + 1  

  # generic calculation
  out = 42.inc().inc()
";
double d = Funny.Calc<double>(expr); // 44  of double  
int    i = Funny.Calc<int>(expr); // 44 of int Таким образом, удалось собрать все преимущества строгой типизации: Если типы выражения не сходятся - вы получаете ошибку на этапе интерпретации.
Если типы не сходятся с ожидаемыми C# типами - вы получаете ошибку на этапе интерпретации.
Производительность. Если типы выражения не сходятся - вы получаете ошибку на этапе интерпретации. Если типы выражения не сходятся - вы получаете ошибку на этапе интерпретации. Если типы не сходятся с ожидаемыми C# типами - вы получаете ошибку на этапе интерпретации. Если типы не сходятся с ожидаемыми C# типами - вы получаете ошибку на этапе интерпретации. Производительность. Производительность. При этом, синтаксис остался максимально простым для неподготовленного пользователя! Технические детали Так как Nfun под капотом это - "почти язык программирования", то его архитектура достаточно стандартна. Не буду описывать ее здесь подробно, об этом уже есть много классных статей. Интерпритацию кода можно разделить на несколько этапов: 1. Токенизация (лексер). Самописный лексер разбирает входную строку на токены, учитывается возможность интерполяции строк. 2. Парсинг. Разбор токенов в дерево AST. Используется самописный парсер. Спецификация синтаксиса опирается на спецификацию языка (и очень много тестов). Формальная грамматика не описана. 3. Выведение типов. Кастомный, графовый алгоритм выведения типов, с поддержкой неявных преобразований между типами. Нюансы: Целочисленные константы являются "обобщенными константами" Целочисленные константы являются "обобщенными константами" Целочисленные константы являются "обобщенными константами" one() = 1 # returns T, where byte -> T -> real 

y:int  = one() # 1 of int
z:real = one() # 1.0 of real one() = 1 # returns T, where byte -> T -> real 

y:int  = one() # 1 of int
z:real = one() # 1.0 of real Тип узла может зависеть, как от предыдущего, так и от последующего кода Тип узла может зависеть, как от предыдущего, так и от последующего кода Тип узла может зависеть, как от предыдущего, так и от последующего кода y = 1 # y:real, так как используется в знаменателе на следующей строчке
x:real = 1/y y = 1 # y:real, так как используется в знаменателе на следующей строчке
x:real = 1/y Ограничения на дженерик-переменные могут быть заданы, как сверху (наследование, тип к которому можно привести данный), так и снизу ( потомок, тип, которой может быть приведен к данному) Ограничения на дженерик-переменные могут быть заданы, как сверху (наследование, тип к которому можно привести данный), так и снизу ( потомок, тип, которой может быть приведен к данному) Ограничения на дженерик-переменные могут быть заданы, как сверху (наследование, тип к которому можно привести данный), так и снизу ( потомок, тип, которой может быть приведен к данному) sum(a,b) = a+b

x:int  = 1 + 2  # x = 3 of int
y:real = 1 + 2 # y = 3.0 of real
z:byte = 1 + 2 # error! operator '+' is defined for (uint16|int16)-> T -> real
               # so it cannot return 'byte' sum(a,b) = a+b

x:int  = 1 + 2  # x = 3 of int
y:real = 1 + 2 # y = 3.0 of real
z:byte = 1 + 2 # error! operator '+' is defined for (uint16|int16)-> T -> real
               # so it cannot return 'byte' 4. Сборка выражений (построение рантайма) Из результатов решения типов и Ast-дерева собирается самописное дерево вычисляемых выражений. Конвертация CLR-значений в Nfun.
Исполнение выражений.
Конвертация результатов в CLR значения. Конвертация CLR-значений в Nfun. Конвертация CLR-значений в Nfun. Исполнение выражений. Исполнение выражений. Конвертация результатов в CLR значения. Конвертация результатов в CLR значения. Я сознательно не использовал Csharp-expression-tree, так как, одним из важнейших критериев была скорость "one-time-shot". То есть запуска, от момента получения строки со скриптом и до момента получения результатов выполнения. Состояние проекта Проект готов к использованию в продакшене. Используется в течении года в составе scada-системы, покрыт 6000+ тестами, к нему написана спецификация, и.. даже есть несколько звездочек на гитхабе (да-да, это call to action!). Почти успех! Заключение Когда я начинал Nfun, я мечтал создать простой, надежный и интуитивный опенсорс-инструмент. Я хотел реализовать синтаксические идеи и поэкспериментировать с системами выведения типов, попробовать для себя что-то новое... По итогу, Nfun стоил огромного количества сил, времени и инвестигаций. Я впервые столкнулся с подобной задачей. Теперь мне хочется, чтобы люди пользовались этим инструментом! И писали тикеты, да реквесты на гитхаб. Ну, или комментарии под этот пост ;)  ]]></text>
</doc>
