<?xml version="1.0" ?>
<doc>
	<original_author auto="true" type="list" verify="true">
		<item type="str"><![CDATA[Christian Schüler]]></item>
	</original_author>
	<label auto="true" type="str" verify="true"><![CDATA[Other]]></label>
	<author auto="true" type="list" verify="true">
		<item type="str"><![CDATA[SergeySib]]></item>
	</author>
	<date auto="true" type="str" verify="true"><![CDATA[2022-06-09, 12:11]]></date>
	<link auto="true" type="str" verify="true"><![CDATA[https://habr.com/ru/post/670522/]]></link>
	<title auto="true" type="str" verify="true"><![CDATA[Вычисление касательного базиса налету]]></title>
	<categories auto="true" type="list" verify="true">
		<item type="str"><![CDATA[Работа с 3D-графикой]]></item>
		<item type="str"><![CDATA[Разработка игр]]></item>
		<item type="str"><![CDATA[Математика]]></item>
	</categories>
	<key_words auto="true" type="list" verify="true">
		<item type="str"><![CDATA[GLSL]]></item>
		<item type="str"><![CDATA[шейдеры]]></item>
		<item type="str"><![CDATA[сопряженное пространство]]></item>
		<item type="str"><![CDATA[нормали]]></item>
		<item type="str"><![CDATA[касательные]]></item>
		<item type="str"><![CDATA[касательное пространство]]></item>
	</key_words>
	<text auto="true" type="str" verify="true"><![CDATA[Этот пост написан автором в далёком 2013 году как дополнение к статье из 2006 года [4]. Тем не менее, предпосылки к отказу от хранения предрассчитанных касательных справедливы и в 2022, а вывод формул изложен понятно и без излишеств.
Мотивация к разработке этого метода заключается в создании касательного базиса налету во фрагментном шейдере, что по иронии диаметрально противоположно мотивации из статьи [2] от 1997 года:
В статье представлен метод бамп-маппинга с минимальным требованием к железу помимо того, которое нужно для освещения по Фонгу. Мы избавимся от затратного попиксельного восстановления касательного пространства...
Так как за окном более не 1997 год, вычисление касательного пространства во фрагментах потенциально даёт некоторый выигрыш:
Понижается сложность инструментария для создания ассетов.
Экономится шина и память для выборки и хранения вершин.
Экономятся интерполяторы атрибутов между геометрическими и фрагментной стадиями.
Отпадает необходимость преобразовывать касательные в вершинном шейдере
Становится проще накладывать карты нормалей при нелинейных деформациях
Лирическое отступление: касательные и дуальные к ним
Обычно нормалмаппинг подаётся в статьях не совсем правильно, что я проиллюстрирую простой метафорой на C++. Пусть есть класс Vector3 для векторов, и есть класс Covector3 для ковекторов. Последний будет копией класса обычных векторов за исключением того что он по другому ведёт себя при трансформациях (за подробным введением в ковекторы и сопряжённые пространства смотрите эту статью). Как вы возможно знаете, нормаль - это на самом деле ковектор, а значит так мы её и объявим. Теперь вообразим такую функцию:
Vector3 tangent;
Vector3 bitangent;
Covector3 normal;
Covector3 perturb_normal( float a, float b, float c )
{
    return
        a * tangent +
        b * bitangent +
        c * normal;
        // ^^^^ compile-error: type mismatch for operator +
}
Эта функция замешивает векторы и ковекторы в одно выражение, что ведёт к ошибке компиляции. Если normal объявлена типом Covector3, то tangent и bitangent должны быть того же типа, иначе из них нельзя сделать единый базис. В реальном мире в коде шейдера всё это будет объявлено типом vec3 и будет работать, хоть и не всегда.
Математическая ошибка компиляции
Прискорбно, но "касательное пространство" для нормалмаппинга было введено авторами статьи [2] через вышеупомянутое несоответствие. Всё работает правильно до тех пор пока касательный базис ортогонален. Но когда дело доходит до восстановления касательного базиса во фрагментном шейдере, приходится иметь дело с неортогональной проекцией на экран. Именно по этой причине в исходной статье я ввёл (который должен быть дуальным касательным, "кокасательным") и (который должен называться ко-би-касательной, как бы упорото это ни звучало) как ковекторы, иначе алгоритм не заработал бы. Таким образом, TBN-базис должен называться не касательным, а кокасательным.
Экскурс в историю: возмущённые нормали Блинна
В этом разделе я покажу как определение и ковекторами естественным образом следует из оригинальной статьи Блинна [1] о бамп-маппинге. Блинн рассматривает криволинейную параметрическую поверхность (например, участок поверхности Безье), на которой он определяет векторы и как производные координаты точки поверхности по и .
В этом контексте он пишет нижние индексы как краткое обозначение производных, то есть . Нормаль к поверхности он вводит и функцию высот . Наконец, он получает первое приближение формулы возмущённой нормали:
Обратите внимание на слагаемые и . Они перпендикулярны и в касательной плоскости, и все вместе образуют базис для смещения и . Кроме того, они ковекторы, что видно из их поведения при трансформациях. А значит их сложение с нормалью не приводит к несоответствию типов. Если мы разделим эти слагаемые на и обратим их знак, то придём к следующему определению и :
где крышечка обозначает единичную нормаль. Это определение совпадает с таковым в [4]. можно понимать как нормаль к плоскости заданного , а — как нормаль к плоскости заданного . В итоге у нас есть три взаимно-перпендикулярных вектора (точнее, ковектора) , и, составляющие базис сопряжённого касательного пространства. А ещё и это градиенты и . Модуль градиентов определяет величину изменения высоты, о чём поговорим ниже.
Забудьте то чему вас учили раньше
Многие авторы ошибочно берут и за и , что верно лишь пока векторы ортогональны. Давайте забудем "касательные", возьмём "кокасательные" и повторим историческое развитие с этой точки зрения: Пирси с соавторами [2] предрасчитывают значения и (изменение высоты на единицу изменения текстурных координат) и сохраняет их в текстуру. Они называют это "картой нормалей", но фактически это "карта крутизны уклонов", которая недавно была переизобретена под названием карта производных. В такую карту нельзя закодировать горизонтальные нормали, потому что тогда пришлось бы кодировать бесконечное значение крутизны. В дополнение к этой карте нужно ещё хранить некий множитель силы смещения. Килгард [3] вводит карты нормалей в современном понимании как закодированный оператор вращения, полностью избавляясь от аппроксимаций путём явного определения возмущённой нормали:
где , и вычитываются из текстуры. Многие думают, что в карте нормалей хранятся нормали, но это верно лишь отчасти. Идея Килгарда была следующей: так как невозмущённая нормаль - это [0, 0, 1], то достаточно хранить лишь последний столбец матрицы вращения чтобы вычислить возмущённую нормаль. В общем да, карта нормалей хранит векторы, соответствующие возмущённым нормалям, но фактически это закодированный оператор вращения. Трудности начинаются когда нужно сблендить несколько карт нормалей, потому что это интерполяция вращений со всеми вытекающими. Более подробный обзор здесь.
Вывод формул двойственного касательного базиса
Перед нами стоит задача, обратная к решённой в работе Блинна. Из карты нормалей мы знаем возмущённую нормаль, но не знаем двойственный касательный базис. Определим неизвестные (ко)касательные как градиенты текстурных координат и : и , а сами текстурные координаты неявно определим как функции координат вершины :
где точка - это скалярное произведение. Градиенты постоянны для интерполированных значений внутри треугольника, потому введём разности , , , , а так же и . Искомые базисные векторы должны удовлетворять условиям:
Первые две строки следуют из определений, а последняя из условия что (ко)касательные перпендикулярны нормали. Последняя строка нужна потому что без неё задача недоопределена. Отсюда можно выразить в матричной форме:
и находятся аналогично.
Переходим к коду шейдера
Полученный результат выглядит устрашающе потому что нужно обращать матрицу в каждом фрагменте! Однако, используя некоторые симметрии, код обращения можно свести к минимуму. Ниже приведён пример функции на GLSL для обращения матрицы 3х3. Похожий код на HLSL появлялся в книге, но с тех пор я его сильно оптимизировал. Смотрите как из веткорных произведений можно получить определитель и присоединённую матрицу:
mat3 inverse3x3( mat3 M )
{
    mat3 M_t = transpose( M ); 
    float det = dot( cross( M_t[0], M_t[1] ), M_t[2] ); 
    mat3 adjugate = mat3( cross( M_t[1], M_t[2] ), cross( M_t[2], M_t[0] ), cross( M_t[0], M_t[1] ) ); 
    return adjugate / det;
}
Строки матрицы из предыдущей части можно подставить в код, раскрыть скобки, привести подобные, получив новое выражение для . Определитель превращается в , а присоединённую матрицу можно записать с помощью двух новых переменных и :
Внимательный читатель возможно догадался, что и это перпендикуляры к сторонам треугольника в плоскости треугольника. И конечно же они ковекторы, образующие хороший базис сопряжённого касательного пространства. Для упрощения дальнейшего изложения заметим следующее:
Последняя строка матрицы неважна, потому что умножается на 0.
Остальные строки матрицы содержат перпендикуляры ( и ), которые после транспонирования умножаются на численные производные текстурных координат.
Вместо нормали к грани ( ) можно взять интерполированную нормаль к вершине, что проще и даёт лучший визуальный результат.
Определитель (выражение ) можно отбросить, о чём ниже в разделе про инвариантность при масштабировании.
В итоге код получается простым и надёжным:
mat3 cotangent_frame( vec3 N, vec3 p, vec2 uv )
{
    // Численные производные
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );
    
    // Решаем линейную систему
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
    
    // Собираем масштабно-инвариантный базис
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
}
Инвариантность при масштабировании
В выведенном выше выражении оставался определитель . Из-за этого дуальные касательные и изменяются обратно пропорционально масштабу модели. Так получается потому что они градиенты. Если масштаб треугольника увеличивается, а всё остальное остаётся неизменным, то изменение текстурных координат на единицу изменения координаты вершин становится меньше. Из-за этого уменьшается и (аналогично) по отношению к . В итоге, уменьшается возмущение нормали при увеличении масштаба треугольника, как будто карта высот растянулась.
Хотя такое поведение абсолютно логично и корректно, оно мешает накладывать нормалмапы на геометрию различного масштаба. Для решения этой проблемы (как видно из кода), я отбрасываю определитель и нормирую и по длине большего из них. Этот хак сохраняет относительные длины и , и даже скошенный или растянутый базис сопряжённого касательного пространства обрабатывается корректно.
Бесперспективная оптимизация
В качестве агрессивной оптимизации я попробовал положить и . Это значит что треугольник прямоугольный, и перпендикуляр к одному катету совпадает со вторым катетом. Во фрагментном шейдере это условие выполняется когда проекция на экран не вносит перспективных искажений. В [4] есть хороший рисунок с демонстрацией этого факта. Такая оптимизация экономит ещё два векторных произведения, но по-моему сильно вредит качеству если фактически перспективное искажение есть.
Собираем всё воедино
Для полноты картины я покажу как с помощью сопряжённого касательного пространства возмутить интерполированную вершинную нормаль. Этим занимается функция perturb_normal, используя вектор из фрагмента в камеру вместо координаты вершины. Это нормально, потому что при вычислении разности положение камеры сокращается.
vec3 perturb_normal( vec3 N, vec3 V, vec2 texcoord ) 
{ 
    // N - интерполированная нормаль,
    // V - интерполированный вектор из вершины в камеру
    vec3 map = texture2D( mapBump, texcoord ).xyz;
#ifdef WITH_NORMALMAP_UNSIGNED
    map = map * 255./127. - 128./127.; 
#endif 
#ifdef WITH_NORMALMAP_2CHANNEL 
    map.z = sqrt( 1. - dot( map.xy, map.xy ) ); 
#endif 
#ifdef WITH_NORMALMAP_GREEN_UP 
    map.y = -map.y; 
#endif
    mat3 TBN = cotangent_frame( N, -V, texcoord ); 
    return normalize( TBN * map ); 
}
varying vec3 g_vertexnormal; 
varying vec3 g_viewvector;// camera pos - vertex pos 
varying vec2 g_texcoord;   

void main() 
{
    vec3 N = normalize( g_vertexnormal );   
#ifdef WITH_NORMALMAP 
    N = perturb_normal( N, g_viewvector, g_texcoord ); 
#endif   
    // ... 
}
Зелёная ось
OpenGL и DirectX считают началом координат начало массива данных текстуры. Текстурная координата (0, 0) - это угол пикселя, на который указывает указатель на данные изображения. Большинство 3д-пакетов устроены иначе: они считают началом координат нижний левый угол uv-развёртки. Это означает что начало текстурных координат находится в углу первого пикселя последней строки изображения.
Поиск по картинкам в Гугле показывает что нет никакого общепринятого соглашения о зелёном канале в картах нормалей. У некоторых зелёный канал указывает вверх, а у некоторых - вниз. Наши художники предпочитают направление вверх по двум причинам: во-первых, 3ds Max работает именно с таким форматом, а во-вторых, он выглядит естественнее, как при освещении зелёным светом сверху. Это облегчает восприятие карты нормалей невооружённым глазом.
Оглядываясь назад
Исходная статья была написана на уровне демонстрации идеи. Хотя алгоритм был протестирован и работал, он был тяжеловат для того времени. Сегодня ситуация изменилась. Я использую этот алгоритм в реальных проектах и больше не парюсь с касательными в вершинных атрибутах. Мне больше не важно, правильно ли экспортируются касательные из Макса или Майи. Художники тоже не чувствуют потери какой-то части своего пайплайна, потому что всё довольно естественно: есть геометрия, есть текстурные координаты и карта нормалей, и оно просто работает.
Нет никакого касательного базиса в нормалмаппинге. Касательный базис, содержащий нормаль, логически неверен. Под него маскируется двойственный ("кокасательный") базис, когда он ортогонален. А когда он становится неортогональным, он перестаёт работать. Используйте двойственный базис.
Список литературы
[1] James Blinn, “Simulation of wrinkled surfaces”, SIGGRAPH 1978
[2] Mark Peercy, John Airey, Brian Cabral, “Efficient Bump Mapping Hardware”, SIGGRAPH 1997
[3] Mark J Kilgard, “A Practical and Robust Bump-mapping Technique for Today’s GPUs”, GDC 2000
[4] Christian Schüler, “Normal Mapping without Precomputed Tangents”, ShaderX 5, Chapter 2.6, pp. 131 – 140
[5] Colin Barré-Brisebois and Stephen Hill, “Blending in Detail” Этот пост написан автором в далёком 2013 году как дополнение к статье из 2006 года [4]. Тем не менее, предпосылки к отказу от хранения предрассчитанных касательных справедливы и в 2022, а вывод формул изложен понятно и без излишеств. Мотивация к разработке этого метода заключается в создании касательного базиса налету во фрагментном шейдере, что по иронии диаметрально противоположно мотивации из статьи [2] от 1997 года:    В статье представлен метод бамп-маппинга с минимальным требованием к железу помимо того, которое нужно для освещения по Фонгу. Мы избавимся от затратного попиксельного восстановления касательного пространства... В статье представлен метод бамп-маппинга с минимальным требованием к железу помимо того, которое нужно для освещения по Фонгу. Мы избавимся от затратного попиксельного восстановления касательного пространства... Мы избавимся от затратного попиксельного восстановления касательного пространства Так как за окном более не 1997 год, вычисление касательного пространства во фрагментах потенциально даёт некоторый выигрыш: Понижается сложность инструментария для создания ассетов.
Экономится шина и память для выборки и хранения вершин.
Экономятся интерполяторы атрибутов между геометрическими и фрагментной стадиями.
Отпадает необходимость преобразовывать касательные в вершинном шейдере
Становится проще накладывать карты нормалей при нелинейных деформациях Понижается сложность инструментария для создания ассетов. Понижается сложность инструментария для создания ассетов. Экономится шина и память для выборки и хранения вершин. Экономится шина и память для выборки и хранения вершин. Экономятся интерполяторы атрибутов между геометрическими и фрагментной стадиями. Экономятся интерполяторы атрибутов между геометрическими и фрагментной стадиями. Отпадает необходимость преобразовывать касательные в вершинном шейдере Отпадает необходимость преобразовывать касательные в вершинном шейдере Становится проще накладывать карты нормалей при нелинейных деформациях Становится проще накладывать карты нормалей при нелинейных деформациях Лирическое отступление: касательные и дуальные к ним Обычно нормалмаппинг подаётся в статьях не совсем правильно, что я проиллюстрирую простой метафорой на C++. Пусть есть класс Vector3 для векторов, и есть класс Covector3 для ковекторов. Последний будет копией класса обычных векторов за исключением того что он по другому ведёт себя при трансформациях (за подробным введением в ковекторы и сопряжённые пространства смотрите эту статью). Как вы возможно знаете, нормаль - это на самом деле ковектор, а значит так мы её и объявим. Теперь вообразим такую функцию: Vector3 Covector3 ковекторов эту статью Vector3 tangent;
Vector3 bitangent;
Covector3 normal;
Covector3 perturb_normal( float a, float b, float c )
{
    return
        a * tangent +
        b * bitangent +
        c * normal;
        // ^^^^ compile-error: type mismatch for operator +
} Vector3 tangent;
Vector3 bitangent;
Covector3 normal;
Covector3 perturb_normal( float a, float b, float c )
{
    return
        a * tangent +
        b * bitangent +
        c * normal;
        // ^^^^ compile-error: type mismatch for operator +
} Эта функция замешивает векторы и ковекторы в одно выражение, что ведёт к ошибке компиляции. Если normal объявлена типом Covector3, то tangent и bitangent должны быть того же типа, иначе из них нельзя сделать единый базис. В реальном мире в коде шейдера всё это будет объявлено типом vec3 и будет работать, хоть и не всегда. normal Covector3 tangent bitangent vec3 Математическая ошибка компиляции Прискорбно, но "касательное пространство" для нормалмаппинга было введено авторами статьи [2] через вышеупомянутое несоответствие. Всё работает правильно до тех пор пока касательный базис ортогонален. Но когда дело доходит до восстановления касательного базиса во фрагментном шейдере, приходится иметь дело с неортогональной проекцией на экран. Именно по этой причине в исходной статье я ввёл (который должен быть дуальным касательным, "кокасательным") и (который должен называться ко-би-касательной, как бы упорото это ни звучало) как ковекторы, иначе алгоритм не заработал бы. Таким образом, TBN-базис должен называться не касательным, а кокасательным. неортогональной проекцией на экран   кокасательным Экскурс в историю: возмущённые нормали Блинна В этом разделе я покажу как определение и ковекторами естественным образом следует из оригинальной статьи Блинна [1] о бамп-маппинге. Блинн рассматривает криволинейную параметрическую поверхность (например, участок поверхности Безье), на которой он определяет векторы и как производные координаты точки поверхности по и .           В этом контексте он пишет нижние индексы как краткое обозначение производных, то есть . Нормаль к поверхности он вводит и функцию высот . Наконец, он получает первое приближение формулы возмущённой нормали:     Обратите внимание на слагаемые и . Они перпендикулярны и в касательной плоскости, и все вместе образуют базис для смещения и . Кроме того, они ковекторы, что видно из их поведения при трансформациях. А значит их сложение с нормалью не приводит к несоответствию типов. Если мы разделим эти слагаемые на и обратим их знак, то придём к следующему определению и :   перпендикулярны          где крышечка обозначает единичную нормаль. Это определение совпадает с таковым в [4]. можно понимать как нормаль к плоскости заданного , а — как нормаль к плоскости заданного . В итоге у нас есть три взаимно-перпендикулярных вектора (точнее, ковектора) , и, составляющие базис сопряжённого касательного пространства. А ещё и это градиенты и . Модуль градиентов определяет величину изменения высоты, о чём поговорим ниже.            Забудьте то чему вас учили раньше Многие авторы ошибочно берут и за и , что верно лишь пока векторы ортогональны. Давайте забудем "касательные", возьмём "кокасательные" и повторим историческое развитие с этой точки зрения: Пирси с соавторами [2] предрасчитывают значения и (изменение высоты на единицу изменения текстурных координат) и сохраняет их в текстуру. Они называют это "картой нормалей", но фактически это "карта крутизны уклонов", которая недавно была переизобретена под названием карта производных. В такую карту нельзя закодировать горизонтальные нормали, потому что тогда пришлось бы кодировать бесконечное значение крутизны. В дополнение к этой карте нужно ещё хранить некий множитель силы смещения. Килгард [3] вводит карты нормалей в современном понимании как закодированный оператор вращения, полностью избавляясь от аппроксимаций путём явного определения возмущённой нормали:       карта производных закодированный оператор вращения  где , и вычитываются из текстуры. Многие думают, что в карте нормалей хранятся нормали, но это верно лишь отчасти. Идея Килгарда была следующей: так как невозмущённая нормаль - это [0, 0, 1], то достаточно хранить лишь последний столбец матрицы вращения чтобы вычислить возмущённую нормаль. В общем да, карта нормалей хранит векторы, соответствующие возмущённым нормалям, но фактически это закодированный оператор вращения. Трудности начинаются когда нужно сблендить несколько карт нормалей, потому что это интерполяция вращений со всеми вытекающими. Более подробный обзор здесь.    здесь Вывод формул двойственного касательного базиса Перед нами стоит задача, обратная к решённой в работе Блинна. Из карты нормалей мы знаем возмущённую нормаль, но не знаем двойственный касательный базис. Определим неизвестные (ко)касательные как градиенты текстурных координат и : и , а сами текстурные координаты неявно определим как функции координат вершины :       где точка - это скалярное произведение. Градиенты постоянны для интерполированных значений внутри треугольника, потому введём разности , , , , а так же и . Искомые базисные векторы должны удовлетворять условиям:        Первые две строки следуют из определений, а последняя из условия что (ко)касательные перпендикулярны нормали. Последняя строка нужна потому что без неё задача недоопределена. Отсюда можно выразить в матричной форме:   и находятся аналогично.   Переходим к коду шейдера Полученный результат выглядит устрашающе потому что нужно обращать матрицу в каждом фрагменте! Однако, используя некоторые симметрии, код обращения можно свести к минимуму. Ниже приведён пример функции на GLSL для обращения матрицы 3х3. Похожий код на HLSL появлялся в книге, но с тех пор я его сильно оптимизировал. Смотрите как из веткорных произведений можно получить определитель и присоединённую матрицу: присоединённую mat3 inverse3x3( mat3 M )
{
    mat3 M_t = transpose( M ); 
    float det = dot( cross( M_t[0], M_t[1] ), M_t[2] ); 
    mat3 adjugate = mat3( cross( M_t[1], M_t[2] ), cross( M_t[2], M_t[0] ), cross( M_t[0], M_t[1] ) ); 
    return adjugate / det;
} mat3 inverse3x3( mat3 M )
{
    mat3 M_t = transpose( M ); 
    float det = dot( cross( M_t[0], M_t[1] ), M_t[2] ); 
    mat3 adjugate = mat3( cross( M_t[1], M_t[2] ), cross( M_t[2], M_t[0] ), cross( M_t[0], M_t[1] ) ); 
    return adjugate / det;
} Строки матрицы из предыдущей части можно подставить в код, раскрыть скобки, привести подобные, получив новое выражение для . Определитель превращается в , а присоединённую матрицу можно записать с помощью двух новых переменных и :       Внимательный читатель возможно догадался, что и это перпендикуляры к сторонам треугольника в плоскости треугольника. И конечно же они ковекторы, образующие хороший базис сопряжённого касательного пространства. Для упрощения дальнейшего изложения заметим следующее:   перпендикуляры ковекторы сопряжённого касательного пространства Последняя строка матрицы неважна, потому что умножается на 0.
Остальные строки матрицы содержат перпендикуляры ( и ), которые после транспонирования умножаются на численные производные текстурных координат.
Вместо нормали к грани ( ) можно взять интерполированную нормаль к вершине, что проще и даёт лучший визуальный результат.
Определитель (выражение ) можно отбросить, о чём ниже в разделе про инвариантность при масштабировании. Последняя строка матрицы неважна, потому что умножается на 0. Последняя строка матрицы неважна, потому что умножается на 0. Остальные строки матрицы содержат перпендикуляры ( и ), которые после транспонирования умножаются на численные производные текстурных координат. Остальные строки матрицы содержат перпендикуляры ( и ), которые после транспонирования умножаются на численные производные текстурных координат.   Вместо нормали к грани ( ) можно взять интерполированную нормаль к вершине, что проще и даёт лучший визуальный результат. Вместо нормали к грани ( ) можно взять интерполированную нормаль к вершине, что проще и даёт лучший визуальный результат.  Определитель (выражение ) можно отбросить, о чём ниже в разделе про инвариантность при масштабировании. Определитель (выражение ) можно отбросить, о чём ниже в разделе про инвариантность при масштабировании.  В итоге код получается простым и надёжным: mat3 cotangent_frame( vec3 N, vec3 p, vec2 uv )
{
    // Численные производные
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );
    
    // Решаем линейную систему
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
    
    // Собираем масштабно-инвариантный базис
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
} mat3 cotangent_frame( vec3 N, vec3 p, vec2 uv )
{
    // Численные производные
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );
    
    // Решаем линейную систему
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
    
    // Собираем масштабно-инвариантный базис
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
} Инвариантность при масштабировании В выведенном выше выражении оставался определитель . Из-за этого дуальные касательные и изменяются обратно пропорционально масштабу модели. Так получается потому что они градиенты. Если масштаб треугольника увеличивается, а всё остальное остаётся неизменным, то изменение текстурных координат на единицу изменения координаты вершин становится меньше. Из-за этого уменьшается и (аналогично) по отношению к . В итоге, уменьшается возмущение нормали при увеличении масштаба треугольника, как будто карта высот растянулась.       Хотя такое поведение абсолютно логично и корректно, оно мешает накладывать нормалмапы на геометрию различного масштаба. Для решения этой проблемы (как видно из кода), я отбрасываю определитель и нормирую и по длине большего из них. Этот хак сохраняет относительные длины и , и даже скошенный или растянутый базис сопряжённого касательного пространства обрабатывается корректно.     Бесперспективная оптимизация В качестве агрессивной оптимизации я попробовал положить и . Это значит что треугольник прямоугольный, и перпендикуляр к одному катету совпадает со вторым катетом. Во фрагментном шейдере это условие выполняется когда проекция на экран не вносит перспективных искажений. В [4] есть хороший рисунок с демонстрацией этого факта. Такая оптимизация экономит ещё два векторных произведения, но по-моему сильно вредит качеству если фактически перспективное искажение есть.   Собираем всё воедино Для полноты картины я покажу как с помощью сопряжённого касательного пространства возмутить интерполированную вершинную нормаль. Этим занимается функция perturb_normal, используя вектор из фрагмента в камеру вместо координаты вершины. Это нормально, потому что при вычислении разности положение камеры сокращается. perturb_normal vec3 perturb_normal( vec3 N, vec3 V, vec2 texcoord ) 
{ 
    // N - интерполированная нормаль,
    // V - интерполированный вектор из вершины в камеру
    vec3 map = texture2D( mapBump, texcoord ).xyz;
#ifdef WITH_NORMALMAP_UNSIGNED
    map = map * 255./127. - 128./127.; 
#endif 
#ifdef WITH_NORMALMAP_2CHANNEL 
    map.z = sqrt( 1. - dot( map.xy, map.xy ) ); 
#endif 
#ifdef WITH_NORMALMAP_GREEN_UP 
    map.y = -map.y; 
#endif
    mat3 TBN = cotangent_frame( N, -V, texcoord ); 
    return normalize( TBN * map ); 
} vec3 perturb_normal( vec3 N, vec3 V, vec2 texcoord ) 
{ 
    // N - интерполированная нормаль,
    // V - интерполированный вектор из вершины в камеру
    vec3 map = texture2D( mapBump, texcoord ).xyz;
#ifdef WITH_NORMALMAP_UNSIGNED
    map = map * 255./127. - 128./127.; 
#endif 
#ifdef WITH_NORMALMAP_2CHANNEL 
    map.z = sqrt( 1. - dot( map.xy, map.xy ) ); 
#endif 
#ifdef WITH_NORMALMAP_GREEN_UP 
    map.y = -map.y; 
#endif
    mat3 TBN = cotangent_frame( N, -V, texcoord ); 
    return normalize( TBN * map ); 
} varying vec3 g_vertexnormal; 
varying vec3 g_viewvector;// camera pos - vertex pos 
varying vec2 g_texcoord;   

void main() 
{
    vec3 N = normalize( g_vertexnormal );   
#ifdef WITH_NORMALMAP 
    N = perturb_normal( N, g_viewvector, g_texcoord ); 
#endif   
    // ... 
} varying vec3 g_vertexnormal; 
varying vec3 g_viewvector;// camera pos - vertex pos 
varying vec2 g_texcoord;   

void main() 
{
    vec3 N = normalize( g_vertexnormal );   
#ifdef WITH_NORMALMAP 
    N = perturb_normal( N, g_viewvector, g_texcoord ); 
#endif   
    // ... 
} Зелёная ось OpenGL и DirectX считают началом координат начало массива данных текстуры. Текстурная координата (0, 0) - это угол пикселя, на который указывает указатель на данные изображения. Большинство 3д-пакетов устроены иначе: они считают началом координат нижний левый угол uv-развёртки. Это означает что начало текстурных координат находится в углу первого пикселя последней строки изображения. Поиск по картинкам в Гугле показывает что нет никакого общепринятого соглашения о зелёном канале в картах нормалей. У некоторых зелёный канал указывает вверх, а у некоторых - вниз. Наши художники предпочитают направление вверх по двум причинам: во-первых, 3ds Max работает именно с таким форматом, а во-вторых, он выглядит естественнее, как при освещении зелёным светом сверху. Это облегчает восприятие карты нормалей невооружённым глазом. картинкам в Гугле Оглядываясь назад Исходная статья была написана на уровне демонстрации идеи. Хотя алгоритм был протестирован и работал, он был тяжеловат для того времени. Сегодня ситуация изменилась. Я использую этот алгоритм в реальных проектах и больше не парюсь с касательными в вершинных атрибутах. Мне больше не важно, правильно ли экспортируются касательные из Макса или Майи. Художники тоже не чувствуют потери какой-то части своего пайплайна, потому что всё довольно естественно: есть геометрия, есть текстурные координаты и карта нормалей, и оно просто работает. просто работает Нет никакого касательного базиса в нормалмаппинге. Касательный базис, содержащий нормаль, логически неверен. Под него маскируется двойственный ("кокасательный") базис, когда он ортогонален. А когда он становится неортогональным, он перестаёт работать. Используйте двойственный базис. Список литературы [1] James Blinn, “Simulation of wrinkled surfaces”, SIGGRAPH 1978 James Blinn, “Simulation of wrinkled surfaces”, SIGGRAPH 1978 James Blinn, “Simulation of wrinkled surfaces”, SIGGRAPH 1978 [2] Mark Peercy, John Airey, Brian Cabral, “Efficient Bump Mapping Hardware”, SIGGRAPH 1997 Mark Peercy, John Airey, Brian Cabral, “Efficient Bump Mapping Hardware”, SIGGRAPH 1997 Mark Peercy, John Airey, Brian Cabral, “Efficient Bump Mapping Hardware”, SIGGRAPH 1997 [3] Mark J Kilgard, “A Practical and Robust Bump-mapping Technique for Today’s GPUs”, GDC 2000 Mark J Kilgard, “A Practical and Robust Bump-mapping Technique for Today’s GPUs”, GDC 2000 Mark J Kilgard, “A Practical and Robust Bump-mapping Technique for Today’s GPUs”, GDC 2000 [4] Christian Schüler, “Normal Mapping without Precomputed Tangents”, ShaderX 5, Chapter 2.6, pp. 131 – 140 ShaderX 5 [5] Colin Barré-Brisebois and Stephen Hill, “Blending in Detail” Colin Barré-Brisebois and Stephen Hill, “Blending in Detail” Colin Barré-Brisebois and Stephen Hill, “Blending in Detail” ]]></text>
</doc>
