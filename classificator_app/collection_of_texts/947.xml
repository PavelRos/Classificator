<?xml version="1.0" ?>
<doc>
	<label auto="true" type="str" verify="true"><![CDATA[Other]]></label>
	<author auto="true" type="list" verify="true">
		<item type="str"><![CDATA[Basil_12]]></item>
	</author>
	<date auto="true" type="str" verify="true"><![CDATA[2022-10-03, 14:43]]></date>
	<link auto="true" type="str" verify="true"><![CDATA[https://habr.com/ru/post/691232/]]></link>
	<title auto="true" type="str" verify="true"><![CDATA[Диагностика портов DGS-1210]]></title>
	<categories auto="true" type="list" verify="true">
		<item type="str"><![CDATA[Python]]></item>
		<item type="str"><![CDATA[Интерфейсы]]></item>
		<item type="str"><![CDATA[Сетевое оборудование]]></item>
	</categories>
	<key_words auto="true" type="list" verify="true">
		<item type="str"><![CDATA[osi layers]]></item>
		<item type="str"><![CDATA[python3]]></item>
		<item type="str"><![CDATA[tkinter]]></item>
		<item type="str"><![CDATA[switch]]></item>
		<item type="str"><![CDATA[коммутатор]]></item>
	</key_words>
	<text auto="true" type="str" verify="true"><![CDATA[В моей работе часто возникает необходимость быстро продиагностировать физические порты на коммутаторах. Способ который я предлагаю ускоряет процесс диагностики и делает его более наглядным по сравнению с прописыванием команд на коммутаторе. Тестирование производится на Linux, так же требуются:
minicom (putty тоже подойдет, утилита играет роль отображения информации в консоль);
модули python3: serial и tkinter;
сведенный к дефолтным настройкам коммутатор Dlink DGS-1210-28/ME;
в моем случая "модеризированный патч-корд" из 4 штук в одной шине (картинка в конце текста), но можно и обычный патч-корд.
Для удобства была написана программа gui на python 3. Она разбита на два модуля, один из которых реализует подключение по COM порту, второй - графический интерфейс.
Подробный алгоритм диагностики портов:
включаем коммутатор (ждем когда загрузится), подключаем его к компьютеру через конвертор USB to RS-232;
Чтобы узнать какие USB устройства у вас подключены можно воспользоваться командой:
ls /dev/ttyUSB*;
(номер(строка) идущая после "USB" указать при запуске скрипта main.py)
запускаем программу командой:
python3 main.py 0
0 - это часть имени USB to RS-232, который в программе представлен как:
port = "/dev/ttyUSB"+str(sys.argv[1]);
у вас эта часть может отличаться.
запускаем параллельно в другом терминале minicom командой:
minicom -D /dev/ttyUSB0 -b 9600;
после запуска нажать несколько раз Enter, чтобы пройти строки авторизации;
коммутируем порты витой пары или SFP. Нажимаем кнопки графического интерфейса, что в свою очередь генерирует данные диагностики кабеля соответствующего порта.
Диагностику можно проводить как на одном так и на множестве коммутаторов:
Четыре совмещенных патч-корда склеил для удобства, в основном пользуюсь одним из них, переключая и проверяя сразу 4 порта (8 - если на одном коммутаторе).
SFP так же можно диагностировать, для этих портов прописанное отдельное условие для команды коммутатора show ports <номер порта(25-28)>.
Программу планирую дорабатывать:
универсальность для DGS 3120, 3100, 1210;
индикация о состоянии кабелей;
опция генерации циклического прохода по всем портам и записи результатов диагностики в файл. В моей работе часто возникает необходимость быстро продиагностировать физические порты на коммутаторах. Способ который я предлагаю ускоряет процесс диагностики и делает его более наглядным по сравнению с прописыванием команд на коммутаторе. Тестирование производится на Linux, так же требуются: minicom (putty тоже подойдет, утилита играет роль отображения информации в консоль);
модули python3: serial и tkinter;
сведенный к дефолтным настройкам коммутатор Dlink DGS-1210-28/ME;
в моем случая "модеризированный патч-корд" из 4 штук в одной шине (картинка в конце текста), но можно и обычный патч-корд. minicom (putty тоже подойдет, утилита играет роль отображения информации в консоль); minicom (putty тоже подойдет, утилита играет роль отображения информации в консоль); minicom модули python3: serial и tkinter; модули python3: serial и tkinter; serial tkinter сведенный к дефолтным настройкам коммутатор Dlink DGS-1210-28/ME; сведенный к дефолтным настройкам коммутатор Dlink DGS-1210-28/ME; в моем случая "модеризированный патч-корд" из 4 штук в одной шине (картинка в конце текста), но можно и обычный патч-корд. в моем случая "модеризированный патч-корд" из 4 штук в одной шине (картинка в конце текста), но можно и обычный патч-корд. Для удобства была написана программа gui на python 3. Она разбита на два модуля, один из которых реализует подключение по COM порту, второй - графический интерфейс. программа Подробный алгоритм диагностики портов: включаем коммутатор (ждем когда загрузится), подключаем его к компьютеру через конвертор USB to RS-232;
Чтобы узнать какие USB устройства у вас подключены можно воспользоваться командой:
ls /dev/ttyUSB*;
(номер(строка) идущая после "USB" указать при запуске скрипта main.py)
запускаем программу командой:
python3 main.py 0
0 - это часть имени USB to RS-232, который в программе представлен как:
port = "/dev/ttyUSB"+str(sys.argv[1]);
у вас эта часть может отличаться.
запускаем параллельно в другом терминале minicom командой:
minicom -D /dev/ttyUSB0 -b 9600;
после запуска нажать несколько раз Enter, чтобы пройти строки авторизации;
коммутируем порты витой пары или SFP. Нажимаем кнопки графического интерфейса, что в свою очередь генерирует данные диагностики кабеля соответствующего порта. включаем коммутатор (ждем когда загрузится), подключаем его к компьютеру через конвертор USB to RS-232; включаем коммутатор (ждем когда загрузится), подключаем его к компьютеру через конвертор USB to RS-232; Чтобы узнать какие USB устройства у вас подключены можно воспользоваться командой:
ls /dev/ttyUSB*;
(номер(строка) идущая после "USB" указать при запуске скрипта main.py) Чтобы узнать какие USB устройства у вас подключены можно воспользоваться командой:
ls /dev/ttyUSB*;
(номер(строка) идущая после "USB" указать при запуске скрипта main.py)  ls /dev/ttyUSB*  запускаем программу командой:
python3 main.py 0
0 - это часть имени USB to RS-232, который в программе представлен как:
port = "/dev/ttyUSB"+str(sys.argv[1]);
у вас эта часть может отличаться. запускаем программу командой:
python3 main.py 0
0 - это часть имени USB to RS-232, который в программе представлен как:
port = "/dev/ttyUSB"+str(sys.argv[1]);
у вас эта часть может отличаться.  python3 main.py 0
0   port = "/dev/ttyUSB"+str(sys.argv[1])  запускаем параллельно в другом терминале minicom командой:
minicom -D /dev/ttyUSB0 -b 9600;
после запуска нажать несколько раз Enter, чтобы пройти строки авторизации; запускаем параллельно в другом терминале minicom командой:
minicom -D /dev/ttyUSB0 -b 9600;
после запуска нажать несколько раз Enter, чтобы пройти строки авторизации;  minicom -D /dev/ttyUSB0 -b 9600  коммутируем порты витой пары или SFP. Нажимаем кнопки графического интерфейса, что в свою очередь генерирует данные диагностики кабеля соответствующего порта. коммутируем порты витой пары или SFP. Нажимаем кнопки графического интерфейса, что в свою очередь генерирует данные диагностики кабеля соответствующего порта.   Диагностику можно проводить как на одном так и на множестве коммутаторов:     Четыре совмещенных патч-корда склеил для удобства, в основном пользуюсь одним из них, переключая и проверяя сразу 4 порта (8 - если на одном коммутаторе).
SFP так же можно диагностировать, для этих портов прописанное отдельное условие для команды коммутатора show ports <номер порта(25-28)>.  show ports <номер порта(25-28)>.   Программу планирую дорабатывать: универсальность для DGS 3120, 3100, 1210;
индикация о состоянии кабелей;
опция генерации циклического прохода по всем портам и записи результатов диагностики в файл. универсальность для DGS 3120, 3100, 1210; универсальность для DGS 3120, 3100, 1210; индикация о состоянии кабелей; индикация о состоянии кабелей; опция генерации циклического прохода по всем портам и записи результатов диагностики в файл. опция генерации циклического прохода по всем портам и записи результатов диагностики в файл. ]]></text>
</doc>
