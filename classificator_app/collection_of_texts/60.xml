<?xml version="1.0" ?>
<doc>
	<label auto="true" type="str" verify="true"><![CDATA[Develop]]></label>
	<author auto="true" type="list" verify="true">
		<item type="str"><![CDATA[Konstantin-2]]></item>
	</author>
	<date auto="true" type="str" verify="true"><![CDATA[2022-12-15, 16:12]]></date>
	<link auto="true" type="str" verify="true"><![CDATA[https://habr.com/ru/post/705758/]]></link>
	<title auto="true" type="str" verify="true"><![CDATA[Управление в децентрализованных сетях]]></title>
	<categories auto="true" type="list" verify="true">
		<item type="str"><![CDATA[Децентрализованные сети]]></item>
		<item type="str"><![CDATA[IT-инфраструктура]]></item>
		<item type="str"><![CDATA[*nix]]></item>
		<item type="str"><![CDATA[Алгоритмы]]></item>
	</categories>
	<key_words auto="true" type="list" verify="true">
		<item type="str"><![CDATA[децентрализованные сети]]></item>
		<item type="str"><![CDATA[Debian]]></item>
		<item type="str"><![CDATA[ubuntu]]></item>
		<item type="str"><![CDATA[администрирование linux-систем]]></item>
	</key_words>
	<text auto="true" type="str" verify="true"><![CDATA[В статье рассматривается способ управления (администрирования) компьютерами в небольшой организации.
Под сетями в данной статье понимаются одна или несколько локальных компьютерных сетей, не связанных между собой, каждая из которых содержит один или несколько компьютеров. Под сетью из одного компьютера понимается отдельно стоящий компьютер, не подключенный ни к какому другому. Термин «децентрализованная» в данной статье означает, что среди компьютеров нет ни одного главного, с которого бы осуществлялось управление другими компьютерами, все имеют равный статус. Под управлением понимаются типичные задачи, решаемые администратором: установка и настройка программ, регулярная проверка результатов работы антивируса, свободного места и состояния S.M.A.R.T. жестких дисков, добавление и удаление учетных записей пользователей и т.п. В качестве примера можно представить общеобразовательную школу, в которой имеется несколько компьютерных классов. Компьютеры в каждом классе соединены в сеть, но классы в силу ряда причин не соединены между собой. Для лаборанта, отвечающего за работу классов, не выделено отдельного компьютера. Задачи администрирования ему приходится решать либо непосредственно на требующем внимания компьютере после уроков, либо с помощью удаленного доступа к нужному компьютеру по сети, если во время занятий в классе найдется другой свободный компьютер. Типичная работа лаборанта требует многократного выполнения одних и тех же действий на каждом компьютере. Такой подход нерационален с точки зрения затрат времени. Работа может быть автоматизирована различными скриптами и программами. Одна из таких программ описана в этой статье.
Для администрирования компьютеров в децентрализованных сетях разработана программа distadm (Distributed Administrator, https://github.com/konstantin-2/distadm). Она позволяет, используя любой компьютер, где она установлена, управлять другими, где она так же должна быть установлена. Управлять другими компьютерами можно, даже если они находятся в другой сети и выключены в данный момент. Для этого программа накапливает управляющие команды и при первой возможности передает их другим компьютерам, которые, в свою очередь, распространяют команды дальше. Передача команд по сети происходит, как только два компьютера обнаруживают друг друга. Для передачи команд между несвязанными сетью компьютерами необходимо создавать специальные файлы и переносить их с помощью флешек или оптических дисков. Попав хотя бы на один из компьютеров новой сети управляющие команды распространяются по ней далее автоматически. Получается бот-сеть, но вполне легальная и полезная. С момента ее разработки и последних внесенных правок прошло более полугода, что показывает ее стабильность. Представляю свою программу публике в надежде, что она или заложенные в ней решения кому-то так же будут полезны.
Пример децентрализованных сетей
Программа работает на компьютерах с операционными системами Debian и Ubuntu.  В учебных классах компьютеры объединены в сеть коммутаторами (свитчами). Сеть построена на базе протокола IPv6 поскольку это современный протокол, не требующий ни каких настроек в режиме link-local. В текущей версии компьютеры не могут соединяться, если они разделены маршрутизатором, такой потребности нет, хотя было бы интересно добавить всякие DHT, PEX и т.п. У программы имеется графический интерфейс, а также возможность работы в командной строке. Компьютеры с установленной программой distadm называются узлами и объединяются в группу. При необходимости компьютер можно включить в состав нескольких групп одновременно. Далее приведены примеры использования программы, облегчающие жизнь администратору.
Управление учетными записями
Для каждого школьника, у которого предусмотрены занятия по информатике, создается собственная учетная запись (разумеется, с дисковыми квотами). До использования программы distadm добавление учетных записей происходило следующим образом. Лаборант на каждом из компьютеров по очереди создавал учетную запись, вводил имя пользователя и пароль, иногда с опечатками. Это все занимало много времени. Удаление учетных записей происходило аналогично. Для автоматизации этой процедуры в программу distadm добавлена вкладка «Пользователи».
Вкладка «Пользователи»
Вкладка «Пользователи» позволяет добавлять и удалять учетные записи пользователей на каждом узле, введя команду только на одном из них. Для добавления необходимо нажать кнопку «+» в нижней части окна, в новом окне ввести логин и пароль, затем нажать «ОК». Для удаления учетной записи необходимо выделить ее и нажать кнопку «x» внизу.
Создание новой учетной записи
Для распространения одинакового пароля между узлами передается строка из файла /etc/shadow. В целях безопасности она передается в зашифрованном виде. Далее distadm на каждом компьютере запускает программы adduser и deluser соответственно. Преимуществом программы adduser перед useradd является начальное заполнение домашнего каталога пользователя файлами из /etc/skel при добавлении учетной записи, а также начальная инициализация с помощью скрипта adduser.local и финальная деинициализация с помощью скрипта deluser.local при удалении учетной записи (man adduser). В эти скрипты можно поместить, например, настройку дисковых квот. Оконные менеджеры, например LightDM, умеют обнаруживать новые учетные записи и добавляют новое имя пользователя в свой список на экране практически сразу по всему учебному классу. На выключенных компьютерах новая учетная запись добавляется, разумеется, только после включения компьютера.
Распространение файлов
Иногда возникает задача разместить на компьютерах файлы. Это могут быть дистрибутивы программ, обучающие видеоролики, другие учебные и вспомогательные материалы. В серьезных организациях такие файлы выкладываются на файловый сервер, откуда пользователи получают к ним доступ. При отсутствии файлового сервера для автоматизации процесса распространения файлов в программу distadm добавлена вкладка «Файлы».
Вкладка «Файлы»
Вкладка «Файлы» позволяет распространять файлы между узлами. По умолчанию они хранятся в каталоге /var/local/distadm/files, куда имеет доступ только администратор (пользователь root), и откуда файлы можно переместить в любой другой каталог (в консоли командой mv, см. вкладку «Консоль»). При распространении больших файлов (несколько гигабайт) между узлами с помощью флешек небольшого объема программа автоматически разбивает такие файлы на части, стараясь максимально использовать на флешке свободное место. Для добавления файла нужно нажать кнопку «+» в нижней части окна, а для удаления выделить его в списке и нажать кнопку «x» внизу.
Согласно логике программы добавление файла — это команда, которая должна быть выполнена на каждом компьютере. Отмена команд не предусмотрена. Удаление файла — это следующая команда. Таким образом, если добавить файл и сразу его удалить, он пропадет из списка, но останется на диске до тех пор, пока не скопируется на каждый компьютер в группе. Только после того, как программа узнает, что файл скопирован на каждый компьютер, она удалит это файл с диска за ненадобностью.
Выполнение команд
Обслуживание компьютеров подразумевает выполнение на нем различных команд. Например, командой df можно проверить наличие свободного места на дисках, smartctl показывает плохо работающие диски. Новые программы устанавливаются с помощью запуска инсталлятора, в т.ч. командой apt install. До написания программы distadm лаборант самостоятельно запускал программы по очереди на каждом из компьютеров. Для автоматизации этой работы в программу distadm добавлена вкладка «Консоль».
Вкладка «Консоль»
Вкладка «Консоль» позволяет задавать команды для интерпретатора sh для выполнения на каждом из узлов. Использование sh в отличие от простого системного вызова exec позволяет использовать перенаправления ввода-вывода символами «|», «>», «<» и т.д. Результат выполнения (вывод программы) отображается во вкладке. Для выполнения сложных конструкций (с циклами, ветвлениями и т.п.) рекомендуется записать их в скрипт-файл, протестировать на отдельном компьютере, после чего распространить этот файл между узлами с помощью вкладки «Файлы» и запустить из вкладки «Консоль». Команды выполняются в каталоге /var/local/distadm/files, в котором хранятся распространяемые файлы. Таким образом, чтобы установить новую программу в простейшем случае достаточно распространить deb-файл с помощью вкладки «Файлы», а потом во вкладке «Консоль» ввести команду типа «apt install ./MY_NEW_PROGRAM.deb». Здесь же вводятся команды переноса файлов с учебными материалами из текущего каталога, недоступного пользователям, в другой доступный, например «mv лабораторная_№1.odp /home/common/Desktop».
Программа distadm отслеживает порядок выполнения команд (точнее, частичный порядок, см. «частично упорядоченное множество»). Поэтому если, например, на одном компьютере загрузить файл для распространения, а затем на другом, убедившись, что файл дошел, переместить его в другую папку, то на всех других компьютерах в группе команда перемещения файла будет выполняться только после команды добавления файла. Частичность порядка означает, что порядок выполнения независимых команд может быть произвольным. Например, если на одном компьютере ввести команду «выключить монитор», а на другом, не дожидаясь выключения монитора ввести команду «включить музыку», то эти две команды будут независимыми, и другие компьютеры в группе могут повести себя по-разному. На некоторых сначала выключится монитор, а затем заиграет музыка, а на других сначала включится музыка, тут как повезет.
Отслеживание состояния компьютеров
Если Вам говорят, что под Линукс не бывает вирусов, не верьте. Школьники любят приносить на уроки всякую дрянь. Поэтому одна из задач лаборанта заключается в том, чтобы в дополнение к проактивной защите периодически запускать антивирус. В моем случае школа использует DrWeb. Антивирус в комплекте с программой distadm не поставляется. Кроме того, интерес представляет состояние S.M.A.R.T. дисков компьютеров. Эта информация не представляет какой-либо важности, чтобы скрывать ее от пользователей. Поэтому при запуске программы distadm с ключом «-i» отображается информационное табло.
Информационное табло
Колонка «Онлайн» означает последнее известное время работы программы. Если известно, что компьютер работает, но дата не обновляется, значит, в работе программы произошел сбой. Но как я уже говорил, за последние полгода все работает без сбоев. Информация о работе может задерживаться, если компьютер не доступен по сети, а свежие данные от него на флешке еще не принесли. В колонке «Базы антивируса» отображается дата базы антивируса, позволяет обнаруживать ситуации, если по каким-то причинам антивирус перестает обновляться. В колонке «Проверка» отображается дата запуска последней проверки, она позволяет обнаруживать ситуации, когда по каким-то причинам проверка перестает производиться. В колонке «Результат» должно быть пусто. Наличие надписи «Внимание» говорит о том, что на компьютере нашелся вирус. В колонке «S.M.A.R.T.» так же должно быть пусто. Надпись «Внимание» говорит о том, что пора менять жесткий диск. Получение информации от антивируса осуществляется с помощью простых скриптов, которые каждый может переделать под свою ситуацию.
Перенос информации на флешках
Когда администратор вводит в программу новую команду, все компьютеры в классе узнают о ней по сети. Но компьютеры в другом классе, не подключенном по сети, о новой команде не знают. Ее необходимо перенести в другой класс, например, на флешке.
Панель с кнопками
Для обмена информацией между изолированными сегментами в программе предусмотрены четыре кнопки справа на панели. Кнопка «Записать пакет» с зеленой стрелочной записывает информацию в файл, который можно записать на флешку, перенести в другой класс и прочитать на любом из компьютеров с помощью кнопки «Прочитать пакет» с красной стрелочной. Красный цвет означает некоторую опасность, поскольку после прочтения программа начинает выполнять полученные команды, которые не всегда могут успешно выполниться, если администратор их составил не аккуратно. Далее информация распространится между компьютерами по местной локальной сети. Информацию между изолированными сегментами нужно переносить в обе стороны, даже если все управляющие команды вводятся только в одном сегменте. Другой сегмент должен отчитаться о том, что команды получены и выполнены. Поэтому запись и чтение часто выполняются вместе. При нажатии на кнопку «Прочитать-записать пакет» с двухсторонней зелено-красной стрелкой выполняются чтение входящей и запись подготовленной информации, нет необходимости открывать один файл два раза. Программа запоминает путь к файлу, поэтому в следующий раз, если флешка подключилась по тому же пути, что и в предыдущий, достаточно нажать кнопку «Повторить чтение-запись» с красно-зеленой молнией и не указывать путь к файлу.
Установка программы
Исходный код программы и deb-файлы доступны по ссылке https://github.com/konstantin-2/distadm. При установке программа помещается в каталог /usr/local/sbin. Для запуска необходимы права пользователя root, поскольку задачи управления компьютером требуют таких прав от пользователя. Для установки из deb-файла необходимо выполнить команду:
sudo apt install ./distadm.deb
Некоторые компьютеры не имеют графического интерфейса. Устанавливать на них библиотеки GTK для компиляции и работы программы не нужно. Для них собран отдельный пакет, поддерживающий работу только в консоли. Для его установки необходимо выполнить команду:
sudo apt install ./distadm-console.deb
Для программы установки из исходного кода необходимо выполнить команды:
make clean
sudo make install -j
Для установки программы из исходного кода на компьютере, где нет графического интерфейса, необходимо выполнить команды:
make clean
sudo NO_X=y make install -j
Чтобы создать собственный deb-файл, необходимо выполнить команды:
sudo make clean
sudo make distadm.deb
Чтобы создать собственный deb-файл для компьютеров, где нет графического интерфейса, необходимо выполнить команды:
sudo make clean
sudo make distadm-console.deb
Запуск программы
При первом запуске программы выдается сообщение о том, что узел не инициализирован (программа не настроена), предлагается создать новую группу компьютеров, которыми будет осуществляться управление, либо присоединиться к существующей группе.
Начальное окно неинициализированного узла
После нажатия кнопки «Новая группа» узел инициализируется и отобразится основное окно программы. В верхней части окна находится панель инструментов с кнопками, которые будут описаны далее. Ниже находятся вкладки.
Вкладка «Узлы» с одним узлом
На вкладке «Узлы» содержится информация об узлах в составе группы. Сразу после создания новой группы во вкладке содержится только одна запись — текущий компьютер. По мере роста группы количество записей увеличивается. Например, если добавить к группе еще два компьютера, один в той же сети и один отдельно стоящий, будет три узла. Добавление компьютеров описано ниже.
Вкладка «Узлы» с тремя узлами
Колонка «№» справочная и не имеет отношения к нумерации узлов в программе. В колонке «UUID» содержится UUID узла, который остается неизменным даже если изменить hostname на этом компьютере. Далее идет колонка, содержащая hostname этого узла. В колонке «Онлайн» содержится последняя известная дата работы программы на этом узле. Если компьютер запущен, а дата не обновляется, значит в работе программы distadm произошел сбой. Далее идут колонки с числами в заголовках, это «матрица осведомленности», которая описана ниже и носит справочно-отладочную информацию. В последней колонке отображается счетчик сетевых пакетов узла, который планируется к использованию для защиты от спуфинга, когда нарушитель записывает сетевой трафик, а затем воспроизводит его, пытаясь повлиять на работу программы. Вкладка «Узлы» носит информативный характер, позволяет разобраться в работе программы, изучать, как именно распространяются сообщения между узлами. В нижней части вкладки находится кнопка удаления выделенного узла из группы. При нажатии на нее отображается всплывающее окно:
Подтверждение удаления узла
При выборе варианта «Да» создается команда на удаление узла из группы. Когда эта команда попадет на удаляемый компьютер, он помечает себя как удаляемый и создает прощальное сообщение, получив которое, другие узлы вычеркивают его из своих списков.
Вариант «Принудительно» создает команду удалить запись об узле, не дожидаясь от него прощального сообщения. Использование принудительного удаления не рекомендуется, поскольку при этом возникает опасность того, что команды удаляемого узла будут выполнены не на всех других узлах, возникнет «неконсистентность» данных. Однако этот вариант является единственно возможным для удаления поврежденного узла, который не способен создать прощальное сообщение. Перед выбором этого варианта рекомендуется проверить, что все команды удаляемого узла выполнены на каждом оставшемся узле.
Вкладка «Очередь»
Вкладка «Очередь» показывает, сколько на текущем узле имеется сообщений (команд), которые необходимо передать другим узлам. Большое значение у узла указывает на необходимость обратить на него внимание, установить причину, по которой команды до него не доходят или не возвращаются ответы о том, что команды получены. Распространение информации между узлами должно происходить в обе стороны. Для узлов в одной компьютерной сети очередей вообще не должно быть, за исключением случаев, когда один из компьютеров выключен.
Вкладка «Команды»
Вкладка «Команды» показывает команды, хранящиеся на текущем узле, которые предназначены для распространения на другие узлы. Информация носит справочный характер и позволяет разобраться в особенностях работы программы.
Вкладка «Локально»
Вкладка «Локально» так же носит справочный характер, отображает идентификаторы группы, узла, его статус. Узел может иметь следующие статусы:
uninitialized
узел присоединился к группе с помощью онлайн-приглашения и ожидает подключения к другим узлам по сети;
partially-initialized
узел присоединился к группе с помощью оффлайн-приглашения и ожидает файла-пакета;
work
узел работает в штатном режиме. Основной режим работы;
inviter
узел является оффлайн-приглашающим и потребляет дополнительные ресурсы (смотри команды write-offline-invite, finalize-invite);
deleting
узел удален (смотри команду delnode). Он не может создавать и получать новые команды;
deleted
то же, что deleting, но при попытке запуска программа сразу завершается.
Добавление новых узлов
Добавление новых узлов в группу можно осуществлять в двух режимах: онлайн и оффлайн. Онлайн означает, что все данные для инициализации узла будут передаваться по сети, оффлайн — что их придется переносить с помощью файлов.
Для добавления в группу новых узлов в онлайн режиме необходимо создать онлайн-приглашение. Оно создается с помощью второй кнопки на панели инструментов, на которой нарисован провод и вилка. Созданный файл имеет небольшой размер, содержит только идентификатор группы и ключ симметричного шифрования. Далее необходимо на новом узле запустить программу distadm. Она отобразит сообщение о том, что узел не инициализирован, и предложит варианты создать новую группу или присоединиться к существующей. Необходимо выбрать второй вариант и указать на файл-приглашение. Программа установит статус нового узла как «uninitialized» и начнет искать в сети другие узлы из этой группы. Как только соединение с ними установится, программа запросит все необходимые данные, инициализируется и поменяет статус узла на «work».
Для добавления новых узлов в оффлайн режиме необходимо создать оффлайн-приглашение. Оно создается с помощью третьей кнопки на панели инструментов, на которой нарисован оптический диск и зеленый символ «плюс». Созданный файл может иметь большой размер поскольку содержит всю информацию, необходимую для нового узла, в том числе все загруженные файлы. Далее необходимо на новом узле запустить программу distadm, выбрать вариант «присоединиться к существующей группе» и указать файл-приглашение. Программа считает все необходимые данные, частично инициализируется, установит свой статус на «partially initialized» и допишет информацию о себе в файл-приглашение. Далее это приглашение необходимо открыть на инициализирующем (приглашающем) узле с помощью четвертой кнопки на панели инструментов, на которой нарисован оптический диск и флажок с шахматной раскраской. Программа прочитает из приглашения идентификатор нового узла и создаст для него команду-приветствие. Далее необходимо создать файл-пакет, перенести его на новый узел и там открыть в программе с помощью кнопки «прочитать пакет». Программа, обнаружив приветствие, поймет, что инициализация прошла успешно, и поменяет свой статус на «work».
С помощью одного приглашения можно последовательно инициализировать несколько узлов. Не следует допускать утечки файлов-приглашений, поскольку в этом случае злоумышленник, завладев ключом симметричного шифрования, сможет присоединить к группе свой компьютер и создавать свои управляющие команды. Дополнительно файл-приглашение защищается при его создании паролем.
Статус узла как оффлайн-приглашающего означает потребление им дополнительных ресурсов, он вынужден накапливать все поступающие команды и не может их удалять. В некоторых случаях может возникнуть потребность убрать у узла статус оффлайн-приглашающего, например, если файл оффлайн-инициализации был утерян. Для этого используется пятая кнопка на панели инструментов, на которой нарисован оптический диск и красный перечеркнутый круг. Она позволяет поменять статус узла на «work».
Матрица осведомленности
Далее идет техническое описание некоторых аспектов работы программы. Каждый узел может создавать сообщения, содержащие различную информацию или управляющие команды. Уникальным идентификатором сообщения является UUID узла автора и номер, последовательно присваиваемый при создании новых команд. На каждом узле ведется своя нумерация. Для определения того, кому и какие новые сообщения необходимо передать, используется «матрица осведомленности». Также она используется для того, чтобы избежать бесконечного накопления команд. Если узел знает, что некоторая команда выполнена всеми узлами в группе, то ее больше нет смысла хранить и она будет удалена, освободив место. Посмотреть на «матрицу осведомленности» можно на вкладке «Узлы» программы. Строка матрицы описывает то, какие команды знает соответствующий узел по мнению текущего узла. Столбцы соответствуют узлам, про чьи сообщения идет речь.
Например, если в 1 строке во 2 столбце находится число 3, это означает, что, по мнению текущего узла, 1 узел знает все команды от 2 узла до его 3-й команды не включительно (так было проще при написании программы), т.е. 3 — это номер следующей команды, которую может создать или уже создал 2-й узел.
Когда узел присоединяется к другому по сети или записывает файл-пакет, он сообщает свою матрицу осведомленности. Другой узел, получив матрицу, обновляет свою, записывая в каждую ячейку число, максимум между старым значением и соответствующим значением из прочитанной матрицы. Обмениваясь такими матрицами осведомленности узлы обновляют свои данные о том, какие узлы какие команды знают.
Если в процессе общения двух узлов по сети, анализируя матрицы, один узел видит, что другой узел знает новые команды, которые не знает первый узел, он запрашивает их. Если позже к первому узлу по сети подключится третий, то, прочитав матрицу, он узнает о существовании новых команд и запросит их. Таким образом сообщения передаются по сети.
Когда узел формирует файл-пакет для оффлайн общения, он записывает в него свою матрицу и все сообщения, которые, исходя из матрицы, неизвестны хотя бы одному другому узлу. Каждое сообщение будет передаваться до тех пор, пока узел не обновит свою матрицу и не узнает, что это сообщение известно всем узлам в группе. Таким образом файлы-пакеты позволяют передавать информацию между любыми узлами, а случайная утрата файлов-пакетов не представляет угрозы.
После того как команда, содержащаяся в сообщении, выполнена узлом и ему известно, что это сообщение известно всем другим узлам, сообщение удаляется за ненадобностью.
Пример. Пусть есть два узла A и B, которые пока не создали ни одного сообщения. Матрицы осведомленности на них будут нулевыми.
Пусть узел A создал команду «cmd», которую вместе со своим идентификатором можно записать так {A, 0, «cmd»}, где A — узел автор команды, 0 — последовательно присваиваемый номер на этом узле. После этого матрицы осведомленности и хранящиеся команды будут следующими:
Далее пусть узел B получает от A его матрицу и обновляет свою:
Узел B, сравнивая у своей матрицы вторую строку (свою) с первой (узла A), видит, что узел A знает команду {A, 0}, не известную ему. Он запрашивает эту команду и обновляет матрицу.
Узел «B» выполнив полученную команду, проанализировав первый столбец своей матрицы, увидит, что команда № 0 от узла «A» известна всем узлам и больше хранить ее нет смысла, значит ее можно удалить, что он и сделает.
Когда в следующий раз узел «A» запросит у «B» матрицу и объединит со своей получится следующее:
Аналогичным образом узел «А», проанализировав первый столбец, увидит ненужность команды № 0 от узла «A» и тоже удалит ее.
Вектор выполненных команд. Некоторые команды требуют последовательного выполнения, то есть множество команд является частично упорядоченным. Например, если на одном узле дать команду на создание учетной записи пользователя, а затем на втором узле дать команду на ее удаление, и, если команда на удаление придет на третий узел раньше, чем команда на создание, и если не соблюдать последовательность их выполнения, может произойти казус. Чтобы соблюсти последовательность, на каждом узле имеется вектор, описывающий номера выполненных команд (вектор выполненных команд). Это позволяет частично упорядочивать команды. Значение элемента вектора указывает, что все команды от соответствующего узла до этого значения (не включительно) выполнены. При создании новой команды к ней команде добавляется «вектор минимальных требований», равный вектору выполненных команд в текущий момент времени. Он указывает, что не следует выполнять новую команду до тех пор, пока не будут выполнены предыдущие в соответствии с этим вектором.
На вкладке «Узлы» в программе вектор выполненных команд совмещен со строкой матрицы осведомленности этого узла. Числа разделены символом «/». Первое число — элемент вектора выполненных команд, второе — элемент матрицы осведомленности. В общем случае эти числа должны быть равными, потому что каждая известная команда должна быть выполнена.
Можно пояснить сказанное на следующем примере. Пусть есть три узла, A, B, C с нулевыми матрицами и нулевыми векторами выполненных команд.
На узле A создается команда «добавить новую учетную запись» (NU). К ней добавляется вектор минимальных требований, равный вектору выполненных команд. В связи с появлением новой команды также обновляется матрица осведомленности.
Здесь в команде, заключенной в фигурные скобки, первый элемент «A» — идентификатор узла автора команды. Второй элемент «0» — номер команды. Третий элемент, строка «NU» — сама команда. Четвертый элемент, вектор «(0, 0, 0)» — вектор минимальных требований. После того, как на узле A эта команда выполнена, первый элемент вектора выполненных команд увеличивается на единицу:
Пусть узел B получает матрицу от узла A и обновляет свою:
Узел B, сравнивая вторую (свою) строку с первой (узла A), узнает о существовании команды {A, 0, …} и запрашивает ее, после чего обновляет свою матрицу осведомленности:
Узел B сравнивает свой вектор выполненных команд с вектором минимальных требований в полученной команде. Поскольку каждое число в векторе минимальных требований не превышает аналогичное в векторе выполненных команд, т.е. минимальные требования выполнены, узел выполняет полученную команду и обновляет вектор выполненных команд:
Далее пусть узел B создает новую команду «Удалить учетную запись» (DU), также обновляя матрицу осведомленности:
Выполнив свою команду, узел B обновляет вектор выполненных команд:
Узел C получает матрицу узла B и обновляет свою:
Сравнив вторую и третью строки, узел C узнает про новые команды и запрашивает их:
Сравнивая вектор минимальных требований в командах со своим вектором выполненных команд, узел C понимает, что может выполнить только команду {A, 0, …}, но не {B, 0, …}, поскольку для второй команды минимальные требования не выполнены. Выполнив первую команду и обновив вектор выполненных команд, узел C обнаруживает, что теперь может выполнить вторую команду:
Выполнив команду {B, 0, …} узел C обновляет вектор выполненных команд:
Вот как-то так программа выполняет частично упорядоченные команды.
Безопасность
Поскольку программа предназначена для решения задач администрирования, она требует для запуска права администратора.
Чтобы избежать перехвата и подмены передаваемой информации, она шифруется симметричным алгоритмом шифрования. Сеансовый ключ состоит из случайного числа, передаваемого в начале сеанса, и общего ключа группы. Ключ группы хранится на каждом узле и, по сути, представляет собой идентификатор группы, информация от других групп расшифруется с ошибкой и будет отброшена. Если злоумышленник получит доступ к ключу, он сможет создавать свои команды, т.е. получит доступ к управлению всей группой.
Поскольку файл-приглашение содержит ключ шифрования, то сам файл также шифруется с помощью пароля, который нужно задать при создании файла-приглашения, а затем вводить при чтении файла-приглашения.
Злоумышленник может осуществлять запись и повторное воспроизведение сетевого трафика, даже не зная его содержимого. Таким образом одна и та же команда будет распространяться по сети много раз. Поскольку команды нумеруются и узел ведет учет выполненных команд, старые команды не будут выполняться повторно и эти действия нарушителя не будут критичными. Однако такие действия заставляют программу тратить некоторые ресурсы на их обработку, т.е. представляют собой некоторую dos-атаку. Для противостояния ей добавлен счетчик сетевых пакетов. Каждому своему сетевому пакету программа присваивает последовательно возрастающий номер, а также отслеживает номера входящих пакетов. Если во входящем пакете номер дублирует или меньше, чем номер ранее полученного пакета, сетевое соединение должно разрываться. Однако здесь появилась другая проблема. Если программа передает сообщение и в этот момент прекращает работу, не сохранив свое состояние (например, пропало электричество), в следующий раз она будет использовать уже использованный идентификатор и не сможет соединиться с другими узлами.
Злоумышленник не может расшифровать передаваемые данные, но может попытаться устроить mitm-атаку и модифицировать передаваемые данные. Для проверки их неизменности после каждой порции данных передается ее хеш, который инициализируется случайным числом, передаваемым в начале сеанса. Модификация данных таким образом, чтобы после расшифровки хеш оказался правильным, трудная задача. В некоторых случаях программа передает данные произвольной длины, например, файлы. В этом случае перед отправкой данных отправляется их размер. Если злоумышленник модифицирует это поле, программа будет ожидать файл очень большого размера, целостность которого не сможет проверить, пока не получит весь файл. Таким образом, злоумышленник может организовать атаку на переполнение места на диске. Чтобы этого избежать, после передачи размера данных произвольной длины так же передается из хеш.
Выводы
Программа distadm разработана для решения конкретной частной задачи. Однако описанные здесь идеи могут помочь другим в решении схожих задач. Если читателей заинтересует представленная программа, готов более подробно описать программу и реализованные в ней алгоритмы, выслушать об их недостатках, ответить на вопросы. В статье рассматривается способ управления (администрирования) компьютерами в небольшой организации. Под сетями в данной статье понимаются одна или несколько локальных компьютерных сетей, не связанных между собой, каждая из которых содержит один или несколько компьютеров. Под сетью из одного компьютера понимается отдельно стоящий компьютер, не подключенный ни к какому другому. Термин «децентрализованная» в данной статье означает, что среди компьютеров нет ни одного главного, с которого бы осуществлялось управление другими компьютерами, все имеют равный статус. Под управлением понимаются типичные задачи, решаемые администратором: установка и настройка программ, регулярная проверка результатов работы антивируса, свободного места и состояния S.M.A.R.T. жестких дисков, добавление и удаление учетных записей пользователей и т.п. В качестве примера можно представить общеобразовательную школу, в которой имеется несколько компьютерных классов. Компьютеры в каждом классе соединены в сеть, но классы в силу ряда причин не соединены между собой. Для лаборанта, отвечающего за работу классов, не выделено отдельного компьютера. Задачи администрирования ему приходится решать либо непосредственно на требующем внимания компьютере после уроков, либо с помощью удаленного доступа к нужному компьютеру по сети, если во время занятий в классе найдется другой свободный компьютер. Типичная работа лаборанта требует многократного выполнения одних и тех же действий на каждом компьютере. Такой подход нерационален с точки зрения затрат времени. Работа может быть автоматизирована различными скриптами и программами. Одна из таких программ описана в этой статье. Для администрирования компьютеров в децентрализованных сетях разработана программа distadm (Distributed Administrator, https://github.com/konstantin-2/distadm). Она позволяет, используя любой компьютер, где она установлена, управлять другими, где она так же должна быть установлена. Управлять другими компьютерами можно, даже если они находятся в другой сети и выключены в данный момент. Для этого программа накапливает управляющие команды и при первой возможности передает их другим компьютерам, которые, в свою очередь, распространяют команды дальше. Передача команд по сети происходит, как только два компьютера обнаруживают друг друга. Для передачи команд между несвязанными сетью компьютерами необходимо создавать специальные файлы и переносить их с помощью флешек или оптических дисков. Попав хотя бы на один из компьютеров новой сети управляющие команды распространяются по ней далее автоматически. Получается бот-сеть, но вполне легальная и полезная. С момента ее разработки и последних внесенных правок прошло более полугода, что показывает ее стабильность. Представляю свою программу публике в надежде, что она или заложенные в ней решения кому-то так же будут полезны. distadm https://github.com/konstantin-2/distadm Пример децентрализованных сетей  Пример децентрализованных сетей Программа работает на компьютерах с операционными системами Debian и Ubuntu.  В учебных классах компьютеры объединены в сеть коммутаторами (свитчами). Сеть построена на базе протокола IPv6 поскольку это современный протокол, не требующий ни каких настроек в режиме link-local. В текущей версии компьютеры не могут соединяться, если они разделены маршрутизатором, такой потребности нет, хотя было бы интересно добавить всякие DHT, PEX и т.п. У программы имеется графический интерфейс, а также возможность работы в командной строке. Компьютеры с установленной программой distadm называются узлами и объединяются в группу. При необходимости компьютер можно включить в состав нескольких групп одновременно. Далее приведены примеры использования программы, облегчающие жизнь администратору. distadm Управление учетными записями Для каждого школьника, у которого предусмотрены занятия по информатике, создается собственная учетная запись (разумеется, с дисковыми квотами). До использования программы distadm добавление учетных записей происходило следующим образом. Лаборант на каждом из компьютеров по очереди создавал учетную запись, вводил имя пользователя и пароль, иногда с опечатками. Это все занимало много времени. Удаление учетных записей происходило аналогично. Для автоматизации этой процедуры в программу distadm добавлена вкладка «Пользователи». distadm distadm  Вкладка «Пользователи» Вкладка «Пользователи» позволяет добавлять и удалять учетные записи пользователей на каждом узле, введя команду только на одном из них. Для добавления необходимо нажать кнопку «+» в нижней части окна, в новом окне ввести логин и пароль, затем нажать «ОК». Для удаления учетной записи необходимо выделить ее и нажать кнопку «x» внизу. Создание новой учетной записи  Создание новой учетной записи Для распространения одинакового пароля между узлами передается строка из файла /etc/shadow. В целях безопасности она передается в зашифрованном виде. Далее distadm на каждом компьютере запускает программы adduser и deluser соответственно. Преимуществом программы adduser перед useradd является начальное заполнение домашнего каталога пользователя файлами из /etc/skel при добавлении учетной записи, а также начальная инициализация с помощью скрипта adduser.local и финальная деинициализация с помощью скрипта deluser.local при удалении учетной записи (man adduser). В эти скрипты можно поместить, например, настройку дисковых квот. Оконные менеджеры, например LightDM, умеют обнаруживать новые учетные записи и добавляют новое имя пользователя в свой список на экране практически сразу по всему учебному классу. На выключенных компьютерах новая учетная запись добавляется, разумеется, только после включения компьютера. distadm adduser deluser adduser useradd adduser.local deluser.local Распространение файлов Иногда возникает задача разместить на компьютерах файлы. Это могут быть дистрибутивы программ, обучающие видеоролики, другие учебные и вспомогательные материалы. В серьезных организациях такие файлы выкладываются на файловый сервер, откуда пользователи получают к ним доступ. При отсутствии файлового сервера для автоматизации процесса распространения файлов в программу distadm добавлена вкладка «Файлы». distadm  Вкладка «Файлы» Вкладка «Файлы» позволяет распространять файлы между узлами. По умолчанию они хранятся в каталоге /var/local/distadm/files, куда имеет доступ только администратор (пользователь root), и откуда файлы можно переместить в любой другой каталог (в консоли командой mv, см. вкладку «Консоль»). При распространении больших файлов (несколько гигабайт) между узлами с помощью флешек небольшого объема программа автоматически разбивает такие файлы на части, стараясь максимально использовать на флешке свободное место. Для добавления файла нужно нажать кнопку «+» в нижней части окна, а для удаления выделить его в списке и нажать кнопку «x» внизу. mv Согласно логике программы добавление файла — это команда, которая должна быть выполнена на каждом компьютере. Отмена команд не предусмотрена. Удаление файла — это следующая команда. Таким образом, если добавить файл и сразу его удалить, он пропадет из списка, но останется на диске до тех пор, пока не скопируется на каждый компьютер в группе. Только после того, как программа узнает, что файл скопирован на каждый компьютер, она удалит это файл с диска за ненадобностью. Выполнение команд Обслуживание компьютеров подразумевает выполнение на нем различных команд. Например, командой df можно проверить наличие свободного места на дисках, smartctl показывает плохо работающие диски. Новые программы устанавливаются с помощью запуска инсталлятора, в т.ч. командой apt install. До написания программы distadm лаборант самостоятельно запускал программы по очереди на каждом из компьютеров. Для автоматизации этой работы в программу distadm добавлена вкладка «Консоль». df smartctl apt install distadm distadm  Вкладка «Консоль» Вкладка «Консоль» позволяет задавать команды для интерпретатора sh для выполнения на каждом из узлов. Использование sh в отличие от простого системного вызова exec позволяет использовать перенаправления ввода-вывода символами «|», «>», «<» и т.д. Результат выполнения (вывод программы) отображается во вкладке. Для выполнения сложных конструкций (с циклами, ветвлениями и т.п.) рекомендуется записать их в скрипт-файл, протестировать на отдельном компьютере, после чего распространить этот файл между узлами с помощью вкладки «Файлы» и запустить из вкладки «Консоль». Команды выполняются в каталоге /var/local/distadm/files, в котором хранятся распространяемые файлы. Таким образом, чтобы установить новую программу в простейшем случае достаточно распространить deb-файл с помощью вкладки «Файлы», а потом во вкладке «Консоль» ввести команду типа «apt install ./MY_NEW_PROGRAM.deb». Здесь же вводятся команды переноса файлов с учебными материалами из текущего каталога, недоступного пользователям, в другой доступный, например «mv лабораторная_№1.odp /home/common/Desktop». sh sh exec apt install ./MY_NEW_PROGRAM.deb mv лабораторная_№1.odp /home/common/Desktop Программа distadm отслеживает порядок выполнения команд (точнее, частичный порядок, см. «частично упорядоченное множество»). Поэтому если, например, на одном компьютере загрузить файл для распространения, а затем на другом, убедившись, что файл дошел, переместить его в другую папку, то на всех других компьютерах в группе команда перемещения файла будет выполняться только после команды добавления файла. Частичность порядка означает, что порядок выполнения независимых команд может быть произвольным. Например, если на одном компьютере ввести команду «выключить монитор», а на другом, не дожидаясь выключения монитора ввести команду «включить музыку», то эти две команды будут независимыми, и другие компьютеры в группе могут повести себя по-разному. На некоторых сначала выключится монитор, а затем заиграет музыка, а на других сначала включится музыка, тут как повезет. distadm Отслеживание состояния компьютеров Если Вам говорят, что под Линукс не бывает вирусов, не верьте. Школьники любят приносить на уроки всякую дрянь. Поэтому одна из задач лаборанта заключается в том, чтобы в дополнение к проактивной защите периодически запускать антивирус. В моем случае школа использует DrWeb. Антивирус в комплекте с программой distadm не поставляется. Кроме того, интерес представляет состояние S.M.A.R.T. дисков компьютеров. Эта информация не представляет какой-либо важности, чтобы скрывать ее от пользователей. Поэтому при запуске программы distadm с ключом «-i» отображается информационное табло. distadm distadm -i  Информационное табло Колонка «Онлайн» означает последнее известное время работы программы. Если известно, что компьютер работает, но дата не обновляется, значит, в работе программы произошел сбой. Но как я уже говорил, за последние полгода все работает без сбоев. Информация о работе может задерживаться, если компьютер не доступен по сети, а свежие данные от него на флешке еще не принесли. В колонке «Базы антивируса» отображается дата базы антивируса, позволяет обнаруживать ситуации, если по каким-то причинам антивирус перестает обновляться. В колонке «Проверка» отображается дата запуска последней проверки, она позволяет обнаруживать ситуации, когда по каким-то причинам проверка перестает производиться. В колонке «Результат» должно быть пусто. Наличие надписи «Внимание» говорит о том, что на компьютере нашелся вирус. В колонке «S.M.A.R.T.» так же должно быть пусто. Надпись «Внимание» говорит о том, что пора менять жесткий диск. Получение информации от антивируса осуществляется с помощью простых скриптов, которые каждый может переделать под свою ситуацию. Перенос информации на флешках Когда администратор вводит в программу новую команду, все компьютеры в классе узнают о ней по сети. Но компьютеры в другом классе, не подключенном по сети, о новой команде не знают. Ее необходимо перенести в другой класс, например, на флешке. Панель с кнопками  Панель с кнопками Для обмена информацией между изолированными сегментами в программе предусмотрены четыре кнопки справа на панели. Кнопка «Записать пакет» с зеленой стрелочной записывает информацию в файл, который можно записать на флешку, перенести в другой класс и прочитать на любом из компьютеров с помощью кнопки «Прочитать пакет» с красной стрелочной. Красный цвет означает некоторую опасность, поскольку после прочтения программа начинает выполнять полученные команды, которые не всегда могут успешно выполниться, если администратор их составил не аккуратно. Далее информация распространится между компьютерами по местной локальной сети. Информацию между изолированными сегментами нужно переносить в обе стороны, даже если все управляющие команды вводятся только в одном сегменте. Другой сегмент должен отчитаться о том, что команды получены и выполнены. Поэтому запись и чтение часто выполняются вместе. При нажатии на кнопку «Прочитать-записать пакет» с двухсторонней зелено-красной стрелкой выполняются чтение входящей и запись подготовленной информации, нет необходимости открывать один файл два раза. Программа запоминает путь к файлу, поэтому в следующий раз, если флешка подключилась по тому же пути, что и в предыдущий, достаточно нажать кнопку «Повторить чтение-запись» с красно-зеленой молнией и не указывать путь к файлу. Установка программы Исходный код программы и deb-файлы доступны по ссылке https://github.com/konstantin-2/distadm. При установке программа помещается в каталог /usr/local/sbin. Для запуска необходимы права пользователя root, поскольку задачи управления компьютером требуют таких прав от пользователя. Для установки из deb-файла необходимо выполнить команду: https://github.com/konstantin-2/distadm sudo apt install ./distadm.deb sudo apt install ./distadm.deb Некоторые компьютеры не имеют графического интерфейса. Устанавливать на них библиотеки GTK для компиляции и работы программы не нужно. Для них собран отдельный пакет, поддерживающий работу только в консоли. Для его установки необходимо выполнить команду: sudo apt install ./distadm-console.deb sudo apt install ./distadm-console.deb Для программы установки из исходного кода необходимо выполнить команды: make clean
sudo make install -j make clean
sudo make install -j Для установки программы из исходного кода на компьютере, где нет графического интерфейса, необходимо выполнить команды: make clean
sudo NO_X=y make install -j make clean
sudo NO_X=y make install -j Чтобы создать собственный deb-файл, необходимо выполнить команды: sudo make clean
sudo make distadm.deb sudo make clean
sudo make distadm.deb Чтобы создать собственный deb-файл для компьютеров, где нет графического интерфейса, необходимо выполнить команды: sudo make clean
sudo make distadm-console.deb sudo make clean
sudo make distadm-console.deb Запуск программы При первом запуске программы выдается сообщение о том, что узел не инициализирован (программа не настроена), предлагается создать новую группу компьютеров, которыми будет осуществляться управление, либо присоединиться к существующей группе. Начальное окно неинициализированного узла  Начальное окно неинициализированного узла После нажатия кнопки «Новая группа» узел инициализируется и отобразится основное окно программы. В верхней части окна находится панель инструментов с кнопками, которые будут описаны далее. Ниже находятся вкладки.  Вкладка «Узлы» с одним узлом На вкладке «Узлы» содержится информация об узлах в составе группы. Сразу после создания новой группы во вкладке содержится только одна запись — текущий компьютер. По мере роста группы количество записей увеличивается. Например, если добавить к группе еще два компьютера, один в той же сети и один отдельно стоящий, будет три узла. Добавление компьютеров описано ниже.  Вкладка «Узлы» с тремя узлами Колонка «№» справочная и не имеет отношения к нумерации узлов в программе. В колонке «UUID» содержится UUID узла, который остается неизменным даже если изменить hostname на этом компьютере. Далее идет колонка, содержащая hostname этого узла. В колонке «Онлайн» содержится последняя известная дата работы программы на этом узле. Если компьютер запущен, а дата не обновляется, значит в работе программы distadm произошел сбой. Далее идут колонки с числами в заголовках, это «матрица осведомленности», которая описана ниже и носит справочно-отладочную информацию. В последней колонке отображается счетчик сетевых пакетов узла, который планируется к использованию для защиты от спуфинга, когда нарушитель записывает сетевой трафик, а затем воспроизводит его, пытаясь повлиять на работу программы. Вкладка «Узлы» носит информативный характер, позволяет разобраться в работе программы, изучать, как именно распространяются сообщения между узлами. В нижней части вкладки находится кнопка удаления выделенного узла из группы. При нажатии на нее отображается всплывающее окно: distadm Подтверждение удаления узла  Подтверждение удаления узла При выборе варианта «Да» создается команда на удаление узла из группы. Когда эта команда попадет на удаляемый компьютер, он помечает себя как удаляемый и создает прощальное сообщение, получив которое, другие узлы вычеркивают его из своих списков. Вариант «Принудительно» создает команду удалить запись об узле, не дожидаясь от него прощального сообщения. Использование принудительного удаления не рекомендуется, поскольку при этом возникает опасность того, что команды удаляемого узла будут выполнены не на всех других узлах, возникнет «неконсистентность» данных. Однако этот вариант является единственно возможным для удаления поврежденного узла, который не способен создать прощальное сообщение. Перед выбором этого варианта рекомендуется проверить, что все команды удаляемого узла выполнены на каждом оставшемся узле.  Вкладка «Очередь» Вкладка «Очередь» показывает, сколько на текущем узле имеется сообщений (команд), которые необходимо передать другим узлам. Большое значение у узла указывает на необходимость обратить на него внимание, установить причину, по которой команды до него не доходят или не возвращаются ответы о том, что команды получены. Распространение информации между узлами должно происходить в обе стороны. Для узлов в одной компьютерной сети очередей вообще не должно быть, за исключением случаев, когда один из компьютеров выключен.  Вкладка «Команды» Вкладка «Команды» показывает команды, хранящиеся на текущем узле, которые предназначены для распространения на другие узлы. Информация носит справочный характер и позволяет разобраться в особенностях работы программы.  Вкладка «Локально» Вкладка «Локально» так же носит справочный характер, отображает идентификаторы группы, узла, его статус. Узел может иметь следующие статусы: uninitialized
узел присоединился к группе с помощью онлайн-приглашения и ожидает подключения к другим узлам по сети;
partially-initialized
узел присоединился к группе с помощью оффлайн-приглашения и ожидает файла-пакета;
work
узел работает в штатном режиме. Основной режим работы;
inviter
узел является оффлайн-приглашающим и потребляет дополнительные ресурсы (смотри команды write-offline-invite, finalize-invite);
deleting
узел удален (смотри команду delnode). Он не может создавать и получать новые команды;
deleted
то же, что deleting, но при попытке запуска программа сразу завершается. uninitialized
узел присоединился к группе с помощью онлайн-приглашения и ожидает подключения к другим узлам по сети;
partially-initialized
узел присоединился к группе с помощью оффлайн-приглашения и ожидает файла-пакета;
work
узел работает в штатном режиме. Основной режим работы;
inviter
узел является оффлайн-приглашающим и потребляет дополнительные ресурсы (смотри команды write-offline-invite, finalize-invite);
deleting
узел удален (смотри команду delnode). Он не может создавать и получать новые команды;
deleted
то же, что deleting, но при попытке запуска программа сразу завершается. uninitialized
узел присоединился к группе с помощью онлайн-приглашения и ожидает подключения к другим узлам по сети;
partially-initialized
узел присоединился к группе с помощью оффлайн-приглашения и ожидает файла-пакета;
work
узел работает в штатном режиме. Основной режим работы;
inviter
узел является оффлайн-приглашающим и потребляет дополнительные ресурсы (смотри команды write-offline-invite, finalize-invite);
deleting
узел удален (смотри команду delnode). Он не может создавать и получать новые команды;
deleted
то же, что deleting, но при попытке запуска программа сразу завершается. uninitialized
узел присоединился к группе с помощью онлайн-приглашения и ожидает подключения к другим узлам по сети;
partially-initialized
узел присоединился к группе с помощью оффлайн-приглашения и ожидает файла-пакета;
work
узел работает в штатном режиме. Основной режим работы;
inviter
узел является оффлайн-приглашающим и потребляет дополнительные ресурсы (смотри команды write-offline-invite, finalize-invite);
deleting
узел удален (смотри команду delnode). Он не может создавать и получать новые команды;
deleted
то же, что deleting, но при попытке запуска программа сразу завершается. uninitialized
узел присоединился к группе с помощью онлайн-приглашения и ожидает подключения к другим узлам по сети; uninitialized uninitialized uninitialized узел присоединился к группе с помощью онлайн-приглашения и ожидает подключения к другим узлам по сети; узел присоединился к группе с помощью онлайн-приглашения и ожидает подключения к другим узлам по сети; partially-initialized
узел присоединился к группе с помощью оффлайн-приглашения и ожидает файла-пакета; partially-initialized partially-initialized partially-initialized узел присоединился к группе с помощью оффлайн-приглашения и ожидает файла-пакета; узел присоединился к группе с помощью оффлайн-приглашения и ожидает файла-пакета; work
узел работает в штатном режиме. Основной режим работы; work work work узел работает в штатном режиме. Основной режим работы; узел работает в штатном режиме. Основной режим работы; inviter
узел является оффлайн-приглашающим и потребляет дополнительные ресурсы (смотри команды write-offline-invite, finalize-invite); inviter inviter inviter узел является оффлайн-приглашающим и потребляет дополнительные ресурсы (смотри команды write-offline-invite, finalize-invite); узел является оффлайн-приглашающим и потребляет дополнительные ресурсы (смотри команды write-offline-invite, finalize-invite); deleting
узел удален (смотри команду delnode). Он не может создавать и получать новые команды; deleting deleting deleting узел удален (смотри команду delnode). Он не может создавать и получать новые команды; узел удален (смотри команду delnode). Он не может создавать и получать новые команды; deleted
то же, что deleting, но при попытке запуска программа сразу завершается. deleted deleted deleted то же, что deleting, но при попытке запуска программа сразу завершается. то же, что deleting, но при попытке запуска программа сразу завершается. Добавление новых узлов Добавление новых узлов в группу можно осуществлять в двух режимах: онлайн и оффлайн. Онлайн означает, что все данные для инициализации узла будут передаваться по сети, оффлайн — что их придется переносить с помощью файлов. Для добавления в группу новых узлов в онлайн режиме необходимо создать онлайн-приглашение. Оно создается с помощью второй кнопки на панели инструментов, на которой нарисован провод и вилка. Созданный файл имеет небольшой размер, содержит только идентификатор группы и ключ симметричного шифрования. Далее необходимо на новом узле запустить программу distadm. Она отобразит сообщение о том, что узел не инициализирован, и предложит варианты создать новую группу или присоединиться к существующей. Необходимо выбрать второй вариант и указать на файл-приглашение. Программа установит статус нового узла как «uninitialized» и начнет искать в сети другие узлы из этой группы. Как только соединение с ними установится, программа запросит все необходимые данные, инициализируется и поменяет статус узла на «work». distadm Для добавления новых узлов в оффлайн режиме необходимо создать оффлайн-приглашение. Оно создается с помощью третьей кнопки на панели инструментов, на которой нарисован оптический диск и зеленый символ «плюс». Созданный файл может иметь большой размер поскольку содержит всю информацию, необходимую для нового узла, в том числе все загруженные файлы. Далее необходимо на новом узле запустить программу distadm, выбрать вариант «присоединиться к существующей группе» и указать файл-приглашение. Программа считает все необходимые данные, частично инициализируется, установит свой статус на «partially initialized» и допишет информацию о себе в файл-приглашение. Далее это приглашение необходимо открыть на инициализирующем (приглашающем) узле с помощью четвертой кнопки на панели инструментов, на которой нарисован оптический диск и флажок с шахматной раскраской. Программа прочитает из приглашения идентификатор нового узла и создаст для него команду-приветствие. Далее необходимо создать файл-пакет, перенести его на новый узел и там открыть в программе с помощью кнопки «прочитать пакет». Программа, обнаружив приветствие, поймет, что инициализация прошла успешно, и поменяет свой статус на «work». distadm С помощью одного приглашения можно последовательно инициализировать несколько узлов. Не следует допускать утечки файлов-приглашений, поскольку в этом случае злоумышленник, завладев ключом симметричного шифрования, сможет присоединить к группе свой компьютер и создавать свои управляющие команды. Дополнительно файл-приглашение защищается при его создании паролем. Статус узла как оффлайн-приглашающего означает потребление им дополнительных ресурсов, он вынужден накапливать все поступающие команды и не может их удалять. В некоторых случаях может возникнуть потребность убрать у узла статус оффлайн-приглашающего, например, если файл оффлайн-инициализации был утерян. Для этого используется пятая кнопка на панели инструментов, на которой нарисован оптический диск и красный перечеркнутый круг. Она позволяет поменять статус узла на «work». Матрица осведомленности Далее идет техническое описание некоторых аспектов работы программы. Каждый узел может создавать сообщения, содержащие различную информацию или управляющие команды. Уникальным идентификатором сообщения является UUID узла автора и номер, последовательно присваиваемый при создании новых команд. На каждом узле ведется своя нумерация. Для определения того, кому и какие новые сообщения необходимо передать, используется «матрица осведомленности». Также она используется для того, чтобы избежать бесконечного накопления команд. Если узел знает, что некоторая команда выполнена всеми узлами в группе, то ее больше нет смысла хранить и она будет удалена, освободив место. Посмотреть на «матрицу осведомленности» можно на вкладке «Узлы» программы. Строка матрицы описывает то, какие команды знает соответствующий узел по мнению текущего узла. Столбцы соответствуют узлам, про чьи сообщения идет речь.    Например, если в 1 строке во 2 столбце находится число 3, это означает, что, по мнению текущего узла, 1 узел знает все команды от 2 узла до его 3-й команды не включительно (так было проще при написании программы), т.е. 3 — это номер следующей команды, которую может создать или уже создал 2-й узел. текущего Когда узел присоединяется к другому по сети или записывает файл-пакет, он сообщает свою матрицу осведомленности. Другой узел, получив матрицу, обновляет свою, записывая в каждую ячейку число, максимум между старым значением и соответствующим значением из прочитанной матрицы. Обмениваясь такими матрицами осведомленности узлы обновляют свои данные о том, какие узлы какие команды знают. Если в процессе общения двух узлов по сети, анализируя матрицы, один узел видит, что другой узел знает новые команды, которые не знает первый узел, он запрашивает их. Если позже к первому узлу по сети подключится третий, то, прочитав матрицу, он узнает о существовании новых команд и запросит их. Таким образом сообщения передаются по сети. Когда узел формирует файл-пакет для оффлайн общения, он записывает в него свою матрицу и все сообщения, которые, исходя из матрицы, неизвестны хотя бы одному другому узлу. Каждое сообщение будет передаваться до тех пор, пока узел не обновит свою матрицу и не узнает, что это сообщение известно всем узлам в группе. Таким образом файлы-пакеты позволяют передавать информацию между любыми узлами, а случайная утрата файлов-пакетов не представляет угрозы. После того как команда, содержащаяся в сообщении, выполнена узлом и ему известно, что это сообщение известно всем другим узлам, сообщение удаляется за ненадобностью. Пример. Пусть есть два узла A и B, которые пока не создали ни одного сообщения. Матрицы осведомленности на них будут нулевыми.    Пусть узел A создал команду «cmd», которую вместе со своим идентификатором можно записать так {A, 0, «cmd»}, где A — узел автор команды, 0 — последовательно присваиваемый номер на этом узле. После этого матрицы осведомленности и хранящиеся команды будут следующими:    Далее пусть узел B получает от A его матрицу и обновляет свою:    Узел B, сравнивая у своей матрицы вторую строку (свою) с первой (узла A), видит, что узел A знает команду {A, 0}, не известную ему. Он запрашивает эту команду и обновляет матрицу.    Узел «B» выполнив полученную команду, проанализировав первый столбец своей матрицы, увидит, что команда № 0 от узла «A» известна всем узлам и больше хранить ее нет смысла, значит ее можно удалить, что он и сделает.    Когда в следующий раз узел «A» запросит у «B» матрицу и объединит со своей получится следующее:    Аналогичным образом узел «А», проанализировав первый столбец, увидит ненужность команды № 0 от узла «A» и тоже удалит ее.    Вектор выполненных команд. Некоторые команды требуют последовательного выполнения, то есть множество команд является частично упорядоченным. Например, если на одном узле дать команду на создание учетной записи пользователя, а затем на втором узле дать команду на ее удаление, и, если команда на удаление придет на третий узел раньше, чем команда на создание, и если не соблюдать последовательность их выполнения, может произойти казус. Чтобы соблюсти последовательность, на каждом узле имеется вектор, описывающий номера выполненных команд (вектор выполненных команд). Это позволяет частично упорядочивать команды. Значение элемента вектора указывает, что все команды от соответствующего узла до этого значения (не включительно) выполнены. При создании новой команды к ней команде добавляется «вектор минимальных требований», равный вектору выполненных команд в текущий момент времени. Он указывает, что не следует выполнять новую команду до тех пор, пока не будут выполнены предыдущие в соответствии с этим вектором. Вектор выполненных команд. На вкладке «Узлы» в программе вектор выполненных команд совмещен со строкой матрицы осведомленности этого узла. Числа разделены символом «/». Первое число — элемент вектора выполненных команд, второе — элемент матрицы осведомленности. В общем случае эти числа должны быть равными, потому что каждая известная команда должна быть выполнена. Можно пояснить сказанное на следующем примере. Пусть есть три узла, A, B, C с нулевыми матрицами и нулевыми векторами выполненных команд.    На узле A создается команда «добавить новую учетную запись» (NU). К ней добавляется вектор минимальных требований, равный вектору выполненных команд. В связи с появлением новой команды также обновляется матрица осведомленности.    Здесь в команде, заключенной в фигурные скобки, первый элемент «A» — идентификатор узла автора команды. Второй элемент «0» — номер команды. Третий элемент, строка «NU» — сама команда. Четвертый элемент, вектор «(0, 0, 0)» — вектор минимальных требований. После того, как на узле A эта команда выполнена, первый элемент вектора выполненных команд увеличивается на единицу:    Пусть узел B получает матрицу от узла A и обновляет свою:    Узел B, сравнивая вторую (свою) строку с первой (узла A), узнает о существовании команды {A, 0, …} и запрашивает ее, после чего обновляет свою матрицу осведомленности:    Узел B сравнивает свой вектор выполненных команд с вектором минимальных требований в полученной команде. Поскольку каждое число в векторе минимальных требований не превышает аналогичное в векторе выполненных команд, т.е. минимальные требования выполнены, узел выполняет полученную команду и обновляет вектор выполненных команд:    Далее пусть узел B создает новую команду «Удалить учетную запись» (DU), также обновляя матрицу осведомленности:    Выполнив свою команду, узел B обновляет вектор выполненных команд:    Узел C получает матрицу узла B и обновляет свою:    Сравнив вторую и третью строки, узел C узнает про новые команды и запрашивает их:    Сравнивая вектор минимальных требований в командах со своим вектором выполненных команд, узел C понимает, что может выполнить только команду {A, 0, …}, но не {B, 0, …}, поскольку для второй команды минимальные требования не выполнены. Выполнив первую команду и обновив вектор выполненных команд, узел C обнаруживает, что теперь может выполнить вторую команду:    Выполнив команду {B, 0, …} узел C обновляет вектор выполненных команд:    Вот как-то так программа выполняет частично упорядоченные команды. Безопасность Поскольку программа предназначена для решения задач администрирования, она требует для запуска права администратора. Чтобы избежать перехвата и подмены передаваемой информации, она шифруется симметричным алгоритмом шифрования. Сеансовый ключ состоит из случайного числа, передаваемого в начале сеанса, и общего ключа группы. Ключ группы хранится на каждом узле и, по сути, представляет собой идентификатор группы, информация от других групп расшифруется с ошибкой и будет отброшена. Если злоумышленник получит доступ к ключу, он сможет создавать свои команды, т.е. получит доступ к управлению всей группой. Поскольку файл-приглашение содержит ключ шифрования, то сам файл также шифруется с помощью пароля, который нужно задать при создании файла-приглашения, а затем вводить при чтении файла-приглашения. Злоумышленник может осуществлять запись и повторное воспроизведение сетевого трафика, даже не зная его содержимого. Таким образом одна и та же команда будет распространяться по сети много раз. Поскольку команды нумеруются и узел ведет учет выполненных команд, старые команды не будут выполняться повторно и эти действия нарушителя не будут критичными. Однако такие действия заставляют программу тратить некоторые ресурсы на их обработку, т.е. представляют собой некоторую dos-атаку. Для противостояния ей добавлен счетчик сетевых пакетов. Каждому своему сетевому пакету программа присваивает последовательно возрастающий номер, а также отслеживает номера входящих пакетов. Если во входящем пакете номер дублирует или меньше, чем номер ранее полученного пакета, сетевое соединение должно разрываться. Однако здесь появилась другая проблема. Если программа передает сообщение и в этот момент прекращает работу, не сохранив свое состояние (например, пропало электричество), в следующий раз она будет использовать уже использованный идентификатор и не сможет соединиться с другими узлами. Злоумышленник не может расшифровать передаваемые данные, но может попытаться устроить mitm-атаку и модифицировать передаваемые данные. Для проверки их неизменности после каждой порции данных передается ее хеш, который инициализируется случайным числом, передаваемым в начале сеанса. Модификация данных таким образом, чтобы после расшифровки хеш оказался правильным, трудная задача. В некоторых случаях программа передает данные произвольной длины, например, файлы. В этом случае перед отправкой данных отправляется их размер. Если злоумышленник модифицирует это поле, программа будет ожидать файл очень большого размера, целостность которого не сможет проверить, пока не получит весь файл. Таким образом, злоумышленник может организовать атаку на переполнение места на диске. Чтобы этого избежать, после передачи размера данных произвольной длины так же передается из хеш. Выводы Программа distadm разработана для решения конкретной частной задачи. Однако описанные здесь идеи могут помочь другим в решении схожих задач. Если читателей заинтересует представленная программа, готов более подробно описать программу и реализованные в ней алгоритмы, выслушать об их недостатках, ответить на вопросы. distadm ]]></text>
</doc>
