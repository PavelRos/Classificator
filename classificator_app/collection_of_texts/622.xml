<?xml version="1.0" ?>
<doc>
	<label auto="true" type="str" verify="true"><![CDATA[Develop]]></label>
	<author auto="true" type="list" verify="true">
		<item type="str"><![CDATA[Infinitive1]]></item>
	</author>
	<date auto="true" type="str" verify="true"><![CDATA[2022-11-29, 11:22]]></date>
	<link auto="true" type="str" verify="true"><![CDATA[https://habr.com/ru/post/702218/]]></link>
	<title auto="true" type="str" verify="true"><![CDATA[Зачем __name__ == "__main__"?]]></title>
	<categories auto="true" type="list" verify="true">
		<item type="str"><![CDATA[Python]]></item>
		<item type="str"><![CDATA[Программирование]]></item>
		<item type="str"><![CDATA[Учебный процесс в IT]]></item>
	</categories>
	<key_words auto="true" type="list" verify="true">
		<item type="str"><![CDATA[python]]></item>
		<item type="str"><![CDATA[python tutor]]></item>
		<item type="str"><![CDATA[база]]></item>
	</key_words>
	<text auto="true" type="str" verify="true"><![CDATA[В этой небольшой статье мы рассмотрим один из самых популярных "новичковых" вопросов - зачем нам конструкция if __name__ == "__main__".
Эта статья ориентирована на начинающих разработчиков, я пытаюсь объяснить тему максимально понятно и доступно. Поэтому где-то лукавлю, где-то преувеличиваю, но это для лучшего понимания, не кидайтесь ананасами :)
Прежде чем изучить конструкцию if __ name__ == __"main__", необходимо знать несколько вещей:
Интерпретатор Python выполняет весь код, который сможет найти в файле.
Когда Python запускает "исходный файл" в качестве основной программы, он присваивает переменной __name__ значение __main__
В языках программирования существует такое понятие, как точка входа. В некоторых языках программирования (C, C#, Go) конструкция if __name__ == "__main__" не требуется, потому что в самом начале разработки задается точка входа, без нее компилятор выдаст ошибку. Python же относится к этому лояльно и позволяет пользователю не указывать точку входу (Python в качестве точки входа считает первую строку), что может приводить к серьезным проблемам.
Также данная конструкция позволяет разделять файлы, чтобы они не пересекались при одновременной работе (при импорте модуля, либо при запуске самого модуля). 
Например, у нас есть две программы:
(test.py) выводит значение переменной __name__, а затем строку "Hello world". 
(test_2.py) импортирует модуль test.
Если в качестве исходной (откуда происходит запуск) программы мы выберем test.py, то на выводе получаем следующее:
Так как в качестве исходной программы мы выбрали test.py, интерпретатор Python присвоил значение переменной __name__: __main__. Теперь попробуем запустить test_2.py.
 Как видим, вместо __main__ мы получили test. Почему это произошло? Потому что мы запустили модуль test, в котором есть строка print(__name__), но так как мы запустили этот код из другой программы (test_2.py), интерпретатор не вывел __main__.
Проще говоря, если мы запускаем программу через «побочную» программу, то переменной __name__ не будет задаваться значение __main__, что позволяет избежать лишнего срабатывания кода. Например:
Мы запустили файл test.py и получили на вывод результат сложения двух чисел и их разность. Также в конце вывели строку, говорящую, что запуск выполнен с помощью test.py. Если же мы импортирует этот модуль в программу test_2.py, то получим на вывод следующее:
А именно сообщение, что мы выполнили действия с помощью test.py, хотя в действительности это не так, ведь мы использовали test_2.py, а не test.py. Чтобы избежать подобного «лишнего» срабатывания фрагментов кода, необходимо в исходном файле (модуле) дописать конструкцию if __name__ == “__main__”. Должно получиться вот так:
Теперь при импортировании модуля test в test_2.py будет выполняться проверка значения переменной __name__. Запускаем наш test_2.py и видим, что теперь срабатывания print(“успешно выполнено с помощью test.py”) не произошло. 
Благодарю за прочтение статьи, надеюсь вы подчерпнули из неё что-то новое.
Пишите в комменты какую тему разобрать в следующий раз, всем добра!
Мой GitHub: https://github.com/Ryize В этой небольшой статье мы рассмотрим один из самых популярных "новичковых" вопросов - зачем нам конструкция if __name__ == "__main__". Эта статья ориентирована на начинающих разработчиков, я пытаюсь объяснить тему максимально понятно и доступно. Поэтому где-то лукавлю, где-то преувеличиваю, но это для лучшего понимания, не кидайтесь ананасами :)  Прежде чем изучить конструкцию if __ name__ == __"main__", необходимо знать несколько вещей: name__ main__ Интерпретатор Python выполняет весь код, который сможет найти в файле.
Когда Python запускает "исходный файл" в качестве основной программы, он присваивает переменной __name__ значение __main__ Интерпретатор Python выполняет весь код, который сможет найти в файле. Интерпретатор Python выполняет весь код, который сможет найти в файле. Когда Python запускает "исходный файл" в качестве основной программы, он присваивает переменной __name__ значение __main__ Когда Python запускает "исходный файл" в качестве основной программы, он присваивает переменной __name__ значение __main__ В языках программирования существует такое понятие, как точка входа. В некоторых языках программирования (C, C#, Go) конструкция if __name__ == "__main__" не требуется, потому что в самом начале разработки задается точка входа, без нее компилятор выдаст ошибку. Python же относится к этому лояльно и позволяет пользователю не указывать точку входу (Python в качестве точки входа считает первую строку), что может приводить к серьезным проблемам. точка входа if __name__ == " __main__ " Python в качестве точки входа считает первую строку) Также данная конструкция позволяет разделять файлы, чтобы они не пересекались при одновременной работе (при импорте модуля, либо при запуске самого модуля).  Например, у нас есть две программы: (test.py) выводит значение переменной __name__, а затем строку "Hello world". 
(test_2.py) импортирует модуль test. (test.py) выводит значение переменной __name__, а затем строку "Hello world".  (test.py) выводит значение переменной __name__, а затем строку "Hello world".  test.py __name__ (test_2.py) импортирует модуль test. (test_2.py) импортирует модуль test. Если в качестве исходной (откуда происходит запуск) программы мы выберем test.py, то на выводе получаем следующее: откуда происходит запуск test.py    Так как в качестве исходной программы мы выбрали test.py, интерпретатор Python присвоил значение переменной __name__: __main__. Теперь попробуем запустить test_2.py. переменной __name__ __main__      Как видим, вместо __main__ мы получили test. Почему это произошло? Потому что мы запустили модуль test, в котором есть строка print(__name__), но так как мы запустили этот код из другой программы (test_2.py), интерпретатор не вывел __main__. __main__ __name__ __main__ Проще говоря, если мы запускаем программу через «побочную» программу, то переменной __name__ не будет задаваться значение __main__, что позволяет избежать лишнего срабатывания кода. Например: __name__ __main__   Мы запустили файл test.py и получили на вывод результат сложения двух чисел и их разность. Также в конце вывели строку, говорящую, что запуск выполнен с помощью test.py. Если же мы импортирует этот модуль в программу test_2.py, то получим на вывод следующее:    А именно сообщение, что мы выполнили действия с помощью test.py, хотя в действительности это не так, ведь мы использовали test_2.py, а не test.py. Чтобы избежать подобного «лишнего» срабатывания фрагментов кода, необходимо в исходном файле (модуле) дописать конструкцию if __name__ == “__main__”. Должно получиться вот так: __name__ __main__   Теперь при импортировании модуля test в test_2.py будет выполняться проверка значения переменной __name__. Запускаем наш test_2.py и видим, что теперь срабатывания print(“успешно выполнено с помощью test.py”) не произошло.  __name__    Благодарю за прочтение статьи, надеюсь вы подчерпнули из неё что-то новое. Пишите в комменты какую тему разобрать в следующий раз, всем добра! Мой GitHub: https://github.com/Ryize https://github.com/Ryize ]]></text>
</doc>
