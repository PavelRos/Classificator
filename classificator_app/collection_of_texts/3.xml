<?xml version="1.0" ?>
<doc>
	<label auto="true" type="str" verify="true"><![CDATA[Develop]]></label>
	<author auto="true" type="list" verify="true">
		<item type="str"><![CDATA[witch_finder]]></item>
	</author>
	<date auto="true" type="str" verify="true"><![CDATA[2022-12-17, 20:47]]></date>
	<link auto="true" type="str" verify="true"><![CDATA[https://habr.com/ru/post/706140/]]></link>
	<title auto="true" type="str" verify="true"><![CDATA[Использование архитектуры Composition root в Unity. Часть 1. Настройка проекта с нуля]]></title>
	<categories auto="true" type="list" verify="true">
		<item type="str"><![CDATA[C#]]></item>
		<item type="str"><![CDATA[Unity]]></item>
	</categories>
	<key_words auto="true" type="list" verify="true">
		<item type="str"><![CDATA[unity]]></item>
		<item type="str"><![CDATA[unity3d]]></item>
		<item type="str"><![CDATA[gamedev]]></item>
		<item type="str"><![CDATA[c#]]></item>
		<item type="str"><![CDATA[архитектура]]></item>
		<item type="str"><![CDATA[observer pattern]]></item>
		<item type="str"><![CDATA[composition root]]></item>
	</key_words>
	<text auto="true" type="str" verify="true"><![CDATA[Привет всем, кто неравнодушен к архитектурным решениям в рамках проектов на Unity и не только. Если вопрос выбора для вас ещё актуален или просто интересуетесь вариантами, то готов рассказать о реализации архитектуры Composition root с примерами простейшей логики. Здесь есть единая точка входа и Dependency Injection, то есть всё как мы любим. Сам я уже несколько лет придерживаюсь данной архитектуры и реализовал на ней не мало проектов, от ГК прототипов, до pvp игр.
Composition root представляет собой смесь моделей MVP и MVVM и активно использует шаблон Observer, в данной статье я не буду углубляться в суть этих терминов, а попробую наглядно показать как это работает. Реализация структуры проекта идёт через связку базовых понятий:  Entity - Presenter Model (PM) - View.
Entity - сущность, отдельная логическая единица, служащая для создания PM и View и передающая им зависимости
Presenter Model - содержит бизнес логику, не имеющую отношение к Monobehaviour классам
View - Gameobject на сцене
Путь от единой точки входа, до первой игровой сущности
Посмотрим на практике, как сделать первые шаги. Создадим два объекта на сцене: пустой Canvas и GameObject Entry Point с компонентом на нём с таким же названием.
Класс EntryPoint будет содержать совсем немного кода
EntryPoint
Тут стоит пояснить, что _uiRoot - этот тот самый пустой канвас, а _contentProvider - это scriptable object, в котором будет лежать всё, что в дальнейшем должно появиться на сцене. Класса Root у нас ещё нет и дальше мы создадим и его.
В будущем освещение и камеру тоже стоит подгружать из Content Provider
Тут начинается всё самое интересное, сначала создаём класс DisposableObject , от которого будут унаследованы все наши будущие сущности и PM, включая Root. Назначение DisposableObject в том, чтобы при необходимости суметь безопасно уничтожить свои экземпляры и подписки внутри них. Тут мы постепенно подходим к паттерну Observer, но обо всём по порядку. 
Класс DisposableObject
Один из наиболее популярных фреймворков для реактивного программирования в Unity является UniRx, именно он поможет установить логические связи между сущностями и их порождениями. Подробнее о нём можно почитать вот здесь. Интерфейс IDisposable является частью UniRx.
Класс Root
Теперь contentProvider и uiRoot являются переменными в структуре Ctx (название сокращенно от Context). Эта структура была создана в EntryPoint и передана в конструктор класса Root, что положило основу “корню” для будущего дерева нашего проекта.
Создадим Game Entity
Реализация простейшей логики
На данном этапе Game Entity порождает только одну сущность UIEntity, внутри которой будет реализована простая логика подсчёта кликов по кнопке. Рассмотрим реализацию UIEntity и логику связей внутри сущности при помощи реактивной переменной.
Класс UIEntity
Класс UIPm
Класс UIViewWithButton
Сущность порождает PM c логикой вывода количества кликов в Debug.Log. Здесь всё просто и акцентировать внимание не на чем. Реализация вьюхи чуть более интересная. Для её создания пригодились content provider, в котором лежал префаб с соответствующим компонентом и uiRoot, послуживший родителем для этого префаба.
buttonClickCounter  - реактивная переменная, созданная посредством UniRx, ставшая частью контекста для вьюхи и pm. Она инициализируется в сущности и передаётся дальше. UIViewWithButton на каждый клик инкриминирует значение переменной, UIPm принимает это значение. Для это в Pm нужно создать подписку на изменение значения переменной. Эта подписка добавляется в список внутри DisposableObject и будет уничтожена, при разрушении объекта. 
Естественно, в контексте можно передавать переменные любого типа, но именно реактивные переменные и события наиболее удобны для организации связей между логическими единицами. 
Используя такую связь, можно создавать краткие инкапсулированные вьюхи, оставляя им только моменты взаимодействия с игроком, а всю логику прятать в pm. Сущности могут порождать другие сущности, содержащие сколько угодно вьюх и pm. Тут уже всё зависит от мастерства декомозиции программиста. Связи между сущностями так же легко реализуются через контексты и реактивные переменные.
Расширение логической части
Добавим логику вращения куба по нажатию на уже имеющуюся кнопку.
Для это создадим ещё одну сущность и опишем в ней создание игрового объекта и его реакцию на нажатие кнопки. Для этого переменную buttonClickCounter  необходимо вынести на уровень выше в Game Entity и добавить её в контекст UIEntity.
Обновлённый класс Game Entity
Класс CubeEntity
В контекст созданной CubeEntity тоже входит переменная buttonClickCounter, которая доходит до CubePm. Там же на неё подписан метод задающий значение для другой реактивной переменной rotateAngle, на которую, в свою очередь, подписана CubeView. 
Обращу внимание что способы организации подписки в Pm и View различаются. Если внутри pm подписку достаточно добавить в список на “разрушение”, то внутри MonoBehaviour  вьюхи, подписке нужно указать, что она принадлежит именно этому объекту, реализовано с помощью .addTo(this). Такая привязка поможет уничтожить подписку вместе с GameObject, когда до этого дойдёт дело.
Класс CubePm
Класс CubeView
Итак, мы получили проект вот с такой структурой. Глядя на код не всегда получается представить описанную логику в виде схемы, а на на этом изображении хорошо понятен принцип организации сущностей в Composition root.
Скачать и посмотреть проект в рабочем состоянии можно тут.
Напоследок
Я знаю, что много чего не указал, например, можно добавить singleton проверку в классе root, чтобы уберечь корневой класс от дубликата или рассказать побольше о  возможностях UniRx, например, о создании реактивных событий. Но об этом, возможно, в другой раз. Здесь я хотел дать больше прикладного материала, о том как стартануть проект с нуля с понятной и устойчивой архитектурой.
В следующей части статьи я расскажу о том как можно в рамках composition root сменить значимые структуры на ссылочные интерфейсы глобального класса. Это имеет свои плюсы и минусы и как минимум, может быть интересно для изучения. Привет всем, кто неравнодушен к архитектурным решениям в рамках проектов на Unity и не только. Если вопрос выбора для вас ещё актуален или просто интересуетесь вариантами, то готов рассказать о реализации архитектуры Composition root с примерами простейшей логики. Здесь есть единая точка входа и Dependency Injection, то есть всё как мы любим. Сам я уже несколько лет придерживаюсь данной архитектуры и реализовал на ней не мало проектов, от ГК прототипов, до pvp игр.   Composition root представляет собой смесь моделей MVP и MVVM и активно использует шаблон Observer, в данной статье я не буду углубляться в суть этих терминов, а попробую наглядно показать как это работает. Реализация структуры проекта идёт через связку базовых понятий:  Entity - Presenter Model (PM) - View. Entity - сущность, отдельная логическая единица, служащая для создания PM и View и передающая им зависимости Entity Presenter Model - содержит бизнес логику, не имеющую отношение к Monobehaviour классам Presenter Model View - Gameobject на сцене View Путь от единой точки входа, до первой игровой сущности Посмотрим на практике, как сделать первые шаги. Создадим два объекта на сцене: пустой Canvas и GameObject Entry Point с компонентом на нём с таким же названием. Класс EntryPoint будет содержать совсем немного кода EntryPoint EntryPoint]]></text>
</doc>
