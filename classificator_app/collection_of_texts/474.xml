<?xml version="1.0" ?>
<doc>
	<label auto="true" type="str" verify="true"><![CDATA[Develop]]></label>
	<author auto="true" type="list" verify="true">
		<item type="str"><![CDATA[arthurshark]]></item>
	</author>
	<date auto="true" type="str" verify="true"><![CDATA[2022-12-02, 19:06]]></date>
	<link auto="true" type="str" verify="true"><![CDATA[https://habr.com/ru/post/703218/]]></link>
	<title auto="true" type="str" verify="true"><![CDATA[Заполнить виджет градиентом, изображением или гифкой с помощью ShaderMask]]></title>
	<categories auto="true" type="list" verify="true">
		<item type="str"><![CDATA[Разработка веб-сайтов]]></item>
		<item type="str"><![CDATA[Разработка мобильных приложений]]></item>
		<item type="str"><![CDATA[Интерфейсы]]></item>
		<item type="str"><![CDATA[Дизайн]]></item>
		<item type="str"><![CDATA[Flutter]]></item>
	</categories>
	<key_words auto="true" type="list" verify="true">
		<item type="str"><![CDATA[flutter]]></item>
		<item type="str"><![CDATA[ui]]></item>
		<item type="str"><![CDATA[программирование]]></item>
		<item type="str"><![CDATA[интерфейс]]></item>
		<item type="str"><![CDATA[разработка по]]></item>
		<item type="str"><![CDATA[how-to]]></item>
		<item type="str"><![CDATA[графика]]></item>
		<item type="str"><![CDATA[мобильная разработка]]></item>
		<item type="str"><![CDATA[веб-дизайн]]></item>
		<item type="str"><![CDATA[frontend]]></item>
	</key_words>
	<text auto="true" type="str" verify="true"><![CDATA[Один из наиболее популярных способов сделать элемент UI выразительным и аутентичным состоит в том, чтобы заполнить его картинкой, градиентом или анимированной гифкой.
Ниже приведен пример реализации данных эффектов на Flutter. Представленный подход будет работать с любым виджетом на всех поддерживаемых платформах. В качестве примера мы будем заполнять графикой Text.
План
Реализация будет идти по сценарию, предложенному командой разработчиков Flutter в серии видео "Widget of the Week".
Основные шаги для заполнения текста графикой:
Создать TextChild виджет для отображения текста.
Создать Shader с нашей кастомной графикой.
Применить Shader к TextChild с помощью ShaderMask.
Widget buildBeautifulText() {
  // 1. Create text child
  final textChild = TextChild();
  
  // 2. Create shader
  final shaderCallback = createShader();
  
  // 3. Apply shader to text child
  return ShaderMask(
    blendMode: BlendMode.srcIn,
    shaderCallback: shaderCallback,
    child: textChild,
  );
}
Кейс 1. Шейдер градиента
Заполнить виджет градиентом достаточно легко, и при удачном применении данного эффекта можно получить весьма впечатляющие результаты. Для реализации нам потребуется описать желаемый градиент и попросить его создать шейдер. Полученный шейдер можно сразу применить к дочернему виджету, используя ShaderMask.
// Create gradient shader
ShaderCallback gradientShader() {
  // Define linear gradient
  const gradient = LinearGradient(
    colors: [
      Colors.red,
      Colors.blue,
    ],
    begin: Alignment.topLeft,
    end: Alignment.bottomRight,
    tileMode: TileMode.mirror,
  );
  // Create shader
  final shaderCallback = gradient.createShader;
  return shaderCallback;
}

// Build text with gradient shader
Widget buildBeautifulText() {
  // 1. Create text child
  final textChild = TextChild();

  // 2. Create shader callback
  final shaderCallback = gradientShader();

  // 3. Apply shader to text child
  return ShaderMask(
    blendMode: BlendMode.srcIn,
    shaderCallback: shaderCallback,
    child: textChild,
  );
}
В примере мы использовали линейный градиент от красного к синему. Процесс можно также повторить с градиентами любого типа (Linear, Radial, Sweep).
Полный код для данного кейса можно посмотреть и запустить через DartPad.
Кейс 2. Шейдер изображения
В Flutter есть класс ImageShader, который позволяет создавать шейдеры для изображений. Для этого необходимо передать ему данные изображения.
Шаг 1. Создать ImageProvider
Мы будем использовать ImageProvider, чтобы получить данные изображения из любого доступного источника (сеть, assets, файл, память). ImageProvider поддерживает форматы JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP и WBMP.
// 1. Create ImageProvider
// JPEG
const jpegProvider = NetworkImage(
  'https://picsum.photos/1000',
);

// Animated GIF
const gifProvider = NetworkImage(
  'https://media.giphy.com/media/5VKbvrjxpVJCM/giphy.gif',
);
Шаг 2. Создать ImageShader для изображения
ImageProvider поставляет нам экземпляры класса Image из пакета dart:ui, которые мы можем передать в ImageShader, чтобы создать ShaderCallback. Данный колбэк создает шейдер с учетом границ поверхности, к которой он будет применен.
Мы заполним графикой весь прямоугольник. В этом процессе будем использовать преобразования матрицы Matrix4, чтобы изменить размер и отцентровать изображение.
Можно пойти альтернативным путем и вместо изменений матрицы изменить TileMode. Режимы mirror и repeat должны хорошо себя проявить при работе с повторяющимися узорами.
Код этого шага можно изменить, чтобы настроить сочетания Matrix4 и TileMode для реализации своего уникального дизайна.
// 2. Create image shader for given Rect size
ShaderCallback createImageShader(ui.Image image) {
  shaderCalback(Rect bounds) {
    // Calculate scale for X and Y sides
    final scaleX = bounds.width / image.width;
    final scaleY = bounds.height / image.height;
    final scale = max(scaleX, scaleY);
    // Calculate offset to center resized image
    final scaledImageWidth = image.width * scale;
    final sacledImageHeight = image.height * scale;
    final offset = Offset(
      (scaledImageWidth - bounds.width) / 2,
      (sacledImageHeight - bounds.height) / 2,
    );
    final matrix = Matrix4.identity()
      // Scale image
      ..scale(scale, scale)
      // Center horizontally and vertically
      ..leftTranslate(
        -offset.dx,
        -offset.dy,
      );
    // Image shader
    return ImageShader(
      image,
      TileMode.decal,
      TileMode.decal,
      matrix.storage,
    );
  }
Шаг 3. Подписаться на ImageStream
При использовании ImageProvider у нас есть возможность подписаться на ImageStream, который отслеживает текущий кадр изображения. Подписка на данный поток позволит нам реагировать на изменения изображения, которые происходят в результате анимаций или изменений исходного ресурса изображения.
Документация Flutter уже содержит код использования ImageStream в виджете. Нам остается лишь изменить его метод build и добавить поле child для дочернего виджета.
Добавляем поле child:
// See MyImage class from Flutter docs
// https://api.flutter.dev/flutter/painting/ImageProvider-class.html
class ImageShaderBuilder extends StatefulWidget {
  const ImageShaderBuilder({
    super.key,
    required this.imageProvider,
    // Add child widget
    required this.child,
  });

  // Add child widget
  final Widget child;
  final ImageProvider imageProvider;

  @override
  State<ImageShaderBuilder> createState() => _ImageShaderBuilderState();
}
Изменяем метод build:
// See MyImage class from Flutter docs
// https://api.flutter.dev/flutter/painting/ImageProvider-class.html
class _ImageShaderBuilderState extends State<ImageShaderBuilder> {
  
  // Keep the source code

  // Change only build method
  @override
  Widget build(BuildContext context) {
    final image = _imageInfo?.image;
    // No image for shader -> show child
    if (image == null) {
      return widget.child;
    }
    final shaderCallback = createImageShader(image);
    // Apply shader to the child
    return ShaderMask(
      blendMode: BlendMode.srcIn,
      shaderCallback: shaderCallback,
      child: widget.child,
    );
  }
}
Шаг 4. Использовать шейдер изображения
Теперь мы можем использовать ImageShaderBuilder для реализации ярких и запоминающихся пользовательских интерфейсов.
Widget buildBeautifulText() {
  // 1. Create text child
  const textChild = TextChild();

  // 2. Create ImageProvider
  const imageProvider = NetworkImage(
    'https://media.giphy.com/media/5VKbvrjxpVJCM/giphy.gif',
  );

  // 3. Apply shader to text child
  return const ImageShaderBuilder(
    imageProvider: imageProvider,
    child: textChild,
  );
}
Полный код для данного кейса можно посмотреть и запустить через DartPad.
Заключение
Благодарю за чтение!
Не стесняйтесь писать внизу свои мысли, предложения и пожелания по поводу данной статьи. Я буду рад учесть их в своих следующих публикациях, а также отвечу на любые вопросы в комментариях.
Ставьте лайки, если статья оказалась полезна.
Об авторе
Имя: Иван Мосягин (LinkedIn)
Компания: Shark Company (LinkedIn)
Должность: Flutter Developer    Один из наиболее популярных способов сделать элемент UI выразительным и аутентичным состоит в том, чтобы заполнить его картинкой, градиентом или анимированной гифкой. Ниже приведен пример реализации данных эффектов на Flutter. Представленный подход будет работать с любым виджетом на всех поддерживаемых платформах. В качестве примера мы будем заполнять графикой Text. План Реализация будет идти по сценарию, предложенному командой разработчиков Flutter в серии видео "Widget of the Week".  Основные шаги для заполнения текста графикой: Основные шаги для заполнения текста графикой: Создать TextChild виджет для отображения текста.
Создать Shader с нашей кастомной графикой.
Применить Shader к TextChild с помощью ShaderMask. Создать TextChild виджет для отображения текста. Создать TextChild виджет для отображения текста. Создать Shader с нашей кастомной графикой. Создать Shader с нашей кастомной графикой. Shader Применить Shader к TextChild с помощью ShaderMask. Применить Shader к TextChild с помощью ShaderMask. ShaderMask Widget buildBeautifulText() {
  // 1. Create text child
  final textChild = TextChild();
  
  // 2. Create shader
  final shaderCallback = createShader();
  
  // 3. Apply shader to text child
  return ShaderMask(
    blendMode: BlendMode.srcIn,
    shaderCallback: shaderCallback,
    child: textChild,
  );
} Widget buildBeautifulText() {
  // 1. Create text child
  final textChild = TextChild();
  
  // 2. Create shader
  final shaderCallback = createShader();
  
  // 3. Apply shader to text child
  return ShaderMask(
    blendMode: BlendMode.srcIn,
    shaderCallback: shaderCallback,
    child: textChild,
  );
} // 1. Create text child final // 2. Create shader final // 3. Apply shader to text child return Кейс 1. Шейдер градиента    Заполнить виджет градиентом достаточно легко, и при удачном применении данного эффекта можно получить весьма впечатляющие результаты. Для реализации нам потребуется описать желаемый градиент и попросить его создать шейдер. Полученный шейдер можно сразу применить к дочернему виджету, используя ShaderMask. // Create gradient shader
ShaderCallback gradientShader() {
  // Define linear gradient
  const gradient = LinearGradient(
    colors: [
      Colors.red,
      Colors.blue,
    ],
    begin: Alignment.topLeft,
    end: Alignment.bottomRight,
    tileMode: TileMode.mirror,
  );
  // Create shader
  final shaderCallback = gradient.createShader;
  return shaderCallback;
}

// Build text with gradient shader
Widget buildBeautifulText() {
  // 1. Create text child
  final textChild = TextChild();

  // 2. Create shader callback
  final shaderCallback = gradientShader();

  // 3. Apply shader to text child
  return ShaderMask(
    blendMode: BlendMode.srcIn,
    shaderCallback: shaderCallback,
    child: textChild,
  );
} // Create gradient shader
ShaderCallback gradientShader() {
  // Define linear gradient
  const gradient = LinearGradient(
    colors: [
      Colors.red,
      Colors.blue,
    ],
    begin: Alignment.topLeft,
    end: Alignment.bottomRight,
    tileMode: TileMode.mirror,
  );
  // Create shader
  final shaderCallback = gradient.createShader;
  return shaderCallback;
}

// Build text with gradient shader
Widget buildBeautifulText() {
  // 1. Create text child
  final textChild = TextChild();

  // 2. Create shader callback
  final shaderCallback = gradientShader();

  // 3. Apply shader to text child
  return ShaderMask(
    blendMode: BlendMode.srcIn,
    shaderCallback: shaderCallback,
    child: textChild,
  );
} // Create gradient shader // Define linear gradient const // Create shader final return // Build text with gradient shader // 1. Create text child final // 2. Create shader callback final // 3. Apply shader to text child return В примере мы использовали линейный градиент от красного к синему. Процесс можно также повторить с градиентами любого типа (Linear, Radial, Sweep). Linear Radial Sweep Полный код для данного кейса можно посмотреть и запустить через DartPad. DartPad Кейс 2. Шейдер изображения   В Flutter есть класс ImageShader, который позволяет создавать шейдеры для изображений. Для этого необходимо передать ему данные изображения. ImageShader данные изображения Шаг 1. Создать ImageProvider Шаг 1. Создать ImageProvider Мы будем использовать ImageProvider, чтобы получить данные изображения из любого доступного источника (сеть, assets, файл, память). ImageProvider поддерживает форматы JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP и WBMP. ImageProvider данные изображения сеть assets файл память JPEG PNG GIF Animated GIF WebP Animated WebP BMP WBMP // 1. Create ImageProvider
// JPEG
const jpegProvider = NetworkImage(
  'https://picsum.photos/1000',
);

// Animated GIF
const gifProvider = NetworkImage(
  'https://media.giphy.com/media/5VKbvrjxpVJCM/giphy.gif',
); // 1. Create ImageProvider
// JPEG
const jpegProvider = NetworkImage(
  'https://picsum.photos/1000',
);

// Animated GIF
const gifProvider = NetworkImage(
  'https://media.giphy.com/media/5VKbvrjxpVJCM/giphy.gif',
); // 1. Create ImageProvider // JPEG const 'https://picsum.photos/1000' // Animated GIF const 'https://media.giphy.com/media/5VKbvrjxpVJCM/giphy.gif' Шаг 2. Создать ImageShader для изображения Шаг 2. Создать ImageShader для изображения ImageProvider поставляет нам экземпляры класса Image из пакета dart:ui, которые мы можем передать в ImageShader, чтобы создать ShaderCallback. Данный колбэк создает шейдер с учетом границ поверхности, к которой он будет применен. Image dart:ui ShaderCallback Мы заполним графикой весь прямоугольник. В этом процессе будем использовать преобразования матрицы Matrix4, чтобы изменить размер и отцентровать изображение. Matrix4 Можно пойти альтернативным путем и вместо изменений матрицы изменить TileMode. Режимы mirror и repeat должны хорошо себя проявить при работе с повторяющимися узорами. TileMode mirror repeat Код этого шага можно изменить, чтобы настроить сочетания Matrix4 и TileMode для реализации своего уникального дизайна. // 2. Create image shader for given Rect size
ShaderCallback createImageShader(ui.Image image) {
  shaderCalback(Rect bounds) {
    // Calculate scale for X and Y sides
    final scaleX = bounds.width / image.width;
    final scaleY = bounds.height / image.height;
    final scale = max(scaleX, scaleY);
    // Calculate offset to center resized image
    final scaledImageWidth = image.width * scale;
    final sacledImageHeight = image.height * scale;
    final offset = Offset(
      (scaledImageWidth - bounds.width) / 2,
      (sacledImageHeight - bounds.height) / 2,
    );
    final matrix = Matrix4.identity()
      // Scale image
      ..scale(scale, scale)
      // Center horizontally and vertically
      ..leftTranslate(
        -offset.dx,
        -offset.dy,
      );
    // Image shader
    return ImageShader(
      image,
      TileMode.decal,
      TileMode.decal,
      matrix.storage,
    );
  } // 2. Create image shader for given Rect size
ShaderCallback createImageShader(ui.Image image) {
  shaderCalback(Rect bounds) {
    // Calculate scale for X and Y sides
    final scaleX = bounds.width / image.width;
    final scaleY = bounds.height / image.height;
    final scale = max(scaleX, scaleY);
    // Calculate offset to center resized image
    final scaledImageWidth = image.width * scale;
    final sacledImageHeight = image.height * scale;
    final offset = Offset(
      (scaledImageWidth - bounds.width) / 2,
      (sacledImageHeight - bounds.height) / 2,
    );
    final matrix = Matrix4.identity()
      // Scale image
      ..scale(scale, scale)
      // Center horizontally and vertically
      ..leftTranslate(
        -offset.dx,
        -offset.dy,
      );
    // Image shader
    return ImageShader(
      image,
      TileMode.decal,
      TileMode.decal,
      matrix.storage,
    );
  } // 2. Create image shader for given Rect size // Calculate scale for X and Y sides final final final // Calculate offset to center resized image final final final 2 2 final // Scale image // Center horizontally and vertically // Image shader return Шаг 3. Подписаться на ImageStream Шаг 3. Подписаться на ImageStream При использовании ImageProvider у нас есть возможность подписаться на ImageStream, который отслеживает текущий кадр изображения. Подписка на данный поток позволит нам реагировать на изменения изображения, которые происходят в результате анимаций или изменений исходного ресурса изображения. ImageStream Документация Flutter уже содержит код использования ImageStream в виджете. Нам остается лишь изменить его метод build и добавить поле child для дочернего виджета. код build child Добавляем поле child: child // See MyImage class from Flutter docs
// https://api.flutter.dev/flutter/painting/ImageProvider-class.html
class ImageShaderBuilder extends StatefulWidget {
  const ImageShaderBuilder({
    super.key,
    required this.imageProvider,
    // Add child widget
    required this.child,
  });

  // Add child widget
  final Widget child;
  final ImageProvider imageProvider;

  @override
  State<ImageShaderBuilder> createState() => _ImageShaderBuilderState();
} // See MyImage class from Flutter docs
// https://api.flutter.dev/flutter/painting/ImageProvider-class.html
class ImageShaderBuilder extends StatefulWidget {
  const ImageShaderBuilder({
    super.key,
    required this.imageProvider,
    // Add child widget
    required this.child,
  });

  // Add child widget
  final Widget child;
  final ImageProvider imageProvider;

  @override
  State<ImageShaderBuilder> createState() => _ImageShaderBuilderState();
} // See MyImage class from Flutter docs // https://api.flutter.dev/flutter/painting/ImageProvider-class.html class ImageShaderBuilder extends StatefulWidget  class ImageShaderBuilder extends StatefulWidget const super required this // Add child widget required this // Add child widget final final @override Изменяем метод build: build // See MyImage class from Flutter docs
// https://api.flutter.dev/flutter/painting/ImageProvider-class.html
class _ImageShaderBuilderState extends State<ImageShaderBuilder> {
  
  // Keep the source code

  // Change only build method
  @override
  Widget build(BuildContext context) {
    final image = _imageInfo?.image;
    // No image for shader -> show child
    if (image == null) {
      return widget.child;
    }
    final shaderCallback = createImageShader(image);
    // Apply shader to the child
    return ShaderMask(
      blendMode: BlendMode.srcIn,
      shaderCallback: shaderCallback,
      child: widget.child,
    );
  }
} // See MyImage class from Flutter docs
// https://api.flutter.dev/flutter/painting/ImageProvider-class.html
class _ImageShaderBuilderState extends State<ImageShaderBuilder> {
  
  // Keep the source code

  // Change only build method
  @override
  Widget build(BuildContext context) {
    final image = _imageInfo?.image;
    // No image for shader -> show child
    if (image == null) {
      return widget.child;
    }
    final shaderCallback = createImageShader(image);
    // Apply shader to the child
    return ShaderMask(
      blendMode: BlendMode.srcIn,
      shaderCallback: shaderCallback,
      child: widget.child,
    );
  }
} // See MyImage class from Flutter docs // https://api.flutter.dev/flutter/painting/ImageProvider-class.html class _ImageShaderBuilderState extends State<ImageShaderBuilder>  class _ImageShaderBuilderState extends State ImageShaderBuilder // Keep the source code // Change only build method @override final // No image for shader -> show child if null return final // Apply shader to the child return Шаг 4. Использовать шейдер изображения Шаг 4. Использовать шейдер изображения Теперь мы можем использовать ImageShaderBuilder для реализации ярких и запоминающихся пользовательских интерфейсов. ImageShaderBuilder Widget buildBeautifulText() {
  // 1. Create text child
  const textChild = TextChild();

  // 2. Create ImageProvider
  const imageProvider = NetworkImage(
    'https://media.giphy.com/media/5VKbvrjxpVJCM/giphy.gif',
  );

  // 3. Apply shader to text child
  return const ImageShaderBuilder(
    imageProvider: imageProvider,
    child: textChild,
  );
} Widget buildBeautifulText() {
  // 1. Create text child
  const textChild = TextChild();

  // 2. Create ImageProvider
  const imageProvider = NetworkImage(
    'https://media.giphy.com/media/5VKbvrjxpVJCM/giphy.gif',
  );

  // 3. Apply shader to text child
  return const ImageShaderBuilder(
    imageProvider: imageProvider,
    child: textChild,
  );
} // 1. Create text child const // 2. Create ImageProvider const 'https://media.giphy.com/media/5VKbvrjxpVJCM/giphy.gif' // 3. Apply shader to text child return const Полный код для данного кейса можно посмотреть и запустить через DartPad. DartPad Заключение Благодарю за чтение! Не стесняйтесь писать внизу свои мысли, предложения и пожелания по поводу данной статьи. Я буду рад учесть их в своих следующих публикациях, а также отвечу на любые вопросы в комментариях. Ставьте лайки, если статья оказалась полезна. Об авторе Об авторе Имя: Иван Мосягин (LinkedIn)
Компания: Shark Company (LinkedIn)
Должность: Flutter Developer Имя: Иван Мосягин (LinkedIn) Имя: Иван Мосягин (LinkedIn) Имя: LinkedIn Компания: Shark Company (LinkedIn) Компания: Shark Company (LinkedIn) Компания: LinkedIn Должность: Flutter Developer Должность: Flutter Developer Должность: ]]></text>
</doc>
