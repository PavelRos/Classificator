<?xml version="1.0" ?>
<doc>
	<label auto="true" type="str" verify="true"><![CDATA[Other]]></label>
	<author auto="true" type="list" verify="true">
		<item type="str"><![CDATA[BosonBeard]]></item>
	</author>
	<date auto="true" type="str" verify="true"><![CDATA[2022-05-13, 15:03]]></date>
	<link auto="true" type="str" verify="true"><![CDATA[https://habr.com/ru/post/592025/]]></link>
	<title auto="true" type="str" verify="true"><![CDATA[«А поговорить?» или делаем звонок для подтверждения заказа в интернет магазине с помощью МТТ VoiceBox]]></title>
	<categories auto="true" type="list" verify="true">
		<item type="str"><![CDATA[API]]></item>
		<item type="str"><![CDATA[Интернет-маркетинг]]></item>
		<item type="str"><![CDATA[Облачные сервисы]]></item>
		<item type="str"><![CDATA[Голосовые интерфейсы]]></item>
		<item type="str"><![CDATA[Визуальное программирование]]></item>
	</categories>
	<key_words auto="true" type="list" verify="true">
		<item type="str"><![CDATA[голосовой движок]]></item>
		<item type="str"><![CDATA[wordpress]]></item>
		<item type="str"><![CDATA[woocommerce]]></item>
		<item type="str"><![CDATA[api]]></item>
		<item type="str"><![CDATA[бот]]></item>
		<item type="str"><![CDATA[php]]></item>
		<item type="str"><![CDATA[postman]]></item>
		<item type="str"><![CDATA[voicebox]]></item>
		<item type="str"><![CDATA[синтез речи]]></item>
		<item type="str"><![CDATA[распознавание речи]]></item>
	</key_words>
	<text auto="true" type="str" verify="true"><![CDATA[Экономическая ситуация нынче нестабильная, лишних денег у людей нет. И вот значится обратились ко мне товарищи со словами: "Ты же когда-то там сайты делал, помоги разобраться". После такой просьбы пришлось мне сдувать пыль вековую с постаревших связей нейронных, да бубен шаманский доставать.
Но не переживайте, эта статья не о том, как я спустя 12 лет снова сел ковырять сайты на PHP. Всё это банально и писать об этом на Хабр я бы не стал.
А вот, что мне действительно было интересно, так это поковыряться в настройках голосового бота. Никогда раньше с таким не сталкивался и настолько меня это увлекло, что по горячим следам начал писать статью.
Вы готовы загибать пальцы?
Итак, сегодня мы с вами:
Настроим сценарий голосового бота для подтверждения интернет заказа.
Одним глазом взглянем на API для управления ботом и отправим пару запросов через Postman.
Добавим пару кастомных действий в WooCommerce, чтобы робот вместо оператора разными голосами подтверждал заказ.
Немного забегая вперед, скажу, что у меня есть план сделать еще парочку статей на эту тему, поэтому сегодня мы с вами рассмотрим "минимальный набор", чтобы мне было о чем писать дальше.
Также, я должен сделать привычный дисклеймер:
"Я техпис, а не программист. поэтому все программные решения в этой статье, скорее всего являются далеко не лучшими практиками".
Ну вот с формальностями покончили можем смело приступать к делу.
Статья получилась объемная поэтому я оставлю оглавление:
Настройка сценария в личном кабинете
Блоки сценариев
Настройки кампании
Работа с API через Postman
Интеграция с WooCommerce (Wordpess)
Настройка сценария в личном кабинете
Первым делом, нам необходимо создать проект в личном кабинете MTT VoiceBox
Вопрос регистрации В ЛК я пропущу, потому что мне доступ уже предоставили и сам я не испил чашу регистрации в сервисе личного кабинета.

Также я пропущу описание некоторых очевидных шагов. У разработчиков в Wiki есть инструкция по работе с личным кабинетом и я не буду её дублировать.
После входа в личный кабинет, перейдем на вкладку "Сценарии" и нажмем кнопку "Создание сценария"
Страница "Сценарии"
Мы не будем использовать сложные шаблоны, а просто создадим сценарий для исходящих звонков.
Перед нашим взором предстанет окно редактора сценариев. Редактор интуитивно понятен.
Сверху диаграмма сразу после создания, снизу состояние при добавлении первого блока "Проигрыватель"
Принцип работы такой: берем с правой панели блоки, кликаем два раза чтобы добавить их в рабочую область и для выбранного блока настраиваем его параметры.
Для меня стало некоторым неудобством то, что нельзя потянуть мышкой связи от одного блока к другому (актуально на декабрь 2021), приходится выбирать следующий шаг для блока в панели свойств. Правда со временем к этому привыкаешь.
Для каждого блока можно посмотреть подсказку.
Сохранить изменения в блоке можно только после того, как корректно заполнены все обязательные поля.
Давайте посмотрим на итоговый сценарий:
Итоговый сценарий
Всего 10 блоков. Вы можете достаточно быстро повторить его самостоятельно.
Но для тех кому не терпится поскорее попробовать, я оставлю в GitHub возможность быстро клонировать сценарий аж целыми двумя способами:
через специальную ссылку;
через запрос к API;
Прежде чем посмотреть настройки каждого блока расскажу вам о еще одной особенности редактора, на линиях связи между блоками указано в каком случае связь будет активна (например, "Успешно", 'Лимит").
В случае, когда для одной связи назначено несколько условий, то будет показано только один статус, для примера выше "Лимит", поэтому не удивляйтесь если не увидите на схеме каких-то связей.
Давайте пройдемся по всем блокам. Я оставлю везде скриншоты настроек, чтобы вы могли свериться.
Блоки сценария
Исходящий сценарий
Самый первый блок нашего сценария. Устанавливается автоматически.
В этом блоке можно добавить переменные, передаваемые через тело POST запроса к API. Как вы увидите позже переменные могут быть массивами, например goods.
Еще в настройках блока можно выбрать голос бота (есть и мужские и женские).
Далее идет следующий шаг сценария в случае успешного завершения блока, в данном случае мы перейдем на блок "Вызов".
Я рекомендую давать блокам осмысленные названия, потому что в противном случае будет очень легко запутаться при выборе между: "Состояние 5" и "Состояние 7".
В дальнейшем я не буду подробно останавливаться на блоках перехода, потому что логика везде похожа.
"Исходящий сценарий"
Исходящий вызов ("Вызов")
Блок, который непосредственно совершит звонок на номер клиента.
Опция "Номер из кампании" позволит нам выбрать любой номер, который мы позже вызовем через API.
Перейдем к блоку "Проигрыватель".
Исходящий вызов (Вызов)
Проигрыватель ("Зачитать список товаров")
Блок проигрывает абоненту заданное сообщение
Можно заранее подготовить медиа файл (это мы отложим на другой раз), а можно просто зачитать текст голосом, добавив переменные из блока "Исходящий сценарий".
Переменные в тексте выделяются двойными фигурными скобками, например, {{name}}. Как вы, уже догадались, робот в данном месте проговорит переменную name из POST запроса.
Для меня оказалось приятной неожиданностью, то что робот умеет читать числительные. Таким образом, отправленные мной в поле total10000, были прочитаны именно как десять тысяч, а не "один - ноль - ноль - ноль - ноль - ноль".
Блок похоже умеет распознавать автоответчики, но мне пока было не на чем проверить этот функционал.
Но я всё равно решил его сделать для демонстрации отправки HTTP запроса в случае негативного сценария. К описанию блока "Неуспех" мы придем, ближе к концу раздела, а пока перейдем дальше по успешному пути.
Проигрыватель ("Зачитать список товаров")
Интерактивный ввод ("Подтверждение")
Интерактивное меню, отвечает за пользовательский ввод.
Пользователь может осуществить ввод несколькими способами:
с помощью клавиатуры телефона;
голосом;
комбинацией первых двух способов;
Мне показался любопытным именно вариант с голосом.
В данном случае можно самостоятельно подобрать слова (с учётом маски), а можно выбрать готовый набор ответов, как в итоге сделал я.
Рекомендую оставить пользователю голосовое сообщение, о том что надо подтвердить заказ.
После данного блока у нас намечается еще одно ветвление.
Допустим пользователь не может нам ответить, что-то внятное за 10 секунд, тогда мы переключим его на живого оператора, но об этом также ближе к концу раздела.
А пока мы пойдем к следующему блоку по успешному пути.
Интерактивный ввод ("Подтверждение")
HTTP (Обновить статус)
Данный блок отправляет запрос в интернет-магазин на обновление статуса заказа. Мы будем использовать WooCommerce и соответственного его API. После выполнения запроса в магазине статус заказа изменится на "Заказ подтвержден".
По сути, блок просто представляет поля для сборки запроса. На всякий случай предупрежу, что я проверял отправку запроса из сценария, только для случая, когда магазин имеет сертификат безопасности и следовательно мы обращаемся к нему через "https". С обычным "http" у WooCommerce есть некоторые сложности, с которыми я не хотел бороться.
В принципе параметры запроса я брал из экспорта в cURL через Postman, о чем немного подробнее будет рассказано в следующем разделе.
Обратите внимание, что в параметрах пути запроса, мы можем использовать переменную. В данном случае orderid, которую мы ранее передали в исходящем запросе.
Я не стал усложнять и продумывать действия в случае неудачного запроса.
После успешного HTTP запроса нам остается только попрощаться с клиентом.
HTTP (Обновить статус)
Проигрыватель ("Спасибо за подтверждение")
Аналогичный блок мы уже разбирали, поэтому просто оставлю скрин параметров.
Осталось только повесить трубку.
Отбой
Поскольку я уже слегка устал к седьмому по счету блоку, этот блок один из моих любимых.
Проходите дальше, тут не на что смотреть, мы просто положим трубку.
Отбой
На этом успешный путь завершен. Давайте рассмотрим случай, когда пользователь не смог справиться с интерактивным вводом.
Проигрыватель ("Дождитесь оператора")
Просто предупредим пользователя, что ему не стоит класть трубку пока мы соединяем его с оператором.
Проигрыватель ("Дождитесь оператора")
Переадресация ("Звонок оператору")
В данном блоке мы можем перенаправить вызов оператору. Если честно, этот блок я тоже не тестировал, потому что пока не было такой цели. Но наверняка, все будет работать.
После переадресации по идее этот вызов должен завершиться на блоке "Отбой".
Переадресация ("Звонок оператору")
Остался последний "неуспешный" блок.
HTTP ("Неуспех")
Запрос практически полностью идентичен "успешному" HTTP запросу, с разницей только в статусе заказа, который мы после запроса изменим на "Нужен звонок".
HTTP ("Неуспех")
Настройки кампании
Для того, чтобы отправлять запрос к API нам необходимо знать, параметры авторизации и значение поля method. Для этого надо создать кампанию.
Перейдём на вкладку "Кампании"
Создадим новую, кампанию и выберем в её настройках опцию "Запуск - по HTTP запросу".
Остальные параметры, интуитивно понятны.

Вот так выглядит кампания для нашего сценария.
Страница настроек кампании
Само собой ключевые значения я замазал, но в целом можно понять, откуда брать данные для запроса к API.
Есть один важный момент. Как я понял, после привязки сценария к кампании, многие его параметры нельзя будет изменить пока кампания не удалена. Например, нельзя будет удалить блок, или добавить новый. Зато можно будет изменить голос робота. Именно, этим мы с вами воспользуемся в следующих разделах.
Работа с API через Postman
При написании статьи я ориентировался на эту версию документации от разработчиков.
Для вашего удобства я собрал в Postman коллекцию тех методов, которые мы используем для статьи.
На всякий случай помимо методов Voicebox я добавил пару методов для проверки API WooCommerce.
Скачать коллекцию и окружение можно в GitHub.
Не забудьте в окружении указать ваши значения для переменных, потому что свои данные я удалил.
Собственно дальше, мы будем ориентироваться именно на коллекцию в Postman.Как я уже говорил выше, логин, пароль и метод можно найти на странице кампании, с которой мы связали наш сценарий.
Запрос на звонок
Наверняка у вас уже горят руки наконец-то попробовать звонок. Не будем откладывать это дело в долгий ящик.
Звонок, это самое простое. Нам надо отправить POST запрос на адрес
https://voicebox.mtt.ru/v1/sb, выбрав базовую авторизацию с указанием логина и пароля из настроек кампании.
Вот как это выглядит в Postman
Пример запроса в Postman
Вот пример cURL запроса (не забудьте подставить свои данные):
curl -L -X POST 'https://voicebox.mtt.ru/api/v1/sb' -H 'Authorization: Basic some_token' -H 'Content-Type: application/json' --data-raw '{
    "method": "10dXXXXXXXXXXXXXXXXXXXbe1",
    "data": {
        "number": "796NNNNNNNN",
        "goods": [
            "Tapki",
            "Kepka"
        ],
        "name": "Roman",
        "total":10000,
        "orderid":17
    }
}'
В ответ метод вернёт, какой-то ID, возможно это ID запроса на звонок (я так и не понял из документации).
Но самое главное, что нам позвонит робот и проговорит то, что мы ожидаем услышать.
Создание сценария
В первой главе статьи я обещал, что покажу, как клонировать сценарий через запрос к API.
Но есть одна маленькая трудность, мы не знаем наш customerID, ну по крайней мере мне его "заказчик" не дал.
Я не стал мучать техподдержку разработчиков, тем более, что личный кабинет оформлен не на меня, поэтому просто воспользовался старой доброй консолью разработчика.
Открываем страницу со сценариями, а в консоли разработчика (я использую Chrome) вкладку "Network".
Забираем customerID (подчеркнуто синим) из Request URL запроса к методу scenarios.
Есть еще одна вещь, которая нам пригодится. У меня почему-то не работает для этого метода базовая авторизация, API ругается, что нет поля token.
Я думаю, это однажды поправят, а пока просто заберем token из authorization (подчеркнуто синим). Теперь вместо, Basic Auth используем Bearer token.
Метод создаст сценарий и вернет нам всю его структуру вместе с ID.
cUrl запрос спрячу под спойлер.
cURL запрос на создание
Обновление сценария
Обновление делается аналогично, только с методом PUT.
Я решил не маяться с обязательными / необязательными параметрами, а просто взять все поля из прошлого ответа.
Нас будет волновать только замена этого фрагмента:
 "settings": {
        "voice": "omazh",
        "speed": 1,
        "emotion": "neutral"
    },
Будем менять голос робота (значение поля voice) на "oksana" или "filipp".
Пример запроса в cURL, я приводить не буду он есть в коллекции Postman, а также внутри одной из функций следующего раздела.
Думаю, пора переходить к завершающей стадии.
Интеграция с WooCommerce (WordPress)
Интеграция — это конечно громко сказано.
Мы просто добавим пару новых статусов, чтобы их мог менять наш бот, а также добавим пару действий, чтоб менять голос бота на мужской и женский.
Такая вот конвергенция двух систем.
Я не буду вдаваться в подробности установки WordPress и WooCommerce.
На момент написания статьи я использовал:
WooCommerce - версия 5.9.0
WordPress - версия 5.8.2
Первым делом добавим новые статусы в файл functions.php текущей темы.
Напомню, что отредактировать этот файл можно через настройки перейдя в раздел
"Внешний вид" -> "Редактор тем" и открыв "Функции темы".
Вы можете просто забрать код из GitHub и вставить фрагмент, куда-нибудь в конец файла.
Вначале статьи я уже говорил, что я не программист, но не грех будет напомнить.
Я если честно, последний раз смотрел на код на PHP лет 12 назад, а с WordPress и вовсе не работал толком никогда, поэтому не буду врать, я просто позаимствовал код отсюда и адаптировал под себя.
Код под спойлером
Как я понимаю мы вначале создаем сущности для новых статусов, а потом добавляем их в лист-бокс. Не забудьте сохранить обновления.
Теперь наш сценарий полностью укомплектован, мы можем позвонить через Postman и статусы поменяются.
Но нам явно не хватает возможности сделать вызов через админ-панель WooCommerce.
Добавьте данный код ниже:
Код под спойлером
Тут код тоже далеко не весь мой. Я взял сами действия тут, а запросы к API просто экспортировал из Postman, добавив в разрывы текста нужные данные.
Остался последний шаг - добавить возможность изменять голос бота из админ-панели.
Мне было лень разбираться с обязательными и необязательными полями в запросе на обновление сценария, поэтому я просто экспортировал его из Postman и добавил смену голоса бота в разрыв текста.
Код под спойлером
Должно получиться примерно вот так:
Новые действия и новый статус в админ-панели WooCommerce
Если выбрать "Звонок бота", то на номер из заказа позвонит бот и скажет дословно "Здравствуйте Роман, Вы заказали: кот в мешке, крот в горшке, на сумму 120 рублей. Вы подтверждаете заказ?".
Ну и само собой мы можем теперь изменить голос бота кнопками "Мужской (женский) голос у бота".
Миссия успешно выполнена.
В благодарность за то, что я показал людям, как работать с голосовым ботом, мне пообещали дать поиграться с ним в свое удовольствие. Так что я думаю написать еще 1–2 статьи по данной теме.
Спасибо всем, кто дочитал до конца, если будут ошибки или битые ссылки пишите мне в "личку" или в комментарии.   Экономическая ситуация нынче нестабильная, лишних денег у людей нет. И вот значится обратились ко мне товарищи со словами: "Ты же когда-то там сайты делал, помоги разобраться". После такой просьбы пришлось мне сдувать пыль вековую с постаревших связей нейронных, да бубен шаманский доставать. Но не переживайте, эта статья не о том, как я спустя 12 лет снова сел ковырять сайты на PHP. Всё это банально и писать об этом на Хабр я бы не стал. А вот, что мне действительно было интересно, так это поковыряться в настройках голосового бота. Никогда раньше с таким не сталкивался и настолько меня это увлекло, что по горячим следам начал писать статью. голосового бота Вы готовы загибать пальцы? Итак, сегодня мы с вами: Настроим сценарий голосового бота для подтверждения интернет заказа.
Одним глазом взглянем на API для управления ботом и отправим пару запросов через Postman.
Добавим пару кастомных действий в WooCommerce, чтобы робот вместо оператора разными голосами подтверждал заказ. Настроим сценарий голосового бота для подтверждения интернет заказа. Настроим сценарий голосового бота для подтверждения интернет заказа. Одним глазом взглянем на API для управления ботом и отправим пару запросов через Postman. Одним глазом взглянем на API для управления ботом и отправим пару запросов через Postman. Добавим пару кастомных действий в WooCommerce, чтобы робот вместо оператора разными голосами подтверждал заказ. Добавим пару кастомных действий в WooCommerce, чтобы робот вместо оператора разными голосами подтверждал заказ. Немного забегая вперед, скажу, что у меня есть план сделать еще парочку статей на эту тему, поэтому сегодня мы с вами рассмотрим "минимальный набор", чтобы мне было о чем писать дальше. Также, я должен сделать привычный дисклеймер:
"Я техпис, а не программист. поэтому все программные решения в этой статье, скорее всего являются далеко не лучшими практиками".  Ну вот с формальностями покончили можем смело приступать к делу.
Статья получилась объемная поэтому я оставлю оглавление:  оглавление Настройка сценария в личном кабинете
Блоки сценариев
Настройки кампании
Работа с API через Postman
Интеграция с WooCommerce (Wordpess) Настройка сценария в личном кабинете
Блоки сценариев
Настройки кампании Настройка сценария в личном кабинете Настройка сценария в личном кабинете  Блоки сценариев
Настройки кампании Блоки сценариев Блоки сценариев Блоки сценариев Настройки кампании Настройки кампании Настройки кампании Работа с API через Postman Работа с API через Postman Работа с API через Postman Интеграция с WooCommerce (Wordpess) Интеграция с WooCommerce (Wordpess) Интеграция с WooCommerce (Wordpess)   Настройка сценария в личном кабинете Первым делом, нам необходимо создать проект в личном кабинете MTT VoiceBox
Вопрос регистрации В ЛК я пропущу, потому что мне доступ уже предоставили и сам я не испил чашу регистрации в сервисе личного кабинета.

Также я пропущу описание некоторых очевидных шагов. У разработчиков в Wiki есть инструкция по работе с личным кабинетом и я не буду её дублировать.    инструкция по работе с личным кабинетом После входа в личный кабинет, перейдем на вкладку "Сценарии" и нажмем кнопку "Создание сценария" Создание сценария  Страница "Сценарии" Мы не будем использовать сложные шаблоны, а просто создадим сценарий для исходящих звонков.
Перед нашим взором предстанет окно редактора сценариев. Редактор интуитивно понятен.   Сверху диаграмма сразу после создания, снизу состояние при добавлении первого блока "Проигрыватель" Принцип работы такой: берем с правой панели блоки, кликаем два раза чтобы добавить их в рабочую область и для выбранного блока настраиваем его параметры.  Для меня стало некоторым неудобством то, что нельзя потянуть мышкой связи от одного блока к другому (актуально на декабрь 2021), приходится выбирать следующий шаг для блока в панели свойств. Правда со временем к этому привыкаешь. (актуально на декабрь 2021) Для каждого блока можно посмотреть подсказку. Сохранить изменения в блоке можно только после того, как корректно заполнены все обязательные поля. Давайте посмотрим на итоговый сценарий:  Итоговый сценарий Всего 10 блоков. Вы можете достаточно быстро повторить его самостоятельно. Но для тех кому не терпится поскорее попробовать, я оставлю в GitHub возможность быстро клонировать сценарий аж целыми двумя способами: GitHub GitHub  через специальную ссылку;
через запрос к API; через специальную ссылку; через специальную ссылку; через запрос к API; через запрос к API; Прежде чем посмотреть настройки каждого блока расскажу вам о еще одной особенности редактора, на линиях связи между блоками указано в каком случае связь будет активна (например, "Успешно", 'Лимит"). В случае, когда для одной связи назначено несколько условий, то будет показано только один статус, для примера выше "Лимит", поэтому не удивляйтесь если не увидите на схеме каких-то связей. Давайте пройдемся по всем блокам. Я оставлю везде скриншоты настроек, чтобы вы могли свериться.  Блоки сценария Исходящий сценарий Самый первый блок нашего сценария. Устанавливается автоматически.
В этом блоке можно добавить переменные, передаваемые через тело POST запроса к API. Как вы увидите позже переменные могут быть массивами, например goods.  goods . Еще в настройках блока можно выбрать голос бота (есть и мужские и женские). Далее идет следующий шаг сценария в случае успешного завершения блока, в данном случае мы перейдем на блок "Вызов". "Вызов" Я рекомендую давать блокам осмысленные названия, потому что в противном случае будет очень легко запутаться при выборе между: "Состояние 5" и "Состояние 7".
В дальнейшем я не буду подробно останавливаться на блоках перехода, потому что логика везде похожа.   "Исходящий сценарий" Исходящий вызов ("Вызов") Блок, который непосредственно совершит звонок на номер клиента.
Опция "Номер из кампании" позволит нам выбрать любой номер, который мы позже вызовем через API.  Перейдем к блоку "Проигрыватель". "Проигрыватель"  Исходящий вызов (Вызов)  Проигрыватель ("Зачитать список товаров") Блок проигрывает абоненту заданное сообщение
Можно заранее подготовить медиа файл (это мы отложим на другой раз), а можно просто зачитать текст голосом, добавив переменные из блока "Исходящий сценарий".  Исходящий сценарий Переменные в тексте выделяются двойными фигурными скобками, например, {{name}}. Как вы, уже догадались, робот в данном месте проговорит переменную name из POST запроса. {{name}}. name Для меня оказалось приятной неожиданностью, то что робот умеет читать числительные. Таким образом, отправленные мной в поле total10000, были прочитаны именно как десять тысяч, а не "один - ноль - ноль - ноль - ноль - ноль". total Блок похоже умеет распознавать автоответчики, но мне пока было не на чем проверить этот функционал. Но я всё равно решил его сделать для демонстрации отправки HTTP запроса в случае негативного сценария. К описанию блока "Неуспех" мы придем, ближе к концу раздела, а пока перейдем дальше по успешному пути. "Неуспех"  Проигрыватель ("Зачитать список товаров") Интерактивный ввод ("Подтверждение") Интерактивное меню, отвечает за пользовательский ввод. Пользователь может осуществить ввод несколькими способами: с помощью клавиатуры телефона;
голосом;
комбинацией первых двух способов; с помощью клавиатуры телефона; с помощью клавиатуры телефона; голосом; голосом; комбинацией первых двух способов; комбинацией первых двух способов; Мне показался любопытным именно вариант с голосом. В данном случае можно самостоятельно подобрать слова (с учётом маски), а можно выбрать готовый набор ответов, как в итоге сделал я. Рекомендую оставить пользователю голосовое сообщение, о том что надо подтвердить заказ. После данного блока у нас намечается еще одно ветвление. Допустим пользователь не может нам ответить, что-то внятное за 10 секунд, тогда мы переключим его на живого оператора, но об этом также ближе к концу раздела. А пока мы пойдем к следующему блоку по успешному пути.  Интерактивный ввод ("Подтверждение") HTTP (Обновить статус) Данный блок отправляет запрос в интернет-магазин на обновление статуса заказа. Мы будем использовать WooCommerce и соответственного его API. После выполнения запроса в магазине статус заказа изменится на "Заказ подтвержден". По сути, блок просто представляет поля для сборки запроса. На всякий случай предупрежу, что я проверял отправку запроса из сценария, только для случая, когда магазин имеет сертификат безопасности и следовательно мы обращаемся к нему через "https". С обычным "http" у WooCommerce есть некоторые сложности, с которыми я не хотел бороться. некоторые сложности В принципе параметры запроса я брал из экспорта в cURL через Postman, о чем немного подробнее будет рассказано в следующем разделе. Обратите внимание, что в параметрах пути запроса, мы можем использовать переменную. В данном случае orderid, которую мы ранее передали в исходящем запросе. orderid Я не стал усложнять и продумывать действия в случае неудачного запроса. После успешного HTTP запроса нам остается только попрощаться с клиентом.  HTTP (Обновить статус) Проигрыватель ("Спасибо за подтверждение") Аналогичный блок мы уже разбирали, поэтому просто оставлю скрин параметров. Осталось только повесить трубку.   Отбой Поскольку я уже слегка устал к седьмому по счету блоку, этот блок один из моих любимых.
Проходите дальше, тут не на что смотреть, мы просто положим трубку.   Отбой На этом успешный путь завершен. Давайте рассмотрим случай, когда пользователь не смог справиться с интерактивным вводом. Проигрыватель ("Дождитесь оператора") Просто предупредим пользователя, что ему не стоит класть трубку пока мы соединяем его с оператором.  Проигрыватель ("Дождитесь оператора") Переадресация ("Звонок оператору") В данном блоке мы можем перенаправить вызов оператору. Если честно, этот блок я тоже не тестировал, потому что пока не было такой цели. Но наверняка, все будет работать. После переадресации по идее этот вызов должен завершиться на блоке "Отбой". "Отбой"  Переадресация ("Звонок оператору") Остался последний "неуспешный" блок. HTTP ("Неуспех") Запрос практически полностью идентичен "успешному" HTTP запросу, с разницей только в статусе заказа, который мы после запроса изменим на "Нужен звонок".  HTTP ("Неуспех")  Настройки кампании Для того, чтобы отправлять запрос к API нам необходимо знать, параметры авторизации и значение поля method. Для этого надо создать кампанию. method. Перейдём на вкладку "Кампании" Создадим новую, кампанию и выберем в её настройках опцию "Запуск - по HTTP запросу". Остальные параметры, интуитивно понятны. Вот так выглядит кампания для нашего сценария.    Страница настроек кампании Само собой ключевые значения я замазал, но в целом можно понять, откуда брать данные для запроса к API. Есть один важный момент. Как я понял, после привязки сценария к кампании, многие его параметры нельзя будет изменить пока кампания не удалена. Например, нельзя будет удалить блок, или добавить новый. Зато можно будет изменить голос робота. Именно, этим мы с вами воспользуемся в следующих разделах.  Работа с API через Postman При написании статьи я ориентировался на эту версию документации от разработчиков. эту версию документации от разработчиков Для вашего удобства я собрал в Postman коллекцию тех методов, которые мы используем для статьи. На всякий случай помимо методов Voicebox я добавил пару методов для проверки API WooCommerce. Скачать коллекцию и окружение можно в GitHub. GitHub GitHub . Не забудьте в окружении указать ваши значения для переменных, потому что свои данные я удалил. Собственно дальше, мы будем ориентироваться именно на коллекцию в Postman.Как я уже говорил выше, логин, пароль и метод можно найти на странице кампании, с которой мы связали наш сценарий. выше Запрос на звонок Наверняка у вас уже горят руки наконец-то попробовать звонок. Не будем откладывать это дело в долгий ящик. Звонок, это самое простое. Нам надо отправить POST запрос на адрес
https://voicebox.mtt.ru/v1/sb, выбрав базовую авторизацию с указанием логина и пароля из настроек кампании.  Вот как это выглядит в Postman  Пример запроса в Postman Вот пример cURL запроса (не забудьте подставить свои данные): curl -L -X POST 'https://voicebox.mtt.ru/api/v1/sb' -H 'Authorization: Basic some_token' -H 'Content-Type: application/json' --data-raw '{
    "method": "10dXXXXXXXXXXXXXXXXXXXbe1",
    "data": {
        "number": "796NNNNNNNN",
        "goods": [
            "Tapki",
            "Kepka"
        ],
        "name": "Roman",
        "total":10000,
        "orderid":17
    }
}' curl -L -X POST 'https://voicebox.mtt.ru/api/v1/sb' -H 'Authorization: Basic some_token' -H 'Content-Type: application/json' --data-raw '{
    "method": "10dXXXXXXXXXXXXXXXXXXXbe1",
    "data": {
        "number": "796NNNNNNNN",
        "goods": [
            "Tapki",
            "Kepka"
        ],
        "name": "Roman",
        "total":10000,
        "orderid":17
    }
}' В ответ метод вернёт, какой-то ID, возможно это ID запроса на звонок (я так и не понял из документации). Но самое главное, что нам позвонит робот и проговорит то, что мы ожидаем услышать. Создание сценария В первой главе статьи я обещал, что покажу, как клонировать сценарий через запрос к API. Но есть одна маленькая трудность, мы не знаем наш customerID, ну по крайней мере мне его "заказчик" не дал. Я не стал мучать техподдержку разработчиков, тем более, что личный кабинет оформлен не на меня, поэтому просто воспользовался старой доброй консолью разработчика. Открываем страницу со сценариями, а в консоли разработчика (я использую Chrome) вкладку "Network".   Забираем customerID (подчеркнуто синим) из Request URL запроса к методу scenarios. customerID Есть еще одна вещь, которая нам пригодится. У меня почему-то не работает для этого метода базовая авторизация, API ругается, что нет поля token. Я думаю, это однажды поправят, а пока просто заберем token из authorization (подчеркнуто синим). Теперь вместо, Basic Auth используем Bearer token.   Метод создаст сценарий и вернет нам всю его структуру вместе с ID. cUrl запрос спрячу под спойлер. cURL запрос на создание cURL запрос на создание    Обновление сценария Обновление делается аналогично, только с методом PUT. Я решил не маяться с обязательными / необязательными параметрами, а просто взять все поля из прошлого ответа. Нас будет волновать только замена этого фрагмента:  "settings": {
        "voice": "omazh",
        "speed": 1,
        "emotion": "neutral"
    },  "settings": {
        "voice": "omazh",
        "speed": 1,
        "emotion": "neutral"
    }, Будем менять голос робота (значение поля voice) на "oksana" или "filipp".   Пример запроса в cURL, я приводить не буду он есть в коллекции Postman, а также внутри одной из функций следующего раздела. Думаю, пора переходить к завершающей стадии.  Интеграция с WooCommerce (WordPress) Интеграция — это конечно громко сказано. Мы просто добавим пару новых статусов, чтобы их мог менять наш бот, а также добавим пару действий, чтоб менять голос бота на мужской и женский. Такая вот конвергенция двух систем. Я не буду вдаваться в подробности установки WordPress и WooCommerce. На момент написания статьи я использовал: WooCommerce - версия 5.9.0
WordPress - версия 5.8.2 WooCommerce - версия 5.9.0 WooCommerce - версия 5.9.0 WordPress - версия 5.8.2 WordPress - версия 5.8.2 Первым делом добавим новые статусы в файл functions.php текущей темы. Напомню, что отредактировать этот файл можно через настройки перейдя в раздел "Внешний вид" -> "Редактор тем" и открыв "Функции темы". Вы можете просто забрать код из GitHub и вставить фрагмент, куда-нибудь в конец файла. GitHub GitHub Вначале статьи я уже говорил, что я не программист, но не грех будет напомнить. Я если честно, последний раз смотрел на код на PHP лет 12 назад, а с WordPress и вовсе не работал толком никогда, поэтому не буду врать, я просто позаимствовал код отсюда и адаптировал под себя. отсюда Код под спойлером Код под спойлером     Как я понимаю мы вначале создаем сущности для новых статусов, а потом добавляем их в лист-бокс. Не забудьте сохранить обновления. Теперь наш сценарий полностью укомплектован, мы можем позвонить через Postman и статусы поменяются. Но нам явно не хватает возможности сделать вызов через админ-панель WooCommerce. Добавьте данный код ниже: Код под спойлером Код под спойлером     Тут код тоже далеко не весь мой. Я взял сами действия тут, а запросы к API просто экспортировал из Postman, добавив в разрывы текста нужные данные. тут Остался последний шаг - добавить возможность изменять голос бота из админ-панели. Мне было лень разбираться с обязательными и необязательными полями в запросе на обновление сценария, поэтому я просто экспортировал его из Postman и добавил смену голоса бота в разрыв текста. Код под спойлером Код под спойлером     Должно получиться примерно вот так:  Новые действия и новый статус в админ-панели WooCommerce Если выбрать "Звонок бота", то на номер из заказа позвонит бот и скажет дословно "Здравствуйте Роман, Вы заказали: кот в мешке, крот в горшке, на сумму 120 рублей. Вы подтверждаете заказ?". "Звонок бота" Ну и само собой мы можем теперь изменить голос бота кнопками "Мужской (женский) голос у бота". Миссия успешно выполнена. В благодарность за то, что я показал людям, как работать с голосовым ботом, мне пообещали дать поиграться с ним в свое удовольствие. Так что я думаю написать еще 1–2 статьи по данной теме. Спасибо всем, кто дочитал до конца, если будут ошибки или битые ссылки пишите мне в "личку" или в комментарии. ]]></text>
</doc>
