<?xml version="1.0" ?>
<doc>
	<original_author auto="true" type="list" verify="true">
		<item type="str"><![CDATA[Honey the codewitch]]></item>
	</original_author>
	<label auto="true" type="str" verify="true"><![CDATA[Other]]></label>
	<author auto="true" type="list" verify="true">
		<item type="str"><![CDATA[Bright_Translate]]></item>
	</author>
	<date auto="true" type="str" verify="true"><![CDATA[2022-10-07, 16:00]]></date>
	<link auto="true" type="str" verify="true"><![CDATA[https://habr.com/ru/company/ruvds/blog/691474/]]></link>
	<title auto="true" type="str" verify="true"><![CDATA[EspMon: мониторинг CPU и GPU с помощью T-Display S3]]></title>
	<categories auto="true" type="list" verify="true">
		<item type="str"><![CDATA[Блог компании RUVDS.com]]></item>
		<item type="str"><![CDATA[C++]]></item>
		<item type="str"><![CDATA[Интерфейсы]]></item>
		<item type="str"><![CDATA[C#]]></item>
		<item type="str"><![CDATA[Программирование микроконтроллеров]]></item>
	</categories>
	<key_words auto="true" type="list" verify="true">
		<item type="str"><![CDATA[ruvds_перевод]]></item>
		<item type="str"><![CDATA[С#]]></item>
		<item type="str"><![CDATA[C++]]></item>
		<item type="str"><![CDATA[мониторинг пк]]></item>
		<item type="str"><![CDATA[diy]]></item>
		<item type="str"><![CDATA[программирование]]></item>
	</key_words>
	<text auto="true" type="str" verify="true"><![CDATA[Я любительница Fallout 4. Эту игру можно расширять бесконечно, поэтому мне до сих пор, даже спустя семь лет, интересно к ней возвращаться. Я постоянно что-то или в неё добавляю, или изменяю.

Когда у меня, наконец, появилась 2080ti, я смогла запустить её в 4К. Игра пошла настолько легко, что я решила нагрузить её вычислениями, добавив по всему ландшафту густой лес. В конце концов, я заметила, что карточка зашумела и начала потеть.

Но мне хотелось мониторить нагрузку не только по шуму системы охлаждения, а забивать экран всякими наложениями я не люблю. Поэтому я достала свой миниатюрный T-Display S3 и решила реализовать всё это на нем.

Это устройство считывает данные о состоянии ПК с последовательного порта, используя сопутствующее приложение, установленное на компьютере. С помощью кнопок можно переключаться между показателями загруженности/температуры оборудования и его текущей частоты.

Скачать

приложение — 137.1 КБ (GitHub);
прошивка — 20.6 КБ (GitHub).

Что потребуется

T-Display S3, либо придётся адаптировать код под иное устройство.
PlatformIO. Хотя можно использовать и Arduino IDE, но тогда нужно будет внести кое-какие изменения, в основном переименовать и переместить некоторые файлы.
Windows 10/11 с правами администратора.
Visual Studio 2019 или новее, а также .NET Framework.

Пояснения

Весь проект состоит из двух частей: прошивки для T-Display и приложения для ПК.

Приложение для ПК использует Open Hardware Monitor для сбора информации о CPU и GPU каждую десятую долю секунды, периодически передавая собранную информацию через последовательный порт на подключённый T-Display.

За обработку графического отображения отвечает LVGL. Эта библиотека периодически запрашивает данные через последовательный порт, после чего обновляет дисплей, но не чаще одного раза в 0.1 сек.

Код

▍ Приложение для ПК

Это приложение выполнено в виде одиночного окна с возможностью выбора COM-порта. Пока что оно в этом плане продумано не лучшим образом, но для демонстрации работоспособности концепции вполне сойдёт. После выбора COM-порта код начинает прослушивать его в ожидании подключения дисплея.

При этом каждую десятую долю секунды приложение будет обновлять переменные членов, содержащие собранные показатели состояния оборудования.

Изначально код прослушивает последовательный порт в ожидании ‘#’ или ‘@’, которые перехватывает из SerialPort.DataReceived. При обнаружении ‘#’ он отправляет четыре значения с плавающей запятой, отражающие показатели загрузки и температуры CPU и GPU. Если же на порт поступает ‘@’, код отправляет частоты CPU и GPU. В случае обнаружения чего-то другого он просто считывает все ожидающие данные. Дело в том, что при запуске T-Display отправляет на порт не относящуюся к делу информацию – по сути, post message.

Вот основной код для коммуникации через порт со стороны ПК:

Считывание данных


Помимо уже описанного, мы видим, что он также обрабатывает системы адресации с обратным порядком байтов. Эта функция в данном случае необязательна, так как мы работаем с традиционным приложением Windows NET. Framework, но для меня это уже инстинктивное решение. К тому же если в дальнейшем код потребуется использовать где-то ещё, оно будет готов обработать все сценарии.

У моей реализации коммуникации есть ещё один аспект, связанный с получением списка COM-портов. Сама эта процедура довольно проста. Достаточно просто их пронумеровать и добавить в общий список. Но вот выбор порта выполняется несколько странным путём. Для этого мы (начиная с последнего доступного), открываем их все по очереди, проверяя каждый на доступность и останавливаясь при обнаружении такового.

Обнаружение порта


Наконец, последней важной частью является происходящий по таймеру сбор информации о состоянии оборудования:

Сбор информации


Это всё, о чём стоило сказать в отношении кода приложения. В остальном он вполне рутинный.

Прошивка T-Display S3

Примечание: перед компиляцией прошивки вам нужно будет сначала скопировать libdeps/include/lv_conf.h в подкаталог /.pio/libdeps, иначе она не скомпилируется.

Настройка по большому счёту — стандартная и окажется однообразной для практически всех приложений. По сути, здесь мы устанавливаем драйвер дисплея, подключаем его к LVGL, инициализируем сам дисплей и активируем мост USB Serial:

Настройка


В приведённом коде есть один странный нюанс – использование одних и тех же буферов для холстов на обоих экранах. Дело в том, что одновременно он нам нужен только один, поэтому содержимое памяти можно переиспользовать.

Выполняется же всё в loop():

static int ticker = 0;
void loop() {
    button_prev.update();
    button_next.update();
    if (ticker++ >= 33) {
        ticker = 0;
        switch (screen) {
            case 0:
                update_screen_0();
            break;
            case 1:
                update_screen_1();
            break;
        }
    }

    lv_timer_handler();
    delay(3);
}

Сначала мы даём возможность сработать кнопкам. Затем каждую десятую долю секунды начинает выполняться обновление текущего экрана, после чего действие предоставляется LVGL.

Наконец, само обновление экрана. Для первого мы просто считываем показания загруженности и температуры оборудования, если на порту эти данные представлены. Считанными значениями мы обновляем индикаторы CPU и GPU, добавляя их в буферы cpu_graph и gpu_graph. Если какой-либо из этих буферов оказывается заполнен, мы удаляем из него самый старый элемент. Если требуется повторить отрисовку содержимого какого-то буфера, мы выстраиваем для LVGL путь прохождения строк, используя масштабированные значения, после чего его отрисовываем.

В случае второго экрана всё немного сложнее, даже несмотря на то, что здесь мы считываем только частоту CPU и GPU. Причина в отсутствии рабочего диапазона значений, то есть нам неизвестны верхние и нижние пределы скорости ваших процессоров и графических ускорителей.

В связи с этим коду приходится отслеживать наблюдаемые максимальные и минимальные значения, используя их в качестве рабочей области. Код также обеспечивает, чтобы эти значения тарировались относительно минимума. Обе подпрограммы очень похожи, поэтому я приведу код только для второго экрана:

Обновление экрана


Единственное, что мы не разобрали – это код самого UI в ui.h. Просто его я не писала, а сгенерировала в визуальном редакторе Squareline Studio, который создаёт код для LVGL, в некотором смысле подобно редактору Windows Forms, создающему код C#.

Заключение

У нас получилась небольшая утилита, которая уже полезна сама по себе, но также может быть доработана под ваши собственные задачи.

Успехов!
Telegram-канал с полезностями и уютный чат                Скачать Скачать  приложение — 137.1 КБ (GitHub);
прошивка — 20.6 КБ (GitHub). приложение — 137.1 КБ (GitHub); приложение GitHub прошивка — 20.6 КБ (GitHub). прошивка GitHub  Что потребуется Что потребуется  T-Display S3, либо придётся адаптировать код под иное устройство.
PlatformIO. Хотя можно использовать и Arduino IDE, но тогда нужно будет внести кое-какие изменения, в основном переименовать и переместить некоторые файлы.
Windows 10/11 с правами администратора.
Visual Studio 2019 или новее, а также .NET Framework. T-Display S3, либо придётся адаптировать код под иное устройство. T-Display S3 PlatformIO. Хотя можно использовать и Arduino IDE, но тогда нужно будет внести кое-какие изменения, в основном переименовать и переместить некоторые файлы. Windows 10/11 с правами администратора. Visual Studio 2019 или новее, а также .NET Framework.  Пояснения Пояснения    Open Hardware Monitor   LVGL   Код Код  ▍ Приложение для ПК ▍ Приложение для ПК      ‘#’ ‘@’ SerialPort.DataReceived ‘#’ ‘@’ post message     Считывание данных Считывание данных          Обнаружение порта Обнаружение порта        Сбор информации Сбор информации        Прошивка T-Display S3 Прошивка T-Display S3  Примечание: перед компиляцией прошивки вам нужно будет сначала скопировать libdeps/include/lv_conf.h в подкаталог /.pio/libdeps, иначе она не скомпилируется. Примечание: libdeps/include/lv_conf.h /.pio/libdeps    Настройка Настройка        loop()   static int ticker = 0;
void loop() {
    button_prev.update();
    button_next.update();
    if (ticker++ >= 33) {
        ticker = 0;
        switch (screen) {
            case 0:
                update_screen_0();
            break;
            case 1:
                update_screen_1();
            break;
        }
    }

    lv_timer_handler();
    delay(3);
} static int ticker = 0;
void loop() {
    button_prev.update();
    button_next.update();
    if (ticker++ >= 33) {
        ticker = 0;
        switch (screen) {
            case 0:
                update_screen_0();
            break;
            case 1:
                update_screen_1();
            break;
        }
    }

    lv_timer_handler();
    delay(3);
}    cpu_graph gpu_graph       Обновление экрана Обновление экрана      ui.h Squareline Studio   Заключение Заключение     Telegram-канал с полезностями и уютный чат Telegram-канал с полезностями и уютный чат Telegram-канал с полезностями и уютный чат Telegram-канал с полезностями уютный чат  ]]></text>
</doc>
