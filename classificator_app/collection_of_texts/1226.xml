<?xml version="1.0" ?>
<doc>
	<label auto="true" type="str" verify="true"><![CDATA[Other]]></label>
	<author auto="true" type="list" verify="true">
		<item type="str"><![CDATA[AlinaZykina]]></item>
	</author>
	<date auto="true" type="str" verify="true"><![CDATA[2022-06-18, 18:13]]></date>
	<link auto="true" type="str" verify="true"><![CDATA[https://habr.com/ru/post/670868/]]></link>
	<title auto="true" type="str" verify="true"><![CDATA[Советы для UI/UX Дизайнера. 3 часть]]></title>
	<categories auto="true" type="list" verify="true">
		<item type="str"><![CDATA[Интерфейсы]]></item>
		<item type="str"><![CDATA[Дизайн мобильных приложений]]></item>
		<item type="str"><![CDATA[Графический дизайн]]></item>
		<item type="str"><![CDATA[Дизайн]]></item>
	</categories>
	<key_words auto="true" type="list" verify="true">
		<item type="str"><![CDATA[дизайн]]></item>
		<item type="str"><![CDATA[советы]]></item>
		<item type="str"><![CDATA[советы и рекомендации]]></item>
		<item type="str"><![CDATA[ui]]></item>
		<item type="str"><![CDATA[ui/ux]]></item>
		<item type="str"><![CDATA[ux]]></item>
		<item type="str"><![CDATA[ux/ui]]></item>
		<item type="str"><![CDATA[ux design]]></item>
		<item type="str"><![CDATA[ui/ux дизайн]]></item>
		<item type="str"><![CDATA[дизайнеру]]></item>
	</key_words>
	<text auto="true" type="str" verify="true"><![CDATA[Автор: А.Ш.
1 совет. Встроенная проверка ошибок
Отображение совершенной пользователем ошибки при заполнении формы, идеально вкладывается на самом первом этапе, а не после, тк это заставляет людей выполнять дополнительную работу и создает для них когнитивную нагрузку. В результате чего, заполнение формы может занять куда больше времени, тк пользователь попадает в луп действий, которые постоянно его откатывают назад.
Думаю у всех было такое, когда ты заполнил огроменную форму, нажал кнопку отправить, и получил потрясающий заряд бешенности на весь день.
а. Показывай встроенную проверку для input'a. Ошибку, показанную в контексте (например справа) можно легко и мгновенно исправить:
а. Встроенная проверка
b. Обрати внимание на чеклист для создания (если необходимо) сложного пароля. Например, хорошо его сделать интерактивным. В момент, когда ты заполняешь поле – галочки автоматически проставляются. Они как бы сигнализируют о том, что ты все сделал правильно, проводя тебя по этому увлекательному маршруту:
 b.  Чек-лист
2 совет. Поля ввода или input
a. Не забывай про лейблы. Проектируя поля ввода не оставляй пользователя без подсказки, в момент когда он уже ввел данные в input. Обязательно оставь возможность пользователю вернуться и не забыть с каким полем он работал:
а. Поля ввода или Input
b. Добавь возможность быстро стереть данные. Например, если пользователь ошибся, а введено уж больно большое количество символов:
b. Быстрое удаление
с. Автоматический переход к следующему полю ввода когда пользователь ввел необходимое количество символов:
с. Автоматический переход
3 совет. Состояние системы
Для правильной коммуникации с пользователем, система всегда должна сообщать свое текущее состояние. Обрати внимание на свои электронные часы, они ведь показывают уведомления, и какое количество заряда осталось, а указатели в метро сообщают на какой станции ты находишься, мессенджеры сигнализируют сколько непрочитанных сообщений и так далее.
Что ж, всякий раз при взаимодействии с твоим продуктом, пользователь ожидает узнать было-ли действие успешным, ну или просто узнать, было ли оно вообще. Информирование пользователей о текущем статусе позволяет им идти в правильном направлении не затрачивая своих усилий, где интерфейс как бы несет это бремя на себе, освобождая пару килобайт памяти в голове пользователя на более приятные вещи.
а. Изменение цвета кнопки при нажатии, или индикатор загрузки определенного процесса:
а. Состояния кнопок
b. Голосовые интерфейсы отображают анимационное кольцо, показывая, что они слушают пользователя:
b. Голосовые интерфейсы
с. Если товар закончился, электронная коммерция уведомляет пользователя об его отсутствии, тем самым избавляя клиента от потери времени, а также останавливая рост недоверия к сервису:
с. Электронная коммерция
d. Товары, которые были ранее добавлены в избранное не исчезают без согласия пользователя, а остаются с особой пометкой (например: Нет в наличии). Поэтому хорошо бы добавить уведомление о том, что произошли некоторые изменения в разделе избранное:
d. Товары
е. В сервисах оплаты могут возникнуть определенные ограничения.
Поэтому нужно заранее демонстрировать пользователю то, что сервис не поддерживает какой-либо вид оплаты. Не скрывай от пользователя информацию! Эта небрежность очень сильно ощущается при малейшем взаимодействии с таким сервисом, что даже не нужно проводить исследований. Для того, чтобы пользователю не пришлось делать лишних действий или испытывать гнев по поводу потраченного времени впустую – будь с ним открытым:
е. Предупреждение
4 совет. Раскрывающие списки в цифровых значениях и датах
Давай определим какой тип дат показывать при различном контексте.
а. Представим, что нам необходимо заполнить дату своего дня рождения и для нас открывается нарядный календарь. Это очень неудачное решение, т.к. такой тип даты уже заранее известен, и мы не планируем ее, ведь наш день рождения это совсем другой тип данных, это определенно строка, как серия и номер паспорта, или номер телефона. Наша задача дать пользователю поделиться воспоминанием, а не дать ему поиграть в еще один интерфейс:
а. Одинаковая вероятность дат
b. Выбирая дату встречи или планируя свою поездку, лучше использовать раскрывающийся календарь. Это вот как раз тип даты, которая заранее неизвестна ни нам, ни (часто бывает) пользователю. Демонстрируя пользователю календарные дни, он понимает в какой день недели, месяц, год он сможет подобрать билет, оформить заселение и т.д.:
b. Выбор – будущие даты

с. Выбирая значение от 1 до 15, возможно ты соблазнишься использовать раскрывающийся список, но лучше бы сделать заполнение данных быстрым и простым используя stepper:
с. Stepper
d. Если твой список из чисел довольно внушительный, например это ценовой диапазон от 1 000 до 90 000 - используй button range:
d. Range Button

На этом все! Я надеюсь тебе было полезно освежить это в своей памяти (или же изучить), а я вернусь к теме более продвинутых советов немного позже. Пока 👀  Автор: А.Ш. 1 совет. Встроенная проверка ошибок Отображение совершенной пользователем ошибки при заполнении формы, идеально вкладывается на самом первом этапе, а не после, тк это заставляет людей выполнять дополнительную работу и создает для них когнитивную нагрузку. В результате чего, заполнение формы может занять куда больше времени, тк пользователь попадает в луп действий, которые постоянно его откатывают назад. Думаю у всех было такое, когда ты заполнил огроменную форму, нажал кнопку отправить, и получил потрясающий заряд бешенности на весь день. а. Показывай встроенную проверку для input'a. Ошибку, показанную в контексте (например справа) можно легко и мгновенно исправить: а.  а. Встроенная проверка b. Обрати внимание на чеклист для создания (если необходимо) сложного пароля. Например, хорошо его сделать интерактивным. В момент, когда ты заполняешь поле – галочки автоматически проставляются. Они как бы сигнализируют о том, что ты все сделал правильно, проводя тебя по этому увлекательному маршруту: b.   b.  Чек-лист 2 совет. Поля ввода или input a. Не забывай про лейблы. Проектируя поля ввода не оставляй пользователя без подсказки, в момент когда он уже ввел данные в input. Обязательно оставь возможность пользователю вернуться и не забыть с каким полем он работал: a.  а. Поля ввода или Input b. Добавь возможность быстро стереть данные. Например, если пользователь ошибся, а введено уж больно большое количество символов: b.  b. Быстрое удаление с. Автоматический переход к следующему полю ввода когда пользователь ввел необходимое количество символов: с.  с. Автоматический переход 3 совет. Состояние системы Для правильной коммуникации с пользователем, система всегда должна сообщать свое текущее состояние. Обрати внимание на свои электронные часы, они ведь показывают уведомления, и какое количество заряда осталось, а указатели в метро сообщают на какой станции ты находишься, мессенджеры сигнализируют сколько непрочитанных сообщений и так далее. Что ж, всякий раз при взаимодействии с твоим продуктом, пользователь ожидает узнать было-ли действие успешным, ну или просто узнать, было ли оно вообще. Информирование пользователей о текущем статусе позволяет им идти в правильном направлении не затрачивая своих усилий, где интерфейс как бы несет это бремя на себе, освобождая пару килобайт памяти в голове пользователя на более приятные вещи.]]></text>
</doc>
