<?xml version="1.0" ?>
<doc>
	<label auto="true" type="str" verify="true"><![CDATA[Develop]]></label>
	<author auto="true" type="list" verify="true">
		<item type="str"><![CDATA[ForestLamp]]></item>
	</author>
	<date auto="true" type="str" verify="true"><![CDATA[2022-12-02, 20:34]]></date>
	<link auto="true" type="str" verify="true"><![CDATA[https://habr.com/ru/post/703232/]]></link>
	<title auto="true" type="str" verify="true"><![CDATA[Делегаты в Swift на простом примере]]></title>
	<categories auto="true" type="list" verify="true">
		<item type="str"><![CDATA[Разработка под iOS]]></item>
		<item type="str"><![CDATA[Разработка мобильных приложений]]></item>
		<item type="str"><![CDATA[Swift]]></item>
	</categories>
	<key_words auto="true" type="list" verify="true">
		<item type="str"><![CDATA[delegate]]></item>
		<item type="str"><![CDATA[Delegate pattern]]></item>
		<item type="str"><![CDATA[Просто о делегатах]]></item>
		<item type="str"><![CDATA[swift]]></item>
		<item type="str"><![CDATA[Swift delegate]]></item>
		<item type="str"><![CDATA[Верстка кодом]]></item>
		<item type="str"><![CDATA[удалить storyboard]]></item>
		<item type="str"><![CDATA[interface programmicaly swift]]></item>
		<item type="str"><![CDATA[делегаты swift пример]]></item>
	</key_words>
	<text auto="true" type="str" verify="true"><![CDATA[Эта статья для уровня trainee, а значит для совсем начинающих великолепных разработчиков
Основная цель статьи - рассказать просто, на примере, как можно использовать паттерн делегирования в Swift.
Статья состоит из двух частей. Первая - удалим из проекта Storyboard и напишем кодом простой интерфейс. Вторая - разберем, как с помощью делегата передать данные на предыдущий контроллер.
Часть 1
Создаем новый проект, назовем его DelegatePattern:
Галочки не понадобятся, Interface - Storyboard, Language - Swift. 
Размещать элементы будем кодом, поэтому удаляем Storyboard из проекта:
Удаляем Main.storyboard
Выбираем Move to Trash - удалить в корзину
Выбираем проект (стрелка 1), вкладка General и в разделе Deployment Info выделяем и удаляем Main(стрелка 2)
Поле Main Interface должно остаться пустым
Переходим в файл info.plist (стрелка 1) и удаляем строку Application Scene Manifest
В итоге останется только строка Information Property List
У нас не будет поддержки IPad - файл SceneDelegate можно тоже удалить:
Вот так теперь выглядит проект
Так как мы удалили Storyboard, в файле AppDelegate объявим свойство window, а в методе application didFinishLaunchingWithOptions, нужно добавить код ниже, чтобы указать стартовый контороллер.  Остальные методы удалим, в нашем проекте они использоваться не будут.
var window: UIWindow?

func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        
        window = UIWindow(frame: UIScreen.main.bounds)
        let rootVC = ViewController()
        window?.rootViewController = rootVC
        window?.makeKeyAndVisible()
        
        return true
    }
Теперь AppDelegate выглядит вот так:
Переходим во ViewController, в методе viewDidLoad добавляем фиолетовый цвет для бэкграунда view контроллера:
view.backgroundColor = .purple
Запускаем проект, и если все сделали верно, запустится симулятор с фиолетовым контроллером:
Отлично, теперь мы можем продолжать писать интерфейс в коде. Для начала создадим еще один ViewController. Нажимаем Command + N и выбираем Cocoa Touch Class:
Назовем его SecondViewController:
После создания удалите весь закоментированый код из SecondViewController. 
Поработаем с ViewController, добавим на него кнопку перехода на SecondViewController:
Строки 12 - 17
Объявим новый метод makeConstraints, в нем добавим кнопку на view и создадим констрейнты.
    private func makeConstraints() {
        
        view.addSubview(toSecondViewControllerButton) // добавляем кнопку на view
        NSLayoutConstraint.activate([
            toSecondViewControllerButton.centerXAnchor.constraint(equalTo: view.centerXAnchor), // центр по оси Х
            toSecondViewControllerButton.centerYAnchor.constraint(equalTo: view.centerYAnchor) // центр по оси Y
        ])
    }
И обязательно, нужно установить значение свойстваbutton.translatesAutoresizingMaskIntoConstraints = false в клоужере создания кнопки. Вот как теперь выглядит ViewController:
Что бы все заработало не забудьте добавить вызов makeConstraints() во viewDidLoad(). Строка 27. 
Проверим симулятор:
Кнопка есть, все отлично. 
Теперь аналогично добавим UILabel, в нем в последующем и будем менять текст при возвращении из следующего контроллера.
Можете сами потренироваться и создать лейбл. Если возникнут проблемы, подглядите здесь :)
Отлично, теперь на view есть кнопка и лейбл. Симулятор выглядят так:
Чтобы кнопка заработала и при ее нажатии открывался следующий экран, добавим ей свойство button.addTarget():
Строка 18
Объявим методtoSecondVCButtonPressed(), который будет отрабатывать по нажатию на кнопку:
Перейдем в SecondViewController и в методе viewDidLoad() добавим цвет бэкграунда view второго контроллера:
Строка 15. 
Проверяем, что получилось, собираем проект. Если все сделано верно, по нажатию на кнопку Go to second VC, откроется второй контроллер с серым фоном.
Часть 2
Пора приступать к передаче данных при закрытии "серого" контроллера. Как вы видели в названии статьи, будем использовать делегат :)
Объявим протокол SecondViewControllerDelegate в файле класса ViewController и обязательно укажем тип AnyObject. Это нужно для того, чтобы протокол работал с классами, а это, в свою очередь, позволит создавать слабые ссылки и избежать retain cycle между контроллерами. Наш протокол будет содержать только один метод - для замены текста в лейбле ViewController'a.
Реализовывать метод протокола будет ViewController, подпишем его под протокол в extension'е и напишем логику для метода, которая будет менять текст:
В аргумент text, находящийся на 68 строке, придет новый текст с другого контроллера, а на 69 строке мы заменим стандартный текст лейбла.
Если навести курсор на аргумент text, Xcode подсветит какой text к какому относится.
Переходим в SecondViewController. Помните мы создали протокол и объявили его anyObject? Теперь пора создать слабую ссылку, которая будет иметь тип делегата, она будет жить в SecondViewController и через нее мы сможем добраться до методов делегата.
Строка 12
Когда мы закрываем SecondViewController, смахивая его вниз, срабатывает метод deinit. В нашем примере это отличное место, чтобы передать новый текст в лейбл ViewController'a. Добираемся через переменную delegate до метода newTextForLabel и передаем в него новый текст для лейбла на первом контроллере "New text". (*PS: метод deinit() в статье используется только для примера, поскольку мы точно уверены в том, что контроллер выгрузится из памяти.)
Строка 20 - 22
Как пример, если создать кнопку закрытия второго экрана, тогда self.delegate?.newTextForLabel(text: "New text") поселился бы в методе, срабатывающем по нажатию на кнопку закрытия.
Все почти готово, осталось дело за малой деталью, о которой лично я всегда забываю :) нужно сообщить нашему SecondViewController, кто будет его делегатом (то есть кто будет что-то делать с теми данными которые, он отправил).
Возвращаемся в ViewController, и там, где мы создавали для кнопки метод перехода на SecondViewController подпишемся под делегата:
Строка 62
Собираем проект и проверяем:
PS: Почему текст обновляется с задержкой? Дело в том, что deinit выгружает контроллер из памяти, поэтому проходит какое-то количество времени, пока контроллер выгрузится и текст сменится. Если вы будете использовать делегат, например, в методе UIViewController'a - dismiss() или в вашем методе кнопки, то никаких задержек не будет.
GitHub с финальным проектом - ссылка.
Спасибо, что дочитали :) Эта статья для уровня trainee, а значит для совсем начинающих великолепных разработчиков Основная цель статьи - рассказать просто, на примере, как можно использовать паттерн делегирования в Swift. Swift Статья состоит из двух частей. Первая - удалим из проекта Storyboard и напишем кодом простой интерфейс. Вторая - разберем, как с помощью делегата передать данные на предыдущий контроллер. Storyboard Часть 1 Создаем новый проект, назовем его DelegatePattern: DelegatePattern:  Галочки не понадобятся, Interface - Storyboard, Language - Swift.  Размещать элементы будем кодом, поэтому удаляем Storyboard из проекта: Storyboard  Удаляем Main.storyboard  Выбираем Move to Trash - удалить в корзину Выбираем проект (стрелка 1), вкладка General и в разделе Deployment Info выделяем и удаляем Main(стрелка 2) General Deployment Info Main  Поле Main Interface должно остаться пустым Переходим в файл info.plist (стрелка 1) и удаляем строку Application Scene Manifest info.plist Application Scene Manifest  В итоге останется только строка Information Property List У нас не будет поддержки IPad - файл SceneDelegate можно тоже удалить: IPad SceneDelegate  Вот так теперь выглядит проект Так как мы удалили Storyboard, в файле AppDelegate объявим свойство window, а в методе application didFinishLaunchingWithOptions, нужно добавить код ниже, чтобы указать стартовый контороллер.  Остальные методы удалим, в нашем проекте они использоваться не будут.  Storyboard AppDelegate window application didFinishLaunchingWithOptions var window: UIWindow?

func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        
        window = UIWindow(frame: UIScreen.main.bounds)
        let rootVC = ViewController()
        window?.rootViewController = rootVC
        window?.makeKeyAndVisible()
        
        return true
    } var window: UIWindow?

func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        
        window = UIWindow(frame: UIScreen.main.bounds)
        let rootVC = ViewController()
        window?.rootViewController = rootVC
        window?.makeKeyAndVisible()
        
        return true
    } Теперь AppDelegate выглядит вот так: AppDelegate   Переходим во ViewController, в методе viewDidLoad добавляем фиолетовый цвет для бэкграунда view контроллера: ViewController viewDidLoad view  view.backgroundColor = .purple Запускаем проект, и если все сделали верно, запустится симулятор с фиолетовым контроллером:   Отлично, теперь мы можем продолжать писать интерфейс в коде. Для начала создадим еще один ViewController. Нажимаем Command + N и выбираем Cocoa Touch Class: ViewController Command + N Cocoa Touch Class   Назовем его SecondViewController: SecondViewController:  После создания удалите весь закоментированый код из SecondViewController.  Поработаем с ViewController, добавим на него кнопку перехода на SecondViewController: ViewController SecondViewController:  Строки 12 - 17 Объявим новый метод makeConstraints, в нем добавим кнопку на view и создадим констрейнты. makeConstraints view     private func makeConstraints() {
        
        view.addSubview(toSecondViewControllerButton) // добавляем кнопку на view
        NSLayoutConstraint.activate([
            toSecondViewControllerButton.centerXAnchor.constraint(equalTo: view.centerXAnchor), // центр по оси Х
            toSecondViewControllerButton.centerYAnchor.constraint(equalTo: view.centerYAnchor) // центр по оси Y
        ])
    }     private func makeConstraints() {
        
        view.addSubview(toSecondViewControllerButton) // добавляем кнопку на view
        NSLayoutConstraint.activate([
            toSecondViewControllerButton.centerXAnchor.constraint(equalTo: view.centerXAnchor), // центр по оси Х
            toSecondViewControllerButton.centerYAnchor.constraint(equalTo: view.centerYAnchor) // центр по оси Y
        ])
    } И обязательно, нужно установить значение свойстваbutton.translatesAutoresizingMaskIntoConstraints = false в клоужере создания кнопки. Вот как теперь выглядит ViewController: button.translatesAutoresizingMaskIntoConstraints = false ViewController  Что бы все заработало не забудьте добавить вызов makeConstraints() во viewDidLoad(). Строка 27.  Проверим симулятор: Кнопка есть, все отлично.   Кнопка есть, все отлично.  Теперь аналогично добавим UILabel, в нем в последующем и будем менять текст при возвращении из следующего контроллера. Можете сами потренироваться и создать лейбл. Если возникнут проблемы, подглядите здесь :) Можете сами потренироваться и создать лейбл. Если возникнут проблемы, подглядите здесь :)           Отлично, теперь на view есть кнопка и лейбл. Симулятор выглядят так: view   Чтобы кнопка заработала и при ее нажатии открывался следующий экран, добавим ей свойство button.addTarget(): button.addTarget():  Строка 18 Объявим методtoSecondVCButtonPressed(), который будет отрабатывать по нажатию на кнопку: toSecondVCButtonPressed()   Перейдем в SecondViewController и в методе viewDidLoad() добавим цвет бэкграунда view второго контроллера: SecondViewController viewDidLoad() view  Строка 15.  Проверяем, что получилось, собираем проект. Если все сделано верно, по нажатию на кнопку Go to second VC, откроется второй контроллер с серым фоном. Go to second VC    Часть 2 Пора приступать к передаче данных при закрытии "серого" контроллера. Как вы видели в названии статьи, будем использовать делегат :) Объявим протокол SecondViewControllerDelegate в файле класса ViewController и обязательно укажем тип AnyObject. Это нужно для того, чтобы протокол работал с классами, а это, в свою очередь, позволит создавать слабые ссылки и избежать retain cycle между контроллерами. Наш протокол будет содержать только один метод - для замены текста в лейбле ViewController'a. SecondViewControllerDelegate ViewController AnyObject ViewController   Реализовывать метод протокола будет ViewController, подпишем его под протокол в extension'е и напишем логику для метода, которая будет менять текст: ViewController extension   В аргумент text, находящийся на 68 строке, придет новый текст с другого контроллера, а на 69 строке мы заменим стандартный текст лейбла. text Если навести курсор на аргумент text, Xcode подсветит какой text к какому относится. text Xcode text   Переходим в SecondViewController. Помните мы создали протокол и объявили его anyObject? Теперь пора создать слабую ссылку, которая будет иметь тип делегата, она будет жить в SecondViewController и через нее мы сможем добраться до методов делегата. SecondViewController anyObject SecondViewController  Строка 12 Когда мы закрываем SecondViewController, смахивая его вниз, срабатывает метод deinit. В нашем примере это отличное место, чтобы передать новый текст в лейбл ViewController'a. Добираемся через переменную delegate до метода newTextForLabel и передаем в него новый текст для лейбла на первом контроллере "New text". (*PS: метод deinit() в статье используется только для примера, поскольку мы точно уверены в том, что контроллер выгрузится из памяти.) SecondViewController deinit ViewController delegate newTextForLabel "New text".  Строка 20 - 22 Как пример, если создать кнопку закрытия второго экрана, тогда self.delegate?.newTextForLabel(text: "New text") поселился бы в методе, срабатывающем по нажатию на кнопку закрытия. self.delegate?.newTextForLabel(text: "New text") Все почти готово, осталось дело за малой деталью, о которой лично я всегда забываю :) нужно сообщить нашему SecondViewController, кто будет его делегатом (то есть кто будет что-то делать с теми данными которые, он отправил). SecondViewController Возвращаемся в ViewController, и там, где мы создавали для кнопки метод перехода на SecondViewController подпишемся под делегата: ViewController, SecondViewController  Строка 62 Собираем проект и проверяем:    PS: Почему текст обновляется с задержкой? Дело в том, что deinit выгружает контроллер из памяти, поэтому проходит какое-то количество времени, пока контроллер выгрузится и текст сменится. Если вы будете использовать делегат, например, в методе UIViewController'a - dismiss() или в вашем методе кнопки, то никаких задержек не будет. deinit UIViewController dismiss() GitHub с финальным проектом - ссылка. ссылка Спасибо, что дочитали :) ]]></text>
</doc>
