<?xml version="1.0" ?>
<doc>
	<label auto="true" type="str" verify="true"><![CDATA[Develop]]></label>
	<author auto="true" type="list" verify="true">
		<item type="str"><![CDATA[shasoftX]]></item>
	</author>
	<date auto="true" type="str" verify="true"><![CDATA[2022-12-09, 06:08]]></date>
	<link auto="true" type="str" verify="true"><![CDATA[https://habr.com/ru/post/703712/]]></link>
	<title auto="true" type="str" verify="true"><![CDATA[Берем абсурдную идею и находим ей применение]]></title>
	<categories auto="true" type="list" verify="true">
		<item type="str"><![CDATA[Системы управления версиями]]></item>
		<item type="str"><![CDATA[Резервное копирование]]></item>
	</categories>
	<key_words auto="true" type="list" verify="true">
		<item type="str"><![CDATA[резервное копирование]]></item>
		<item type="str"><![CDATA[backup]]></item>
	</key_words>
	<text auto="true" type="str" verify="true"><![CDATA[Абсурдная идея
Если создать в интернете базу данных всех существующих файлов, то любой архив будет представлять собой список имен каталогов, файлов, дата+время изменения/создания и хеши этих файлов. А при распаковке архива достаточно будет просто скачать из интернета содержимое файла по его хешу, записать на диск и присвоить атрибуты (дата,время). Т.е. даже архив с полным сезоном какого-нибудь сериала из 20 серий будет занимать не больше нескольких килобайт (в независимости от качества видео).
Всем понятно, что создать базу хешей всех файлов просто физически невозможно. И даже не потому что для этого требуется большой объем для хранения файлов, а потому что новые файлы появляются каждую секунду. И такая online база данных просто не будет успевать сохранять огромный массив данных.
Уменьшение абсурда
Упростим условия и будем ограничится не всеми файлами, а только какой-то группой файлов. В этом случае скорость появления новых файлов будет не такой огромной и объем данных также будет в разумных пределах.
И самое очевидное применение такого подхода - это система контроля версий  файлов. Т.е. мы будем ограничиваться только файлами одного проекта.
Небольшое лирическое отступление
Формализация задачи
Сохранение всех элементов (файлов, каталогов, ссылок) папки проекта с возможностью вернуться к любому сохраненному состоянию.
Проект - папка(директория) с элементами. Элементом может быть
Файл
Директория
Символьная ссылка (если она указывает на элемент внутри проекта)
Состояние проекта - список всех имен элементов проекта +  их состояния.
Состояние элемента определяется как
Файл - имя(путь внутри проекта)+хеш файла + размер + дата/время последнего изменения
Директория - имя(путь внутри проекта)
Символьная ссылка - имя(путь внутри проекта) + относительный путь (относительно базового пути проекта) на ссылающийся элемент
ХЕШ файла = хеш (SHA-3+crc32) данных файла + размер файла
Трансформация - список команд (добавление, удаление), которые переводят проект из предыдущего состояние в следующее.
Команда трансформации - состоит из
Тип команды
D Добавление элемента
R Удаление элемента
Имя элемента
Данные команды (только для команды Добавления)
Добавление каталога - нет данных
Добавление ссылки
LINK - ссылка на элемент
Добавление файла
HASH - хеш данных файла
SIZE - размер
TIME - дата/время изменения
Описание процесса сохранения на сервер
Первоначально папка проекта находится в состоянии "пусто". Трансформация 1 переводит её в Состояние 1. В трансформации 1 две команды, которые добавляют два файла. Затем трансформация 2 переводит проект в Состояние 2. Во второй трансформации четыре команды: удаление file1.txt, удалить file2.txt, добавить file2.txt, добавление file3.txt
Схема процесса сохранения:
Сканируем папку проекта и получаем список состояний всех локальных элементов.
Запрашиваем с сервера все трансформации проекта.
Выполняем все трансформации и получаем состояние проекта на сервере.
Определяем трансформацию со списком команд, которые переводят проект из состояние на сервере в локальное состояние.
Отправляем на сервер все новые файлы.
Отправляем на сервер новую трансформацию.
Процесс восстановления аналогичен, только трансформация со списком команд строится для перевода из состояния сервера в локальное состояние.
Для получения нужного состояния клиенту необходимо скачать все трансформации, предшествовавшие этому состоянию, и выполнить их у себя.
Сервер хранения
Сервер хранения будет выступать только как хранилище файлов. Использовать можно FTP, HTTP или облачное API. В простейшем случае в качестве сервера хранилища может выступать каталог на локальном компьютере или сетевом диске.
Файловая структура хранилища:
files - все файлы хранилища. Имя файла это хеш файла.
projects - проекты
имя проекта
NN трансформации - номер трансформации. От 1 до 4.294.967.295
Алгоритм запроса с сервера состояний элементов (т.е. всех трансформаций проекта):
Читаем в корне директории проекта файл `shasoft-vcs.json` и из него получаем имя проекта.
Номер трансформации NN = 1.
Проверяем на сервере наличие трансформации NN в файле `projects/<хеш имени проекта>/NN`. Если нет то КОНЕЦ.
Читаем с сервера трансформацию NN.
NN = NN + 1.
Идти к пп.3.
При сохранении новых трансформаций определяем последний номер трансформации и сохраняем новые трансформации под следующем номером на сервер.
Для уменьшения размера будем упаковывать список трансформаций (и файлы) в архив GZIP. Как вариант, можно прикрутить и другой формат упаковки. Однако реализация GZIP у меня есть + этот формат может распаковывать PHP. Что удобно если я всё-таки сделаю HTTP сервер аля github.
Реализация работы с хранилищем
Адрес сервера хранения задаётся в виде: <тип хранилища>://<параметры хранилища>
Функции работы с хранилищем располагаются в dll с именем storage-<тип хранилища>. Динамическая библиотека должна реализовать следующие функции:
int32 storage_connect(const byte *url) - установить соединение
Возвращает идентификатор соединения или 0 в случае ошибки
void storage_disconnect(int32 idConnect) - разорвать соединение
int32 storage_upload(int32 idConnect, const byte *filepathFrom, const byte *filenameTo) - записать файл в хранилище
Возвращает статус выполнения операции
0 - Ok
1 - Ошибка записи, так как файл с таким именем уже существует
99 - Ошибка записи
int32 storage_download(int32 idConnect, const byte *filenameFrom, const byte *filepathTo) - получить файл из хранилища
Возвращает статус выполнения операции
0 - Ok
1 - Ошибка чтения, так как файла с таким именем не существует
99 - Ошибка чтения
int32 storage_file_exists(int32 idConnect, const byte *filename) - проверить существование файла
Возвращает статус выполнения операции
0 - файл НЕ существует
1 - файл существует
99 - Ошибка
Имена файлов передаются в виде utf-8 строки с символом \0 в конце.
На текущий момент поддерживается два типа хранилища:
fs - файловая система. Пример адреса `fs://<путь до каталога хранилища>`
ftp - работа с FTP. Пример адреса `ftp//:[[<логин>[:<пароль>]@]<хост>[:<порт>]][/<папка на сервере>]`
Безопасность
Слабая сторона данной схемы - безопасность. В общем случае нет возможности на сервере проверить имя пользователя (потому что сервер выступает как файловое хранилище и не может выполнять функции авторизации). А значит любой, кто знает параметры доступа к файловому серверу может удалить или изменить там данные. Как вариант решения - отключить эту возможность, оставив только возможность добавления файлов. В этом случае вредитель не сможет удалить или изменить данные. Но сможет добавить некоректные значения. Что тоже не очень хорошо.
Вариант решения тут только один - сделать специальный файловый сервер (к примеру HTTP/HTTPS) для работы с системой контроля версий который будет проверять авторизацию пользователя и не давать выполнять какие-то действия, если у пользователя нет на это прав.
Справка по работе с программой
Shasoft VCS version 1.0.0-beta.15
Usage: shasoft-vcs.exe -m -s [-l] [-n] [--nosave] folder
Positional arguments:
  folder Project folder
Optional arguments:
  -m, --mode    Working mode
    backup  Save data to storage
    restore Restore data from storage
  -s, --storage Link to storage/Storage ID
  -l, --log     Display log on screen
  -n, --nn      Recovery Version ID
  --nosave      Without saving the result
Storage ID settings file:
  <...>/AppData/Roaming/Shasoft VCS/storages.json
folder - папка проекта. В указанной папке ищется файл `shasoft-vcs.json` с именем проекта.
{
  "name" : "<имя проекта в формате /[a-zA-Z0-9_@$\\-]{1,}\\/[a-zA-Z0-9_@$\\-]{1,}/>"
}
В случае отсутствия поиск продолжается в родительской папке. И так до самого верхнего уровня. Если файл с именем проекта не найден, то ошибка. Если найден, то происходит сохранение в найденный проект. При этом сохраняется только указанная папка, а не весь проект. Т.е. если файл проекта находится в `c:/myproject/shasoft-vcs.json` и указана папка `c:/myproject/aaa/bbb`, то сохранится/восстановится только папка проекта `aaa/bbb`.
-m, --mode - режим работы. Два значения
backup - сохранение
restore - восстановление
-s, --storage - адрес/псевдоним хранилища.
-n, --nn - номер версии для восстановления
--save - без внесения изменений. Режим добавлен для тестирования системы игнорирования элементов проекта через файл .gitignore
Внизу указывается расположение файла с соответствиями псевдонима хранилища его адресу в формате
{
  "<псевдоним 1>" : "<адрес 1>",
  "<псевдоним 1>" : "<адрес 1>",
  ...
}
Так как файл с псевдонимами хранится в директории пользователя, то таким образом можно скрыть адреса хранилищ от других пользователей компьютера.
Планы
1. Добавить шифрование. Это позволит создавать хранилища даже в облаке без опасения что данные "утекут"
2. Собрать программу под linux. Для этого проект был переведен на cmake. Установил VSCode в Simply Linux. Нужно разбираться дальше.
Ссылка на программу Абсурдная идея Если создать в интернете базу данных всех существующих файлов, то любой архив будет представлять собой список имен каталогов, файлов, дата+время изменения/создания и хеши этих файлов. А при распаковке архива достаточно будет просто скачать из интернета содержимое файла по его хешу, записать на диск и присвоить атрибуты (дата,время). Т.е. даже архив с полным сезоном какого-нибудь сериала из 20 серий будет занимать не больше нескольких килобайт (в независимости от качества видео). всех Всем понятно, что создать базу хешей всех файлов просто физически невозможно. И даже не потому что для этого требуется большой объем для хранения файлов, а потому что новые файлы появляются каждую секунду. И такая online база данных просто не будет успевать сохранять огромный массив данных. Уменьшение абсурда Упростим условия и будем ограничится не всеми файлами, а только какой-то группой файлов. В этом случае скорость появления новых файлов будет не такой огромной и объем данных также будет в разумных пределах. И самое очевидное применение такого подхода - это система контроля версий  файлов. Т.е. мы будем ограничиваться только файлами одного проекта. система контроля версий Небольшое лирическое отступление Небольшое лирическое отступление   Формализация задачи Сохранение всех элементов (файлов, каталогов, ссылок) папки проекта с возможностью вернуться к любому сохраненному состоянию. Проект - папка(директория) с элементами. Элементом может быть
Файл
Директория
Символьная ссылка (если она указывает на элемент внутри проекта)
Состояние проекта - список всех имен элементов проекта +  их состояния.
Состояние элемента определяется как
Файл - имя(путь внутри проекта)+хеш файла + размер + дата/время последнего изменения
Директория - имя(путь внутри проекта)
Символьная ссылка - имя(путь внутри проекта) + относительный путь (относительно базового пути проекта) на ссылающийся элемент
ХЕШ файла = хеш (SHA-3+crc32) данных файла + размер файла
Трансформация - список команд (добавление, удаление), которые переводят проект из предыдущего состояние в следующее.
Команда трансформации - состоит из
Тип команды
D Добавление элемента
R Удаление элемента
Имя элемента
Данные команды (только для команды Добавления)
Добавление каталога - нет данных
Добавление ссылки
LINK - ссылка на элемент
Добавление файла
HASH - хеш данных файла
SIZE - размер
TIME - дата/время изменения Проект - папка(директория) с элементами. Элементом может быть
Файл
Директория
Символьная ссылка (если она указывает на элемент внутри проекта) Проект - папка(директория) с элементами. Элементом может быть Проект Файл
Директория
Символьная ссылка (если она указывает на элемент внутри проекта) Файл Файл Файл Директория Директория Директория Символьная ссылка (если она указывает на элемент внутри проекта) Символьная ссылка (если она указывает на элемент внутри проекта) Символьная ссылка Состояние проекта - список всех имен элементов проекта +  их состояния. Состояние проекта - список всех имен элементов проекта +  их состояния. Состояние проекта Состояние элемента определяется как
Файл - имя(путь внутри проекта)+хеш файла + размер + дата/время последнего изменения
Директория - имя(путь внутри проекта)
Символьная ссылка - имя(путь внутри проекта) + относительный путь (относительно базового пути проекта) на ссылающийся элемент Состояние элемента определяется как Состояние элемента Файл - имя(путь внутри проекта)+хеш файла + размер + дата/время последнего изменения
Директория - имя(путь внутри проекта)
Символьная ссылка - имя(путь внутри проекта) + относительный путь (относительно базового пути проекта) на ссылающийся элемент Файл - имя(путь внутри проекта)+хеш файла + размер + дата/время последнего изменения Файл - имя(путь внутри проекта)+хеш файла + размер + дата/время последнего изменения Файл Директория - имя(путь внутри проекта) Директория - имя(путь внутри проекта) Директория Символьная ссылка - имя(путь внутри проекта) + относительный путь (относительно базового пути проекта) на ссылающийся элемент Символьная ссылка - имя(путь внутри проекта) + относительный путь (относительно базового пути проекта) на ссылающийся элемент Символьная ссылка ХЕШ файла = хеш (SHA-3+crc32) данных файла + размер файла ХЕШ файла = хеш (SHA-3+crc32) данных файла + размер файла ХЕШ файла Трансформация - список команд (добавление, удаление), которые переводят проект из предыдущего состояние в следующее. Трансформация - список команд (добавление, удаление), которые переводят проект из предыдущего состояние в следующее. Трансформация добавление удаление Команда трансформации - состоит из
Тип команды
D Добавление элемента
R Удаление элемента
Имя элемента
Данные команды (только для команды Добавления)
Добавление каталога - нет данных
Добавление ссылки
LINK - ссылка на элемент
Добавление файла
HASH - хеш данных файла
SIZE - размер
TIME - дата/время изменения Команда трансформации - состоит из Команда трансформации Тип команды
D Добавление элемента
R Удаление элемента
Имя элемента
Данные команды (только для команды Добавления)
Добавление каталога - нет данных
Добавление ссылки
LINK - ссылка на элемент
Добавление файла
HASH - хеш данных файла
SIZE - размер
TIME - дата/время изменения Тип команды
D Добавление элемента
R Удаление элемента Тип команды D Добавление элемента
R Удаление элемента D Добавление элемента D Добавление элемента D R Удаление элемента R Удаление элемента R Имя элемента Имя элемента Данные команды (только для команды Добавления)
Добавление каталога - нет данных
Добавление ссылки
LINK - ссылка на элемент
Добавление файла
HASH - хеш данных файла
SIZE - размер
TIME - дата/время изменения Данные команды (только для команды Добавления) Добавление каталога - нет данных
Добавление ссылки
LINK - ссылка на элемент
Добавление файла
HASH - хеш данных файла
SIZE - размер
TIME - дата/время изменения Добавление каталога - нет данных Добавление каталога - нет данных Добавление ссылки
LINK - ссылка на элемент Добавление ссылки LINK - ссылка на элемент LINK - ссылка на элемент LINK - ссылка на элемент LINK Добавление файла
HASH - хеш данных файла
SIZE - размер
TIME - дата/время изменения Добавление файла HASH - хеш данных файла
SIZE - размер
TIME - дата/время изменения HASH - хеш данных файла HASH - хеш данных файла HASH SIZE - размер SIZE - размер SIZE TIME - дата/время изменения TIME - дата/время изменения TIME Описание процесса сохранения на сервер Первоначально папка проекта находится в состоянии "пусто". Трансформация 1 переводит её в Состояние 1. В трансформации 1 две команды, которые добавляют два файла. Затем трансформация 2 переводит проект в Состояние 2. Во второй трансформации четыре команды: удаление file1.txt, удалить file2.txt, добавить file2.txt, добавление file3.txt Трансформация 1 Состояние 1 трансформации 1 трансформация 2 Состояние 2    Схема процесса сохранения: Сканируем папку проекта и получаем список состояний всех локальных элементов.
Запрашиваем с сервера все трансформации проекта.
Выполняем все трансформации и получаем состояние проекта на сервере.
Определяем трансформацию со списком команд, которые переводят проект из состояние на сервере в локальное состояние.
Отправляем на сервер все новые файлы.
Отправляем на сервер новую трансформацию. Сканируем папку проекта и получаем список состояний всех локальных элементов. Сканируем папку проекта и получаем список состояний всех локальных элементов. Запрашиваем с сервера все трансформации проекта. Запрашиваем с сервера все трансформации проекта. Выполняем все трансформации и получаем состояние проекта на сервере. Выполняем все трансформации и получаем состояние проекта на сервере. Определяем трансформацию со списком команд, которые переводят проект из состояние на сервере в локальное состояние. Определяем трансформацию со списком команд, которые переводят проект из состояние на сервере в локальное состояние. Отправляем на сервер все новые файлы. Отправляем на сервер все новые файлы. Отправляем на сервер новую трансформацию. Отправляем на сервер новую трансформацию. Процесс восстановления аналогичен, только трансформация со списком команд строится для перевода из состояния сервера в локальное состояние. Для получения нужного состояния клиенту необходимо скачать все трансформации, предшествовавшие этому состоянию, и выполнить их у себя. Сервер хранения Сервер хранения будет выступать только как хранилище файлов. Использовать можно FTP, HTTP или облачное API. В простейшем случае в качестве сервера хранилища может выступать каталог на локальном компьютере или сетевом диске. Файловая структура хранилища: files - все файлы хранилища. Имя файла это хеш файла.
projects - проекты
имя проекта
NN трансформации - номер трансформации. От 1 до 4.294.967.295 files - все файлы хранилища. Имя файла это хеш файла. files - все файлы хранилища. Имя файла это хеш файла. files projects - проекты
имя проекта
NN трансформации - номер трансформации. От 1 до 4.294.967.295 projects - проекты projects имя проекта
NN трансформации - номер трансформации. От 1 до 4.294.967.295 имя проекта
NN трансформации - номер трансформации. От 1 до 4.294.967.295 имя проекта имя проекта NN трансформации - номер трансформации. От 1 до 4.294.967.295 NN трансформации - номер трансформации. От 1 до 4.294.967.295 NN трансформации - номер трансформации. От 1 до 4.294.967.295 NN трансформации Алгоритм запроса с сервера состояний элементов (т.е. всех трансформаций проекта): Читаем в корне директории проекта файл `shasoft-vcs.json` и из него получаем имя проекта.
Номер трансформации NN = 1.
Проверяем на сервере наличие трансформации NN в файле `projects/<хеш имени проекта>/NN`. Если нет то КОНЕЦ.
Читаем с сервера трансформацию NN.
NN = NN + 1.
Идти к пп.3. Читаем в корне директории проекта файл `shasoft-vcs.json` и из него получаем имя проекта. Читаем в корне директории проекта файл `shasoft-vcs.json` и из него получаем имя проекта. Номер трансформации NN = 1. Номер трансформации NN = 1. Проверяем на сервере наличие трансформации NN в файле `projects/<хеш имени проекта>/NN`. Если нет то КОНЕЦ. Проверяем на сервере наличие трансформации NN в файле `projects/<хеш имени проекта>/NN`. Если нет то КОНЕЦ. Читаем с сервера трансформацию NN. Читаем с сервера трансформацию NN. NN = NN + 1. NN = NN + 1. Идти к пп.3. Идти к пп.3. При сохранении новых трансформаций определяем последний номер трансформации и сохраняем новые трансформации под следующем номером на сервер. Для уменьшения размера будем упаковывать список трансформаций (и файлы) в архив GZIP. Как вариант, можно прикрутить и другой формат упаковки. Однако реализация GZIP у меня есть + этот формат может распаковывать PHP. Что удобно если я всё-таки сделаю HTTP сервер аля github. Реализация работы с хранилищем Адрес сервера хранения задаётся в виде: <тип хранилища>://<параметры хранилища> тип хранилища параметры хранилища Функции работы с хранилищем располагаются в dll с именем storage-<тип хранилища>. Динамическая библиотека должна реализовать следующие функции: storage-<тип хранилища> int32 storage_connect(const byte *url) - установить соединение
Возвращает идентификатор соединения или 0 в случае ошибки
void storage_disconnect(int32 idConnect) - разорвать соединение
int32 storage_upload(int32 idConnect, const byte *filepathFrom, const byte *filenameTo) - записать файл в хранилище
Возвращает статус выполнения операции
0 - Ok
1 - Ошибка записи, так как файл с таким именем уже существует
99 - Ошибка записи
int32 storage_download(int32 idConnect, const byte *filenameFrom, const byte *filepathTo) - получить файл из хранилища
Возвращает статус выполнения операции
0 - Ok
1 - Ошибка чтения, так как файла с таким именем не существует
99 - Ошибка чтения
int32 storage_file_exists(int32 idConnect, const byte *filename) - проверить существование файла
Возвращает статус выполнения операции
0 - файл НЕ существует
1 - файл существует
99 - Ошибка int32 storage_connect(const byte *url) - установить соединение
Возвращает идентификатор соединения или 0 в случае ошибки int32 storage_connect(const byte *url) - установить соединение storage_connect *url) - установить соединение Возвращает идентификатор соединения или 0 в случае ошибки Возвращает идентификатор соединения или 0 в случае ошибки Возвращает идентификатор соединения или 0 в случае ошибки void storage_disconnect(int32 idConnect) - разорвать соединение void storage_disconnect(int32 idConnect) - разорвать соединение storage_disconnect разорвать соединение int32 storage_upload(int32 idConnect, const byte *filepathFrom, const byte *filenameTo) - записать файл в хранилище
Возвращает статус выполнения операции
0 - Ok
1 - Ошибка записи, так как файл с таким именем уже существует
99 - Ошибка записи int32 storage_upload(int32 idConnect, const byte *filepathFrom, const byte *filenameTo) - записать файл в хранилище storage_upload *filepathFrom, const byte *filenameTo) - записать файл в хранилище Возвращает статус выполнения операции
0 - Ok
1 - Ошибка записи, так как файл с таким именем уже существует
99 - Ошибка записи Возвращает статус выполнения операции
0 - Ok
1 - Ошибка записи, так как файл с таким именем уже существует
99 - Ошибка записи Возвращает статус выполнения операции 0 - Ok
1 - Ошибка записи, так как файл с таким именем уже существует
99 - Ошибка записи 0 - Ok 0 - Ok 0 1 - Ошибка записи, так как файл с таким именем уже существует 1 - Ошибка записи, так как файл с таким именем уже существует 1 99 - Ошибка записи 99 - Ошибка записи 99 int32 storage_download(int32 idConnect, const byte *filenameFrom, const byte *filepathTo) - получить файл из хранилища
Возвращает статус выполнения операции
0 - Ok
1 - Ошибка чтения, так как файла с таким именем не существует
99 - Ошибка чтения int32 storage_download(int32 idConnect, const byte *filenameFrom, const byte *filepathTo) - получить файл из хранилища storage_download *filenameFrom, const byte *filepathTo) - получить файл из хранилища Возвращает статус выполнения операции
0 - Ok
1 - Ошибка чтения, так как файла с таким именем не существует
99 - Ошибка чтения Возвращает статус выполнения операции
0 - Ok
1 - Ошибка чтения, так как файла с таким именем не существует
99 - Ошибка чтения Возвращает статус выполнения операции 0 - Ok
1 - Ошибка чтения, так как файла с таким именем не существует
99 - Ошибка чтения 0 - Ok 0 - Ok 0 1 - Ошибка чтения, так как файла с таким именем не существует 1 - Ошибка чтения, так как файла с таким именем не существует 1 99 - Ошибка чтения 99 - Ошибка чтения 99 int32 storage_file_exists(int32 idConnect, const byte *filename) - проверить существование файла
Возвращает статус выполнения операции
0 - файл НЕ существует
1 - файл существует
99 - Ошибка int32 storage_file_exists(int32 idConnect, const byte *filename) - проверить существование файла storage_file_exists *filename) - проверить существование файла Возвращает статус выполнения операции
0 - файл НЕ существует
1 - файл существует
99 - Ошибка Возвращает статус выполнения операции Возвращает статус выполнения операции 0 - файл НЕ существует 0 - файл НЕ существует 0 1 - файл существует 1 - файл существует 1 99 - Ошибка 99 - Ошибка 99 Имена файлов передаются в виде utf-8 строки с символом \0 в конце.
На текущий момент поддерживается два типа хранилища:  fs - файловая система. Пример адреса `fs://<путь до каталога хранилища>`
ftp - работа с FTP. Пример адреса `ftp//:[[<логин>[:<пароль>]@]<хост>[:<порт>]][/<папка на сервере>]` fs - файловая система. Пример адреса `fs://<путь до каталога хранилища>` fs - файловая система. Пример адреса `fs://<путь до каталога хранилища>` fs ftp - работа с FTP. Пример адреса `ftp//:[[<логин>[:<пароль>]@]<хост>[:<порт>]][/<папка на сервере>]` ftp - работа с FTP. Пример адреса `ftp//:[[<логин>[:<пароль>]@]<хост>[:<порт>]][/<папка на сервере>]` ftp Безопасность Слабая сторона данной схемы - безопасность. В общем случае нет возможности на сервере проверить имя пользователя (потому что сервер выступает как файловое хранилище и не может выполнять функции авторизации). А значит любой, кто знает параметры доступа к файловому серверу может удалить или изменить там данные. Как вариант решения - отключить эту возможность, оставив только возможность добавления файлов. В этом случае вредитель не сможет удалить или изменить данные. Но сможет добавить некоректные значения. Что тоже не очень хорошо. Вариант решения тут только один - сделать специальный файловый сервер (к примеру HTTP/HTTPS) для работы с системой контроля версий который будет проверять авторизацию пользователя и не давать выполнять какие-то действия, если у пользователя нет на это прав. Справка по работе с программой Shasoft VCS version 1.0.0-beta.15
Usage: shasoft-vcs.exe -m -s [-l] [-n] [--nosave] folder
Positional arguments:
  folder Project folder
Optional arguments:
  -m, --mode    Working mode
    backup  Save data to storage
    restore Restore data from storage
  -s, --storage Link to storage/Storage ID
  -l, --log     Display log on screen
  -n, --nn      Recovery Version ID
  --nosave      Without saving the result
Storage ID settings file:
  <...>/AppData/Roaming/Shasoft VCS/storages.json Shasoft VCS version 1.0.0-beta.15
Usage: shasoft-vcs.exe -m -s [-l] [-n] [--nosave] folder
Positional arguments:
  folder Project folder
Optional arguments:
  -m, --mode    Working mode
    backup  Save data to storage
    restore Restore data from storage
  -s, --storage Link to storage/Storage ID
  -l, --log     Display log on screen
  -n, --nn      Recovery Version ID
  --nosave      Without saving the result
Storage ID settings file:
  <...>/AppData/Roaming/Shasoft VCS/storages.json folder - папка проекта. В указанной папке ищется файл `shasoft-vcs.json` с именем проекта. folder - папка проекта. В указанной папке ищется файл `shasoft-vcs.json` с именем проекта. folder - папка проекта. В указанной папке ищется файл `shasoft-vcs.json` с именем проекта. folder {
  "name" : "<имя проекта в формате /[a-zA-Z0-9_@$\\-]{1,}\\/[a-zA-Z0-9_@$\\-]{1,}/>"
} {
  "name" : "<имя проекта в формате /[a-zA-Z0-9_@$\\-]{1,}\\/[a-zA-Z0-9_@$\\-]{1,}/>"
} В случае отсутствия поиск продолжается в родительской папке. И так до самого верхнего уровня. Если файл с именем проекта не найден, то ошибка. Если найден, то происходит сохранение в найденный проект. При этом сохраняется только указанная папка, а не весь проект. Т.е. если файл проекта находится в `c:/myproject/shasoft-vcs.json` и указана папка `c:/myproject/aaa/bbb`, то сохранится/восстановится только папка проекта `aaa/bbb`. -m, --mode - режим работы. Два значения
backup - сохранение
restore - восстановление
-s, --storage - адрес/псевдоним хранилища.
-n, --nn - номер версии для восстановления
--save - без внесения изменений. Режим добавлен для тестирования системы игнорирования элементов проекта через файл .gitignore -m, --mode - режим работы. Два значения
backup - сохранение
restore - восстановление -m, --mode - режим работы. Два значения -m --mode backup - сохранение
restore - восстановление backup - сохранение backup - сохранение backup restore - восстановление restore - восстановление restore -s, --storage - адрес/псевдоним хранилища. -s, --storage - адрес/псевдоним хранилища. -s --storage -n, --nn - номер версии для восстановления -n, --nn - номер версии для восстановления -n --nn --save - без внесения изменений. Режим добавлен для тестирования системы игнорирования элементов проекта через файл .gitignore --save - без внесения изменений. Режим добавлен для тестирования системы игнорирования элементов проекта через файл .gitignore --save системы игнорирования Внизу указывается расположение файла с соответствиями псевдонима хранилища его адресу в формате {
  "<псевдоним 1>" : "<адрес 1>",
  "<псевдоним 1>" : "<адрес 1>",
  ...
} {
  "<псевдоним 1>" : "<адрес 1>",
  "<псевдоним 1>" : "<адрес 1>",
  ...
} Так как файл с псевдонимами хранится в директории пользователя, то таким образом можно скрыть адреса хранилищ от других пользователей компьютера. Планы 1. Добавить шифрование. Это позволит создавать хранилища даже в облаке без опасения что данные "утекут" 2. Собрать программу под linux. Для этого проект был переведен на cmake. Установил VSCode в Simply Linux. Нужно разбираться дальше. cmake VSCode Simply Linux Ссылка на программу Ссылка на программу ]]></text>
</doc>
